1
00:00:01,580 --> 00:00:05,000
卷積運算是

2
00:00:05,000 --> 00:00:06,870
一個卷積神經網路的基本建構基石之一

3
00:00:06,870 --> 00:00:10,050
使用邊緣偵測來做為一個例子

4
00:00:10,050 --> 00:00:14,030
這段影片，您將見到卷積運算如何運作

5
00:00:17,743 --> 00:00:18,943
前面影片中

6
00:00:18,943 --> 00:00:23,810
我提到有關於神經網路早期層中或許會偵測邊緣

7
00:00:23,810 --> 00:00:27,250
然後後面層或許會偵測部分的物件

8
00:00:27,250 --> 00:00:31,320
更後面的層會偵測部分完整的物件

9
00:00:31,320 --> 00:00:33,380
在這個例子中像是人臉

10
00:00:35,270 --> 00:00:40,740
在這段影片您會見到
您如何在影像中偵測邊緣

11
00:00:40,740 --> 00:00:42,360
我們來舉個例子

12
00:00:42,360 --> 00:00:46,760
像這張影像，對於電腦來找出哪些物件

13
00:00:46,760 --> 00:00:53,205
在影像中，第一件事您或許要做的是
偵測影像中的垂直邊緣

14
00:00:54,650 --> 00:00:59,470
舉個例子，這個影像有這些垂直線在欄杆上

15
00:00:59,470 --> 00:01:04,040
還有類似垂直線的這些行人的形狀

16
00:01:04,040 --> 00:01:08,420
所以這些是會被垂直邊緣偵測器
偵測到的輸出

17
00:01:09,860 --> 00:01:12,340
您或許也想偵測水平邊緣

18
00:01:12,340 --> 00:01:17,180
舉個例子，這些是很明顯的水平線在欄杆上

19
00:01:17,180 --> 00:01:20,410
還有這些也被偵測到，大約這裡

20
00:01:21,520 --> 00:01:25,034
您要如何在影像中偵測邊緣？

21
00:01:25,034 --> 00:01:26,160
讓我們來看一個例子

22
00:01:27,670 --> 00:01:31,056
這裡是一張 6乘6 灰階影像

23
00:01:31,056 --> 00:01:35,949
而因為是灰階影像，這個會是  6乘6乘1 矩陣

24
00:01:35,949 --> 00:01:40,700
而不是 6乘6乘3 ，因為沒有分開的 ＲＧＢ通道

25
00:01:41,790 --> 00:01:46,213
為了要偵測邊緣，假設是影像的垂直邊緣

26
00:01:46,213 --> 00:01:49,093
您可以建立一個 3乘3 矩陣

27
00:01:49,093 --> 00:01:53,733
在卷積神經網路的專有名詞中

28
00:01:53,733 --> 00:01:55,950
這個稱為過濾器

29
00:01:57,390 --> 00:02:01,543
我將建立一個 3乘3 過濾器

30
00:02:01,543 --> 00:02:08,679
3乘3 矩陣像這樣，1 1 1, 0 0 0, -1 -1 -1

31
00:02:08,679 --> 00:02:12,947
有時候研究論文會稱這個為核心，而不是過濾器

32
00:02:12,947 --> 00:02:16,370
但我將使用過濾器這個專有名詞在這個影片中

33
00:02:17,890 --> 00:02:22,730
您要做的是拿這個 6乘6 影像，然後卷積它

34
00:02:22,730 --> 00:02:27,107
而這樣的卷積運算記號為星號 (*)

35
00:02:29,560 --> 00:02:32,690
跟一個 3乘3 過濾器卷積

36
00:02:32,690 --> 00:02:37,410
關於符號有一點不幸的是
在數學的記號中

37
00:02:37,410 --> 00:02:41,490
星號是卷積運算的標準符號

38
00:02:41,490 --> 00:02:45,648
但在 python 中這符號也用來作為乘法

39
00:02:45,648 --> 00:02:48,440
或者說逐元素乘積

40
00:02:48,440 --> 00:02:53,009
所以這個星號有雙重目的，它是一個重載符號

41
00:02:53,009 --> 00:02:58,598
但我會試著在影片中，清楚表示星號是代表卷積

42
00:02:58,598 --> 00:03:03,844
而這個卷積運算的結果會是 4乘4 矩陣

43
00:03:03,844 --> 00:03:09,020
您可以解釋或想像它
成為一個 4乘4 影像

44
00:03:09,020 --> 00:03:13,330
而您計算這個 4乘4 輸出的方式如下

45
00:03:13,330 --> 00:03:18,522
計算第一個元素，這 4乘4 矩陣左上角的元素

46
00:03:18,522 --> 00:03:21,848
您要做的是拿這個 3乘3 過濾器

47
00:03:21,848 --> 00:03:26,254
貼在上面這個原來輸入影像
的這個 3乘3 區域

48
00:03:26,254 --> 00:03:30,920
我寫在這裡 1 1 1

49
00:03:30,920 --> 00:03:34,872
0 0 0, -1 -1 -1

50
00:03:34,872 --> 00:03:38,221
您應該做的是拿這個逐元素的乘積

51
00:03:38,221 --> 00:03:41,481
所以第一個是 3乘1

52
00:03:41,481 --> 00:03:46,377
而第二個是 1乘1, 對照下面這個是 1乘1

53
00:03:46,377 --> 00:03:50,398
然後加上 2乘1 這個

54
00:03:50,398 --> 00:03:53,340
然後將 9 個數字加起來

55
00:03:53,340 --> 00:04:00,451
所以中間這一列給您 0 x 0 + 5 x 0 + 7 x 0

56
00:04:00,451 --> 00:04:06,357
而最右邊列是 1 x -1 +

57
00:04:06,357 --> 00:04:09,088
8 x -1 + 2 x -1

58
00:04:09,088 --> 00:04:15,875
而將這些 9 個數字加起來會給您 -5

59
00:04:15,875 --> 00:04:19,340
所以我將 -5 填在這裡

60
00:04:19,340 --> 00:04:22,450
當然您可以將這 9 個數字
任何順序加起來

61
00:04:22,450 --> 00:04:27,550
我只是從第一欄開始

62
00:04:27,550 --> 00:04:29,620
然後第二欄，跟第三欄

63
00:04:29,620 --> 00:04:33,467
接下來，要計算這第二個元素

64
00:04:33,467 --> 00:04:39,526
您將這個藍色正方形往右邊移一步，像這樣

65
00:04:39,526 --> 00:04:42,100
讓我清掉這些綠色的記號

66
00:04:42,100 --> 00:04:46,330
您將做同樣的逐元素乘積然後加總

67
00:04:46,330 --> 00:04:52,501
所以您有 0 x 1 + 5 x 1 + 7 x 1

68
00:04:52,501 --> 00:04:57,400
+ 1 x 0 + 8 x 0 + 2 x 0

69
00:04:57,400 --> 00:05:03,450
+ 2 x -1 + 9 x -1 + 5 x -1

70
00:05:03,450 --> 00:05:10,791
如果您將這 9 個數字加總，您會得到 -4, 等等

71
00:05:10,791 --> 00:05:16,078
如果您在往右移一步，做這 9 個乘積跟加總，您會得到 0

72
00:05:16,078 --> 00:05:19,424
然後移到這裡，您應該得到 8

73
00:05:19,424 --> 00:05:26,017
驗證一下，您這裡有 2 + 9 + 5 會是 16

74
00:05:26,017 --> 00:05:29,165
中間這一欄給您 0

75
00:05:29,165 --> 00:05:35,110
最右邊這一欄，4 + 1 + 3 x -1 會是 -8

76
00:05:35,110 --> 00:05:39,621
所以最左邊是 16 減去 8

77
00:05:39,621 --> 00:05:43,796
會得到 8, 像是這裡這個數字

78
00:05:43,796 --> 00:05:47,738
接下來，為了給您下一行這個元素

79
00:05:47,738 --> 00:05:52,280
您要做的是拿這個藍色正方形，望下移一格

80
00:05:52,280 --> 00:05:54,450
所以現在您在這個位置

81
00:05:54,450 --> 00:05:59,920
再一次，重複逐元素乘積跟加總

82
00:05:59,920 --> 00:06:02,967
如果您這樣做，您應該會得到 -10

83
00:06:05,016 --> 00:06:11,147
然後往右移一步，您應該會得到 -2

84
00:06:11,147 --> 00:06:14,590
然後是 2, 然後 3 等等

85
00:06:14,590 --> 00:06:20,050
然後將其餘矩陣的元素填完

86
00:06:21,400 --> 00:06:26,281
確認一下，這個 -16 是從

87
00:06:26,281 --> 00:06:29,980
這右下角這個 3乘3 區域

88
00:06:31,080 --> 00:06:36,600
所以這個 6乘6 矩陣跟一個 3乘3 矩陣卷積會給您 4乘4  矩陣

89
00:06:38,182 --> 00:06:39,760
而這些影像跟過濾器

90
00:06:39,760 --> 00:06:43,390
其實只不過是一些矩陣有不同的維度

91
00:06:44,640 --> 00:06:49,779
但在最左邊這個矩陣方便上解釋為影像

92
00:06:49,779 --> 00:06:52,564
而中間這個，我們解釋為過濾器

93
00:06:52,564 --> 00:06:57,021
而在右邊這個，我們或許解釋成為另一個影像

94
00:06:57,021 --> 00:07:00,830
而這個其實是一個垂直邊緣偵測器

95
00:07:00,830 --> 00:07:03,440
下一張投影片您會知道為什麼

96
00:07:03,440 --> 00:07:06,097
在繼續之前，這裡有一個註解

97
00:07:06,097 --> 00:07:10,476
也就是當您用程式語言建立這個運算時，實際上

98
00:07:10,476 --> 00:07:13,840
大部分的程式語言會用不同的函數

99
00:07:13,840 --> 00:07:16,800
而不是用星號來作為卷積運算

100
00:07:16,800 --> 00:07:20,010
舉個例子，在程式作業時，您會

101
00:07:20,010 --> 00:07:24,040
建立一個函數稱為  conv_forward

102
00:07:24,040 --> 00:07:28,481
如果用 tensorFlow 作的時候

103
00:07:28,481 --> 00:07:34,528
有一個函數稱為 tf.nn.conv2d

104
00:07:34,528 --> 00:07:37,000
然後在其他的深度學習框架

105
00:07:37,000 --> 00:07:41,538
像是 Keras 程式框架，您之後會在課程中看到

106
00:07:41,538 --> 00:07:46,090
有一個函數稱為 Conv2D 來建置卷積，等等

107
00:07:46,090 --> 00:07:49,559
但所有對於卷積有很好支援的深度學習框架

108
00:07:49,559 --> 00:07:54,218
都會有一些函數來建置這個卷積運算

109
00:07:56,813 --> 00:07:59,756
為什麼這個的作用是用來偵測邊緣

110
00:07:59,756 --> 00:08:01,700
讓我們看另一個例子

111
00:08:03,470 --> 00:08:06,188
為了描述這個，我們將使用簡化的影像

112
00:08:06,188 --> 00:08:08,819
所以這是一個簡單的 6乘6 影像

113
00:08:08,819 --> 00:08:14,480
左邊一半的影像是 10 而右邊一半是 0

114
00:08:14,480 --> 00:08:18,734
如果您畫這個圖形，它或許像這樣，在左半邊

115
00:08:18,734 --> 00:08:21,775
是 10 給您比較亮的值

116
00:08:21,775 --> 00:08:25,060
在右邊，給您比較暗的值

117
00:08:25,060 --> 00:08:27,890
我使用會灰色陰影來代表 0

118
00:08:27,890 --> 00:08:32,110
雖然或許也可以畫成黑色

119
00:08:32,110 --> 00:08:37,654
但在影像中，清楚看到有很強烈的
垂直邊緣在正中間

120
00:08:37,654 --> 00:08:42,590
的影像中，當它從白色轉為黑色或者白色轉為暗色時

121
00:08:44,070 --> 00:08:48,808
當您將它跟一個 3乘3 過濾器卷積，

122
00:08:48,808 --> 00:08:53,048
所以這個 3乘3 過濾器可以看成這樣

123
00:08:53,048 --> 00:08:57,575
也就是白的，明亮的像素在左邊

124
00:08:57,575 --> 00:09:02,080
然後是中間色調，0 在中央，
然後是暗色在右邊

125
00:09:02,080 --> 00:09:05,290
您會得到在右邊的這個矩陣

126
00:09:06,640 --> 00:09:10,130
如果您想驗證一下

127
00:09:10,130 --> 00:09:15,815
舉個例，這個 0 是用逐元素乘積

128
00:09:15,815 --> 00:09:18,880
在這個 3乘3 區域

129
00:09:18,880 --> 00:09:23,008
所以您從最左邊這一欄 10 + 10 + 10

130
00:09:23,008 --> 00:09:26,987
中間是 0，然後 -10-10-10

131
00:09:26,987 --> 00:09:30,670
這是最終您得到這個 0 

132
00:09:30,670 --> 00:09:35,490
相對的，這個 30 是這樣來的

133
00:09:36,860 --> 00:09:41,062
也就是我們從 10+10+10

134
00:09:41,062 --> 00:09:47,190
然後是 -0, -0, 這是為什麼這裡是 30

135
00:09:47,190 --> 00:09:51,490
現在如果您畫最右邊這個影像，它會像這樣

136
00:09:51,490 --> 00:09:55,240
也就是這裡會有一個較亮的區域在中間

137
00:09:55,240 --> 00:09:59,820
而這對應到了已經偵測到這個垂直的邊緣

138
00:09:59,820 --> 00:10:03,630
就在這個 6乘6 影像的正中間

139
00:10:03,630 --> 00:10:06,920
而如果這個維度看起來有點不對勁

140
00:10:06,920 --> 00:10:09,450
這個偵測出來的邊緣真的很厚

141
00:10:09,450 --> 00:10:13,840
這只是因為我們作用在這個例子的影像很小

142
00:10:13,840 --> 00:10:17,100
如果您使用，假設 1000乘1000 影像

143
00:10:17,100 --> 00:10:22,190
而不是 6乘6 影像，那您會發現

144
00:10:22,190 --> 00:10:27,390
這樣的作法在偵測垂直邊緣作用得很好

145
00:10:27,390 --> 00:10:28,510
而在這個例子

146
00:10:28,510 --> 00:10:34,225
這個輸出影像中間亮的區域，要表達的是

147
00:10:34,225 --> 00:10:39,355
似乎是有一個很清楚的垂直邊緣
在影像的正中間

148
00:10:39,355 --> 00:10:44,280
而從這個垂直邊緣偵測
得到一個重要的直覺是

149
00:10:44,280 --> 00:10:49,315
一個垂直邊緣是 3乘3 區域，
因為我們使用了這樣的 3乘3 過濾器

150
00:10:49,315 --> 00:10:52,706
在左邊是明亮的像素

151
00:10:52,706 --> 00:10:55,104
跟您較不關心中間的值

152
00:10:55,104 --> 00:10:58,171
然後右邊是暗色的像素

153
00:10:58,171 --> 00:11:03,011
而在 6乘6 影像的中間影像其實

154
00:11:03,011 --> 00:11:07,850
可以是左邊是明亮的像素，右邊是暗色的像素

155
00:11:07,850 --> 00:11:12,120
這是為什麼它認為是有一個垂直邊緣在那裏

156
00:11:12,120 --> 00:11:16,480
而卷積運算給您一個方便的方式來表達

157
00:11:16,480 --> 00:11:20,200
如何在影像中找到垂直的邊緣

158
00:11:20,200 --> 00:11:23,720
您已經見到了卷積運算的作用

159
00:11:23,720 --> 00:11:26,430
在下一段影片，您將見到如何用這樣的方式

160
00:11:26,430 --> 00:11:30,032
利用它成為一個卷積神經網路的建構基石