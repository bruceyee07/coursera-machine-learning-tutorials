1
00:00:01,410 --> 00:00:05,830
DNN을 구축하기 위해, 기본적인 컨볼루션 연산에 한 가지 변형을

2
00:00:05,830 --> 00:00:10,675
여러분이 할 줄 알아야 하는데요, 그것은 바로 패딩입니다.

3
00:00:10,675 --> 00:00:12,232
어떻게 작동하는지 보시죠.

4
00:00:12,232 --> 00:00:15,190
지난 영상에서 본 것은

5
00:00:15,190 --> 00:00:19,385
6x6 이미지를 3x3 필터와 합성했을 때,

6
00:00:19,385 --> 00:00:23,585
4x4 행렬로 된 4x4 아웃풋이 나온다는 것이었습니다.

7
00:00:23,585 --> 00:00:28,080
이게 가능한 이유는 3x3필터로 된 가능한 위치에 놓이는 숫자들이 있기 때문입니다.

8
00:00:28,080 --> 00:00:29,470
이는

9
00:00:29,470 --> 00:00:31,780
4x4에만 가능한 위치가 있다는 뜻이죠.

10
00:00:31,780 --> 00:00:37,035
6x6매트릭스에 맞는 3x3필터가 있기 때문이기도 합니다.

11
00:00:37,035 --> 00:00:41,346
수학적으로 봤을 때,

12
00:00:41,346 --> 00:00:45,725
n x n 이미지를 f x f 필터로 합성시키면

13
00:00:45,725 --> 00:00:48,850
아웃풋의 차원은

14
00:00:48,850 --> 00:00:58,237
(n-f+1) x (n-f+1) 이 될 것입니다.

15
00:00:58,237 --> 00:00:59,665
이 예시에서,

16
00:00:59,665 --> 00:01:03,455
6-3+1 = 4 입니다.

17
00:01:03,455 --> 00:01:07,489
이것이 4x4 아웃풋을 갖게 되는 이유입니다.

18
00:01:07,489 --> 00:01:10,400
여기엔 두 가지의 단점이 있는데요, 하나는 이겁니다.

19
00:01:10,400 --> 00:01:14,790
컨벌루션 연산을 적용할 때 마다 이미지가 축소됩니다.

20
00:01:14,790 --> 00:01:17,595
6x6에서 4x4로 줄어든다면,

21
00:01:17,595 --> 00:01:21,716
여러분의 이미지가 정말 작아지기 전에 <br />단 몇 번의 연산만 수행할 수밖에 없습니다.

22
00:01:21,716 --> 00:01:23,870
1x1 정도로 줄어드는 그 때 정도까지만 말이죠.

23
00:01:23,870 --> 00:01:26,720
그러니, 모서리를 감지할 때마다 이미지가 줄어들지 않게 하거나

24
00:01:26,720 --> 00:01:29,902
다른 피쳐를 그 위에 얹고자 할 때엔,

25
00:01:29,902 --> 00:01:31,605
그게 하나의 단점이 되는 것이죠.

26
00:01:31,605 --> 00:01:33,590
두 번째 단점은 이겁니다.

27
00:01:33,590 --> 00:01:36,665
코너나 모서리에 있는 픽셀을 보면

28
00:01:36,665 --> 00:01:40,755
이 작은 픽셀이 아웃풋의 하나로서만 사용되도록 터치되어집니다.

29
00:01:40,755 --> 00:01:43,490
왜냐하면 이게 3x3영역을 건드리기 때문이죠.

30
00:01:43,490 --> 00:01:48,905
반면에 가운데에 있는 픽셀을 고르면, <br />(이 픽셀이라고 치면)

31
00:01:48,905 --> 00:01:55,380
그럼 그 픽셀과 겹쳐지는 3x3 영역이 많아지게 되고,

32
00:01:55,380 --> 00:02:01,455
다시 말해, 코너나 모서리에 있는 픽셀들이<br />아웃풋에서 훨씬 적게 사용된다고 볼 수 있습니다.

33
00:02:01,455 --> 00:02:06,390
따라서 이미지 가장자리 쪽의 <br />많은 정보를 버리는 것과 같습니다.

34
00:02:06,390 --> 00:02:08,735
이러한 두 가지 문제점을 해결하기 위해서

35
00:02:08,735 --> 00:02:12,829
축소되는 아웃풋과

36
00:02:12,829 --> 00:02:15,485
여러분이 정말 여러 층으로 이루어진 인공 신경망을 만들 때

37
00:02:15,485 --> 00:02:19,685
단계마다 이미지가 왜 줄어들면 안 되는지 살펴보세요. <br />왜냐하면 만약 여러분이

38
00:02:19,685 --> 00:02:22,038
100개의 레이어로 된 deep net을 가지고 있고,

39
00:02:22,038 --> 00:02:23,710
각 레이어마다 이미지 크기가 줄어든다면,

40
00:02:23,710 --> 00:02:27,993
100 레이어 이후에는 매우 작은 이미지만 남게 될 것이기 때문입니다.

41
00:02:27,993 --> 00:02:29,085
그래서 이게 첫 번째 문제점이었고,

42
00:02:29,085 --> 00:02:38,120
또 다른 문제는 이미지의 가장자리에서 <br />많은 정보를 버리고 있다는 것입니다.

43
00:02:38,120 --> 00:02:40,740
따라서 이 두 가지 문제점을 해결하기 위해

44
00:02:40,740 --> 00:02:44,774
여러분이 할 수 있는 것은 <br />컨벌루션 연산을 최대로 적용하는 것입니다.

45
00:02:44,774 --> 00:02:46,959
이미지를 덧붙일 수 있습니다.

46
00:02:46,959 --> 00:02:56,185
이 경우, 이미지에 <br />추가적인 경계선을 덧댄다고 생각해봅시다.

47
00:02:56,185 --> 00:03:00,670
모든 모서리 둘레에 하나의 픽셀을 추가해서 경계선을 그리는 거죠.

48
00:03:00,670 --> 00:03:02,635
그렇게 하면,

49
00:03:02,635 --> 00:03:05,517
6x6 이미지 대신에,

50
00:03:05,517 --> 00:03:09,500
이걸 덧붙여서 8x8 이미지를 만들게 되고,

51
00:03:09,500 --> 00:03:14,007
이 8x8 이미지를 3x3 필터와 컨볼브하게 되면,<br /> 이러한 결과를 만들어내게 됩니다.

52
00:03:14,007 --> 00:03:16,960
자, 4x4 이미지가 대신 6x6 이미지가 생기고,

53
00:03:16,960 --> 00:03:23,667
이제 원래의 6x6 인풋 사이즈를 유지하게 됩니다.

54
00:03:23,667 --> 00:03:25,350
따라서 습관적으로 패딩할 때

55
00:03:25,350 --> 00:03:33,296
0으로 패딩하고, p 크기만큼 패딩한다면

56
00:03:33,296 --> 00:03:34,575
이러한 경우,

57
00:03:34,575 --> 00:03:36,615
p=1과 같습니다.

58
00:03:36,615 --> 00:03:41,180
왜냐하면 픽셀의 추가적인 경계선으로 모든 테두리를 덧붙이고 있기 때문입니다.

59
00:03:41,180 --> 00:03:47,940
그리고 아웃풋은

60
00:03:47,940 --> 00:03:54,360
(n+2p-f+1) x (n+2p-f+1) 이므로,

61
00:03:54,360 --> 00:04:02,480
이는 (6+2-3+1) x (6+2-3+1) 가 됩니다.

62
00:04:02,480 --> 00:04:06,475
따라서 (6+2-3+1) 은 6이 됩니다.

63
00:04:06,475 --> 00:04:12,880
원본 사이즈를 보존한 6x6 이미지를 얻게 되는 것입니다.

64
00:04:12,880 --> 00:04:16,030
이 픽셀의 존재는 실제로

65
00:04:16,030 --> 00:04:23,330
아웃풋의 모든 셀에 영향을 주고,

66
00:04:23,330 --> 00:04:26,700
정보를 허비하는 게 아니라 덜 셈으로서

67
00:04:26,700 --> 00:04:32,715
이미지의 코너의 모서리나 이미지의 가장자리에 있는 정보는 줄어들게 됩니다.

68
00:04:32,715 --> 00:04:34,255
여기 보여드리는 것처럼,

69
00:04:34,255 --> 00:04:38,240
하나의 픽셀을 deep border를 덧붙이는 효과인데요,

70
00:04:38,240 --> 00:04:42,535
원한다면 두 개의 픽셀을 경계에 붙일 수도 있습니다. 이런 경우엔

71
00:04:42,535 --> 00:04:44,820
또 다른 경계 면에 붙일 수도 있는데요,

72
00:04:44,820 --> 00:04:50,125
여러분이 선택한 만큼 더 많은 픽셀을 붙일 수도 있겠죠.

73
00:04:50,125 --> 00:04:52,812
제 생각엔 여기 그리고 있는 건,

74
00:04:52,812 --> 00:04:55,438
이건 덧붙여진 건 2개, 즉 p=2이죠

75
00:04:55,438 --> 00:05:00,665
얼마나 많이 덧붙일 수 있는가에 대해서는,

76
00:05:00,665 --> 00:05:04,129
공통적으로 불리는 2개가 있는데요

77
00:05:04,129 --> 00:05:07,380
Valid Convolution과 Same Convolution입니다.

78
00:05:07,380 --> 00:05:10,960
대단한 이름은 아니지만, Valid Convolution에서는

79
00:05:10,960 --> 00:05:15,170
기본적으로 패딩이 없는 것을 의미합니다.

80
00:05:15,170 --> 00:05:22,600
이 경우, n x n 이미지를 f x f 필터로 컨볼브해서

81
00:05:22,600 --> 00:05:25,345
이는 (n-f+1)

82
00:05:25,345 --> 00:05:30,298
(n-f+1) x (n-f+1) 의 아웃풋을 산출하게 됩니다.

83
00:05:30,298 --> 00:05:35,060
이것은 이전 영상에서 보았던 예시와 같은 것인데요,

84
00:05:35,060 --> 00:05:37,250
n x n 이미지를

85
00:05:37,250 --> 00:05:43,095
3 x 3 필터로 컨볼브 해서 4x4 아웃풋을 도출했었습니다.

86
00:05:43,095 --> 00:05:48,545
또 다른 일반적인 선택지는

87
00:05:48,545 --> 00:05:52,660
Same Convolution인데요, 이것은 패드를 해서

88
00:05:52,660 --> 00:05:58,580
아웃풋 사이즈가 인풋 사이즈와 같은 경우를 뜻합니다.

89
00:05:58,580 --> 00:06:01,795
실제로 이 공식을 보시면,

90
00:06:01,795 --> 00:06:04,635
p 픽셀로 패드를 할 때,

91
00:06:04,635 --> 00:06:11,676
이는 마치 n+2p 그리고 나서 이 나머지인 거죠, 그렇죠?

92
00:06:11,676 --> 00:06:15,740
-f+1

93
00:06:15,740 --> 00:06:22,125
nxn 이미지와 온 테두리를 p 픽셀로 패딩하였다면,

94
00:06:22,125 --> 00:06:28,900
이 아웃풋의 차원은 n +2p-f+1을 곱한 것과 같습니다.

95
00:06:28,900 --> 00:06:36,080
따라서 만약 n+2p-f+1이 n이 되려면

96
00:06:36,080 --> 00:06:38,795
즉, 아웃풋 사이즈가 인풋 사이즈와 같아지려면,

97
00:06:38,795 --> 00:06:42,905
이걸 계산하면

98
00:06:42,905 --> 00:06:46,664
양변에 n 을 지워주고, p에 대해 풀어보면

99
00:06:46,664 --> 00:06:53,463
p는 2분의 f-1 이 됩니다.

100
00:06:53,463 --> 00:06:56,181
f가 홀수이면

101
00:06:56,181 --> 00:06:58,990
다음과 같이 패딩 크기를 결정해서

102
00:06:58,990 --> 00:07:01,960
아웃풋 사이즈가 인풋사이즈와 같다는 것을

103
00:07:01,960 --> 00:07:06,265
확인할 수 있습니다, 그렇게 때문에 예를 들어

104
00:07:06,265 --> 00:07:10,795
이전 슬라이드에서 봤던 것처럼 필터가 3x3이면

105
00:07:10,795 --> 00:07:15,990
아웃풋 크기와 인풋 크기를 같게 하는 패딩은

106
00:07:15,990 --> 00:07:21,790
2분의 3-1, 즉 1 입니다.

107
00:07:21,790 --> 00:07:23,415
또 다른 예를 들어보면,

108
00:07:23,415 --> 00:07:28,250
필터가 5x5 이고

109
00:07:28,250 --> 00:07:30,395
즉, f=5이라면

110
00:07:30,395 --> 00:07:35,590
이걸 방정식에 대입하면, 2만큼의 패딩이 아웃풋 크기를

111
00:07:35,590 --> 00:07:43,154
인풋 크기와 똑같게 만들어줍니다. 필터가 5x5일때 말이죠.

112
00:07:43,154 --> 00:07:46,440
그리고 컴퓨터 비전 분야의 관습에 따르면

113
00:07:46,440 --> 00:07:50,435
f는 주로 홀수이며,

114
00:07:50,435 --> 00:07:59,070
사실 대부분 항상 홀수입니다, 짝수로 된 필터는 보기도 어렵습니다.

115
00:07:59,070 --> 00:08:02,631
필터는 컴퓨터 비전을 사용해서 작동합니다.

116
00:08:02,631 --> 00:08:05,280
그리고 제 생각에 그 이유는 두 가지 입니다.

117
00:08:05,280 --> 00:08:07,320
첫째로, f가 짝수이면

118
00:08:07,320 --> 00:08:10,155
몇 가지 비대칭적인 패딩을 해야 합니다.

119
00:08:10,155 --> 00:08:15,380
따라서 f가 홀수여서 이 Same Convolution 유형이

120
00:08:15,380 --> 00:08:17,180
자연적인 패딩 영역을 주기만 한다면

121
00:08:17,180 --> 00:08:20,290
패딩이 왼쪽엔 더 많고 오른쪽엔 더 적다거나

122
00:08:20,290 --> 00:08:22,104
혹은 불규칙적이지 않고 사방에 같은 dimension이 있을 것이다.

123
00:08:22,104 --> 00:08:27,440
두 번째 이유는, 홀수 차원의 필터를 사용한다면

124
00:08:27,440 --> 00:08:29,770
예를 들어 3x3 이나 5x5와 같이

125
00:08:29,770 --> 00:08:32,860
중앙 포지션을 가지고 있고 때로는

126
00:08:32,860 --> 00:08:36,095
컴퓨터 비전분야에 있어서 특징점을 가지고 있다는 것은 좋은 점입니다.

127
00:08:36,095 --> 00:08:37,450
픽셀을 가지고 있으면 좋습니다,

128
00:08:37,450 --> 00:08:43,527
중앙의 픽셀을 칭할 수 있고 필터의 포지션에 대해 이야기할 수 있습니다.

129
00:08:43,527 --> 00:08:48,080
맞습니다, 어느 것도 f 가 거의 항상 홀수로 사용되는 데 있어 좋은 이유가 될 수는 없습니다.

130
00:08:48,080 --> 00:08:50,310
하지만 컨벌루션 문헌에 보면,

131
00:08:50,310 --> 00:08:53,482
3x3 필터가 매우 흔하다는 걸 보게 됩니다.

132
00:08:53,482 --> 00:08:56,155
또는 5x5, 7x7을 보게 되기도 하고,

133
00:08:56,155 --> 00:08:58,985
실제로 때로는,

134
00:08:58,985 --> 00:09:02,095
1x1 필터에 대해 알아보고 그게 어떻게 가능한지도 살펴보겠습니다.

135
00:09:02,095 --> 00:09:04,130
하지만 관행적으로,

136
00:09:04,130 --> 00:09:08,335
홀수 필터를 사용하기를 권장합니다.

137
00:09:08,335 --> 00:09:10,385
제 생각엔 아마 가능할 것 같습니다.

138
00:09:10,385 --> 00:09:14,180
f에 짝수 값을 사용한다 하더라도 좋은 성능을 낼 수 있을 것 같습니다.

139
00:09:14,180 --> 00:09:18,538
하지만 여러분이 아직 컴퓨터 비전 관행에 매여있다면,

140
00:09:18,538 --> 00:09:25,865
저는 대개 홀수 f를 사용합니다, <br />자, 여러분은 Padded Convolution을 사용하는 방법을 살펴보았습니다.

141
00:09:25,865 --> 00:09:28,890
컨벌루션 연산을 위해 패딩을 더 알고 싶다면

142
00:09:28,890 --> 00:09:31,200
p 값을 구체화하거나

143
00:09:31,200 --> 00:09:34,835
Valid Convolution이라고 하면 되는데요,

144
00:09:34,835 --> 00:09:38,595
이는 p=0 임을 의미하는 것이죠. <br />아니면 Same Convolution,

145
00:09:38,595 --> 00:09:40,850
즉, 아웃풋이 인풋과 같은 차원을 가지는

146
00:09:40,850 --> 00:09:43,780
패딩도 있습니다.

147
00:09:43,780 --> 00:09:45,181
여기까지 패딩에 대해 보았습니다.

148
00:09:45,181 --> 00:09:49,220
다음 강좌에서는, Strided Convolution를 실행하는 법에 대해 알아보겠습니다.