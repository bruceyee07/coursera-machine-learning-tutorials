1
00:00:01,410 --> 00:00:05,830
为了构建深层神经网络

2
00:00:05,830 --> 00:00:10,675
一个你非常需要使用的<br />对基本的卷积操作的改进是填充(padding)

3
00:00:10,675 --> 00:00:12,232
我们来看看它是如何工作的

4
00:00:12,232 --> 00:00:15,190
在前面我们讲过

5
00:00:15,190 --> 00:00:19,385
如果你用一个3x3的过滤器(filter)卷积一个6x6的图片

6
00:00:19,385 --> 00:00:23,585
你最终会得到的输出是一个4x4的矩阵

7
00:00:23,585 --> 00:00:28,080
这是因为3x3过滤器的可能放的位置的数目是4x4

8
00:00:28,080 --> 00:00:29,470
事实上

9
00:00:29,470 --> 00:00:31,780
为了适应你的6x6矩阵大小

10
00:00:31,780 --> 00:00:37,035
3x3过滤器只有4x4可能的位置

11
00:00:37,035 --> 00:00:41,346
这其中的通用公式是

12
00:00:41,346 --> 00:00:45,725
如果你有一个 n x n 的图片并且想使用一个 f x f 的过滤器

13
00:00:45,725 --> 00:00:48,850
这样输出的维度将会是

14
00:00:48,850 --> 00:00:58,237
(n-f+1) x (n-f+1)

15
00:00:58,237 --> 00:00:59,665
在这个例子中

16
00:00:59,665 --> 00:01:03,455
6-3+1 = 4

17
00:01:03,455 --> 00:01:07,489
这就是为什么你最后得到一个4x4的输出

18
00:01:07,489 --> 00:01:10,400
这其实有两个缺陷：第一个是

19
00:01:10,400 --> 00:01:14,790
如果每一次你使用一个卷积操作，<br />你的图像都会缩小

20
00:01:14,790 --> 00:01:17,595
例如你从 6x6 降维到 4x4

21
00:01:17,595 --> 00:01:21,716
你做不了几次卷积，你的图片就会变得非常小

22
00:01:21,716 --> 00:01:23,870
也许它会缩小到只有1x1或者别的什么

23
00:01:23,870 --> 00:01:26,720
所以也许你并不希望

24
00:01:26,720 --> 00:01:29,902
每次你想检测边界或者其他的特征时，都缩小你的图片

25
00:01:29,902 --> 00:01:31,605
这就是一个缺陷

26
00:01:31,605 --> 00:01:33,590
第二个缺陷是

27
00:01:33,590 --> 00:01:36,665
图片角落或者边际上的像素

28
00:01:36,665 --> 00:01:40,755
只会在输出中被使用一次

29
00:01:40,755 --> 00:01:43,490
因为它只通过那个3x3的过滤器（filter）一次

30
00:01:43,490 --> 00:01:48,905
然而图片中间的一个像素，比如这一个

31
00:01:48,905 --> 00:01:55,380
会有许多3x3的过滤器（filter）在那个像素上重叠

32
00:01:55,380 --> 00:02:01,455
所以相对而言 角落或者边界上的像素被使用的次数少很多

33
00:02:01,455 --> 00:02:06,390
你丢失了许多图片上靠近边界的信息

34
00:02:06,390 --> 00:02:08,735
所以为了同时解决上述的两个问题

35
00:02:08,735 --> 00:02:12,829
一是输出的逐渐缩小

36
00:02:12,829 --> 00:02:15,485
这在当你构建非常深的神经网络时

37
00:02:15,485 --> 00:02:19,685
你会发现为什么你不希望每一步都缩小图片

38
00:02:19,685 --> 00:02:22,038
因为比如你有一个一百层的深度网络

39
00:02:22,038 --> 00:02:23,710
如果它每一层都会缩小(图片)一点

40
00:02:23,710 --> 00:02:27,993
这样一百层之后你会得到一个非常小的图片

41
00:02:27,993 --> 00:02:29,085
这是一个问题

42
00:02:29,085 --> 00:02:38,120
另一个(问题)是丢失了许多图片边界上的信息

43
00:02:38,120 --> 00:02:40,740
所以为了消除这两个问题

44
00:02:40,740 --> 00:02:44,774
你能做的是在使用卷机操作前

45
00:02:44,774 --> 00:02:46,959
你可以填充（pad）图片

46
00:02:46,959 --> 00:02:56,185
在这种情况下<br />让我们假设你用一个额外的边缘(border)填充图片

47
00:02:56,185 --> 00:03:00,670
在边界周围用一个1个像素的大小的额外边缘

48
00:03:00,670 --> 00:03:02,635
如果你这么做

49
00:03:02,635 --> 00:03:05,517
你现在的输入已经变成一个通过填充得到的 8x8 图片

50
00:03:05,517 --> 00:03:09,500
而不是 6x6 图片

51
00:03:09,500 --> 00:03:14,007
如果你使用一个3x3过滤器卷积一个8x8图片

52
00:03:14,007 --> 00:03:16,960
现在结果是一个6x6的图片而不是 4x4

53
00:03:16,960 --> 00:03:23,667
所以你通过填充保持了图片的原始大小 6x6

54
00:03:23,667 --> 00:03:25,350
通常当你填充时

55
00:03:25,350 --> 00:03:33,296
你使用0来填充 如果p是填充的数量

56
00:03:33,296 --> 00:03:34,575
所以 在这种情况下所以 在这种情况下

57
00:03:34,575 --> 00:03:36,615
p=1

58
00:03:36,615 --> 00:03:41,180
因为我们使用了一个1像素的额外边缘填充了一圈

59
00:03:41,180 --> 00:03:47,940
这样输出变成了

60
00:03:47,940 --> 00:03:54,360
(n+2p-f+1) x (n+2p-f+1)

61
00:03:54,360 --> 00:04:02,480
所以这个变成了 (6+2*1-3+1) x (6+2*1-3+1)

62
00:04:02,480 --> 00:04:06,475
这是(6+2-3+1) = 6

63
00:04:06,475 --> 00:04:12,880
这样你得到了一个 6x6 的输出 <br />保持了初始图片的大小

64
00:04:12,880 --> 00:04:16,030
因此这个绿色的像素事实上影响了

65
00:04:16,030 --> 00:04:23,330
所有这些过滤器的输出

66
00:04:23,330 --> 00:04:26,700
这样的效果是大大降低了

67
00:04:26,700 --> 00:04:32,715
之前的那种边界和角落信息被忽略的严重程度

68
00:04:32,715 --> 00:04:34,255
并且我在这里展示了

69
00:04:34,255 --> 00:04:38,240
使用单个像素填充边缘的效果

70
00:04:38,240 --> 00:04:42,535
如果你需要，你也可以用两个像素填充边缘 

71
00:04:42,535 --> 00:04:44,820
这样子你再添加一个额外的边缘

72
00:04:44,820 --> 00:04:50,125
如果你愿意 这里你甚至可以使用更多的像素来填充

73
00:04:50,125 --> 00:04:52,812
我在这里画的是

74
00:04:52,812 --> 00:04:55,438
这里是一个p等于2的填充

75
00:04:55,438 --> 00:05:00,665
到底需要填充多少

76
00:05:00,665 --> 00:05:04,129
我们有两个常见的选择

77
00:05:04,129 --> 00:05:07,380
即valid卷积和same卷积

78
00:05:07,380 --> 00:05:10,960
不是什么很棒的名字<br />不过valid卷积

79
00:05:10,960 --> 00:05:15,170
基本上意思是没有填充

80
00:05:15,170 --> 00:05:22,600
因此在这种情况下

81
00:05:22,600 --> 00:05:25,345
当你用一个 fxf 过滤器去卷积一个 nxn 的图片

82
00:05:25,345 --> 00:05:30,298
你会得到一个 (n-f+1) x (n-f+1) 维度的输出

83
00:05:30,298 --> 00:05:35,060
这就像是我们在之前的视频中使用的例子

84
00:05:35,060 --> 00:05:37,250
我们用一个3x3的过滤器卷积一个6x6的图片

85
00:05:37,250 --> 00:05:43,095
得到一个4x4的输出

86
00:05:43,095 --> 00:05:48,545
另一个最常用的填充选择

87
00:05:48,545 --> 00:05:52,660
叫做same卷积<br />意思是你选择的填充将使得

88
00:05:52,660 --> 00:05:58,580
输出大小等于输入大小

89
00:05:58,580 --> 00:06:01,795
所以当我们看一下这个公式

90
00:06:01,795 --> 00:06:04,635
当你用p个像素填充

91
00:06:04,635 --> 00:06:11,676
这就像是n变成了n+2p 然后其余的不变 对吧?

92
00:06:11,676 --> 00:06:15,740
减去f加上1

93
00:06:15,740 --> 00:06:22,125
所以当我们有一个nxn的图片 并且边缘四周的填充是p个像素

94
00:06:22,125 --> 00:06:28,900
这样输出的大小是n+2p-f+1

95
00:06:28,900 --> 00:06:36,080
如果你希望n+2p-f+1=n

96
00:06:36,080 --> 00:06:38,795
即输出和输入大小一致

97
00:06:38,795 --> 00:06:42,905
如果你用这个式子然后解方程 我想

98
00:06:42,905 --> 00:06:46,664
两边n抵消了 然后如果你解p

99
00:06:46,664 --> 00:06:53,463
这个意味着p=(f-1)/2

100
00:06:53,463 --> 00:06:56,181
所以当f是奇数时

101
00:06:56,181 --> 00:06:58,990
这样通过选择填充的大小

102
00:06:58,990 --> 00:07:01,960
你可以保证输出和输入的大小相同

103
00:07:01,960 --> 00:07:06,265
这就是为什么 比如说

104
00:07:06,265 --> 00:07:10,795
当过滤器是3x3时 就像在之前的幻灯片中

105
00:07:10,795 --> 00:07:15,990
可以使输出输入大小相同的填充是

106
00:07:15,990 --> 00:07:21,790
(3-1)/2=1

107
00:07:21,790 --> 00:07:23,415
另一个例子是

108
00:07:23,415 --> 00:07:28,250
如果你的过滤器是5x5

109
00:07:28,250 --> 00:07:30,395
就是说f=5

110
00:07:30,395 --> 00:07:35,590
如果带入这个式子 你会发现需要使用2个像素大小的填充

111
00:07:35,590 --> 00:07:43,154
才能使得在过滤器是5x5的情况下 输出输入相同

112
00:07:43,154 --> 00:07:46,440
通常在计算机视觉(computer vision)领域

113
00:07:46,440 --> 00:07:50,435
f基本上是使用奇数

114
00:07:50,435 --> 00:07:59,070
事实上几乎永远是奇数<br />并且你很少看到偶数大小的

115
00:07:59,070 --> 00:08:02,631
计算机视觉使用的过滤器

116
00:08:02,631 --> 00:08:05,280
并且我想有两个原因导致这个现象

117
00:08:05,280 --> 00:08:07,320
一是如果f是偶数

118
00:08:07,320 --> 00:08:10,155
你会需要一些不对称的填充

119
00:08:10,155 --> 00:08:15,380
所以只有当f是奇数时 这种same卷积会产生

120
00:08:15,380 --> 00:08:17,180
在四周有相同的维度的一个自然的填充区域

121
00:08:17,180 --> 00:08:20,290
而不是在左边多填充在右边少填充

122
00:08:20,290 --> 00:08:22,104
或者别的不对称的填充

123
00:08:22,104 --> 00:08:27,440
其次当你有一个奇数大小的过滤器

124
00:08:27,440 --> 00:08:29,770
比如3x3或者5x5

125
00:08:29,770 --> 00:08:32,860
这样这可以有一个中心位置

126
00:08:32,860 --> 00:08:36,095
有时候在计算机视觉领域 有一个特殊点是很好的

127
00:08:36,095 --> 00:08:37,450
有一个这样的像素是很好的

128
00:08:37,450 --> 00:08:43,527
你可以称之为中心像素 这样你就可以描述你过滤器的位置

129
00:08:43,527 --> 00:08:48,080
也许这些都不是<br />为什么f基本上永远使用奇数的很好的理由

130
00:08:48,080 --> 00:08:50,310
但是如果你去读一些卷积相关的文献

131
00:08:50,310 --> 00:08:53,482
你会发现3x3的过滤器非常常见

132
00:08:53,482 --> 00:08:56,155
你会看见一些5x5,7x7

133
00:08:56,155 --> 00:08:58,985
事实上有时候 

134
00:08:58,985 --> 00:09:02,095
之后我们会讲到1x1过滤器和它的原理

135
00:09:02,095 --> 00:09:04,130
但是只是约定俗成

136
00:09:04,130 --> 00:09:08,335
我建议你也使用奇数大小的过滤器

137
00:09:08,335 --> 00:09:10,385
我想就算你使用一个偶数f

138
00:09:10,385 --> 00:09:14,180
你也许能得到不错的结果

139
00:09:14,180 --> 00:09:18,538
但是如果你坚持计算机视觉的传统

140
00:09:18,538 --> 00:09:25,865
我一般只用奇数f 所以现在你知道了如何使用填充卷积

141
00:09:25,865 --> 00:09:28,890
为了指定你卷积操作的填充

142
00:09:28,890 --> 00:09:31,200
你可以指定p的大小

143
00:09:31,200 --> 00:09:34,835
或者你可以只说这是一个valid卷积

144
00:09:34,835 --> 00:09:38,595
意味着p=0 或者你可以说这是一个same卷积

145
00:09:38,595 --> 00:09:40,850
意味着使用足够的填充

146
00:09:40,850 --> 00:09:43,780
使得输出输入的大小相等

147
00:09:43,780 --> 00:09:45,181
所以这就是填充

148
00:09:45,181 --> 00:09:49,220
在下一个视频，让我们来讲讲如何实现步幅(stride)卷积