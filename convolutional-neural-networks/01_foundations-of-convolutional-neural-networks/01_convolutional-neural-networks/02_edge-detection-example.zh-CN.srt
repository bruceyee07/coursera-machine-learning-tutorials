1
00:00:01,580 --> 00:00:05,000
卷积运算是卷积神经网络的

2
00:00:05,000 --> 00:00:06,870
基础组成单元之一

3
00:00:06,870 --> 00:00:10,050
在这个视频中 我们用边缘检测<br />作为引发兴趣的例子

4
00:00:10,050 --> 00:00:14,030
你将了解卷积运算是如何进行的

5
00:00:17,743 --> 00:00:18,943
在之前的一节中

6
00:00:18,943 --> 00:00:23,810
我已经讨论过神经网络的前几层<br />是怎样检测边缘的

7
00:00:23,810 --> 00:00:27,250
并且后几层可能会<br />检测对象的某些部分

8
00:00:27,250 --> 00:00:31,320
而更后的几层会检测<br />到某些整个的对象

9
00:00:31,320 --> 00:00:33,380
比如在此例中的人脸

10
00:00:35,270 --> 00:00:40,740
在本视频中你将看到<br />如何在一个图像中进行边缘检测

11
00:00:40,740 --> 00:00:42,360
举个例子来看我们举个例子说明

12
00:00:42,360 --> 00:00:46,760
给出一张这样的图片 让电脑算出<br />在这张图片中的物体是什么

13
00:00:46,760 --> 00:00:53,205
你做的第一件事可能是<br />检测图片中的垂直边缘

14
00:00:54,650 --> 00:00:59,470
例如在这个图像中<br />垂直的线是栅栏所在的地方

15
00:00:59,470 --> 00:01:04,040
还有比较垂直的线<br />是这些行人的轮廓

16
00:01:04,040 --> 00:01:08,420
所以在这个垂直边缘检测结果中<br />它们被检测出来了

17
00:01:09,860 --> 00:01:12,340
你也许也想要检测水平边缘

18
00:01:12,340 --> 00:01:17,180
比如说有一个非常明显的<br />水平线段在栅栏在的地方

19
00:01:17,180 --> 00:01:20,410
它也被检测到 大概在这里

20
00:01:21,520 --> 00:01:25,034
所以你怎样才能<br />在像这样的图像中检测边缘呢

21
00:01:25,034 --> 00:01:26,160
我们来看个例子

22
00:01:27,670 --> 00:01:31,056
这里是一个6x6的灰度图像

23
00:01:31,056 --> 00:01:35,949
因为这是一个灰度图像<br />所以只是一个6x6x1的矩阵

24
00:01:35,949 --> 00:01:40,700
而不是6x6x3<br />因为没有分开的RGB通道

25
00:01:41,790 --> 00:01:46,213
为了检测边缘<br />比如这个图像中的垂直边缘

26
00:01:46,213 --> 00:01:49,093
你能做的是建立一个3x3的矩阵

27
00:01:49,093 --> 00:01:53,733
在池化(pooling)过程中<br />用卷积神经网络中的专业术语来说

28
00:01:53,733 --> 00:01:55,950
这会被称为一个过滤器(filter)

29
00:01:57,390 --> 00:02:01,543
我将要建立一个3x3的过滤器

30
00:02:01,543 --> 00:02:08,679
或者说是3x3的矩阵<br />像这样 111 000 -1 -1 -1的

31
00:02:08,679 --> 00:02:12,947
有时候科研论文中会将它<br />称为核(kernel)而不是过滤器

32
00:02:12,947 --> 00:02:16,370
但是在这个视频中我将会用过滤器这个术语

33
00:02:17,890 --> 00:02:22,730
你需要做的是获得6x6的图像<br />并求其卷积

34
00:02:22,730 --> 00:02:27,107
卷积运算用这个星号代替

35
00:02:29,560 --> 00:02:32,690
用这个3x3的过滤器去求它的卷积

36
00:02:32,690 --> 00:02:37,410
稍微有点遗憾的是<br />这个符号在数学中

37
00:02:37,410 --> 00:02:41,490
星号是卷积的标准符号

38
00:02:41,490 --> 00:02:45,648
但是在Python中这被用来表示乘法

39
00:02:45,648 --> 00:02:48,440
也许元素积乘法

40
00:02:48,440 --> 00:02:53,009
所以这个星号有双重用法<br />这是个重复的符号

41
00:02:53,009 --> 00:02:58,598
但是当星号表示卷积的时候<br />我会在这个视频中明确表示

42
00:02:58,598 --> 00:03:03,844
这个卷积运算的输出是<br />一个4x4的矩阵

43
00:03:03,844 --> 00:03:09,020
你可以将它理解为一个4x4的图像

44
00:03:09,020 --> 00:03:13,330
下面是计算这个4x4输出的方法

45
00:03:13,330 --> 00:03:18,522
计算第一个元素 也是就这个<br />4乘以4矩阵中左上角的这个元素

46
00:03:18,522 --> 00:03:21,848
你要做的是用这个3X3的过滤器

47
00:03:21,848 --> 00:03:26,254
把它粘贴到你的原始图像的<br />这块3x3区域上面

48
00:03:26,254 --> 00:03:30,920
我在这里写了111

49
00:03:30,920 --> 00:03:34,872
0 0 0 -1 -1 -1

50
00:03:34,872 --> 00:03:38,221
你需要做的是计算元素积

51
00:03:38,221 --> 00:03:41,481
所以第一个是3乘以1

52
00:03:41,481 --> 00:03:46,377
然后第二个是1乘1<br />把它放到这里 1乘1

53
00:03:46,377 --> 00:03:50,398
然后加上这个 2乘1

54
00:03:50,398 --> 00:03:53,340
然后把九个结果全部加起来

55
00:03:53,340 --> 00:04:00,451
所以中间的列得到<br />0乘0加5乘0加7乘0

56
00:04:00,451 --> 00:04:06,357
然后最右边的列得到1乘-1

57
00:04:06,357 --> 00:04:09,088
8乘-1加上2乘-1

58
00:04:09,088 --> 00:04:15,875
把这九个数字相加你将得到-5

59
00:04:15,875 --> 00:04:19,340
然后我把-5填在这里

60
00:04:19,340 --> 00:04:22,450
对 你当然可以用<br />任何顺序把这九个数字相加

61
00:04:22,450 --> 00:04:27,550
比如说我先计算第一列

62
00:04:27,550 --> 00:04:29,620
然后第二列 然后第三列

63
00:04:29,620 --> 00:04:33,467
接下来 为了计算出第二个元素

64
00:04:33,467 --> 00:04:39,526
你要将蓝色的方形向右平移一步<br />像这样

65
00:04:39,526 --> 00:04:42,100
让我把这里的绿色标记都去掉

66
00:04:42,100 --> 00:04:46,330
你将要求同样的元素积然后相加

67
00:04:46,330 --> 00:04:52,501
所以你有0乘1加上5乘1加7乘1

68
00:04:52,501 --> 00:04:57,400
加1乘0加8乘0加2乘0

69
00:04:57,400 --> 00:05:03,450
加2乘-1加9乘-1加5乘-1

70
00:05:03,450 --> 00:05:10,791
如果你把这九个数加起来<br />你得到-4 以此类推

71
00:05:10,791 --> 00:05:16,078
如果你把这个向右平移得到九个乘积<br />然后把它们相加得到0

72
00:05:16,078 --> 00:05:19,424
然后在这里你应该得到8

73
00:05:19,424 --> 00:05:26,017
只是验证一下 你有2加9加5 得到16

74
00:05:26,017 --> 00:05:29,165
然后中间的列得到0

75
00:05:29,165 --> 00:05:35,110
最右边的列 4加1加3乘-1 得到-8

76
00:05:35,110 --> 00:05:39,621
然后就是在左边的列是16 -8

77
00:05:39,621 --> 00:05:43,796
然后得8 和我们算好的一样

78
00:05:43,796 --> 00:05:47,738
接下来 为了得到下一行的元素

79
00:05:47,738 --> 00:05:52,280
你需要做的是把这个<br />蓝色的方形往下移一步

80
00:05:52,280 --> 00:05:54,450
然后它现在在这个位置

81
00:05:54,450 --> 00:05:59,920
然后再次重复元素积然后相加

82
00:05:59,920 --> 00:06:02,967
如果你这么做了 你在这里得到-10

83
00:06:05,016 --> 00:06:11,147
然后你把它向右移一步 应该得到-2

84
00:06:11,147 --> 00:06:14,590
然后是2 然后是3等等

85
00:06:14,590 --> 00:06:20,050
然后算出矩阵中的所有元素

86
00:06:21,400 --> 00:06:26,281
再解释清楚一点 这个-16是

87
00:06:26,281 --> 00:06:29,980
从右下端的3x3区域得到的

88
00:06:31,080 --> 00:06:36,600
所以用3x3矩阵卷积6x6的矩阵<br />将得到一个4x4的矩阵

89
00:06:38,182 --> 00:06:39,760
这些是图像和过滤器

90
00:06:39,760 --> 00:06:43,390
这些都只是多维的矩阵

91
00:06:44,640 --> 00:06:49,779
不过左边的矩阵可以<br />容易地理解为一个图像

92
00:06:49,779 --> 00:06:52,564
中间这个我们把它理解为<br />一个过滤器

93
00:06:52,564 --> 00:06:57,021
然后右边的这一个<br />也许可以理解为另一个图像

94
00:06:57,021 --> 00:07:00,830
这就是一个垂直边缘检测器

95
00:07:00,830 --> 00:07:03,440
你会在下一页知道为什么是这样的

96
00:07:03,440 --> 00:07:06,097
在我们继续之前我有另一个提醒

97
00:07:06,097 --> 00:07:10,476
那就是如果你将这运用到编程语言中<br />在实践中

98
00:07:10,476 --> 00:07:13,840
大部分的编程语言<br />都会有一些不同的方法

99
00:07:13,840 --> 00:07:16,800
而不用一个星号去标记卷积

100
00:07:16,800 --> 00:07:20,010
比如说在编程练习中

101
00:07:20,010 --> 00:07:24,040
你会实现一个conv_forward函数

102
00:07:24,040 --> 00:07:28,481
如果你用TensorFlow做

103
00:07:28,481 --> 00:07:34,528
有一个函数tf.nn.conv2d

104
00:07:34,528 --> 00:07:37,000
而在其他的深度学习编程框架中

105
00:07:37,000 --> 00:07:41,538
比如Keras 后面会学到

106
00:07:41,538 --> 00:07:46,090
有一个函数Conv2D来实现卷积运算

107
00:07:46,090 --> 00:07:49,559
但是所有支持卷积的深度学习框架

108
00:07:49,559 --> 00:07:54,218
都会有一些函数实现这个卷积运算

109
00:07:56,813 --> 00:07:59,756
为什么这是在进行垂直边缘检测呢

110
00:07:59,756 --> 00:08:01,700
让我们看看另一个例子。

111
00:08:03,470 --> 00:08:06,188
为了更好的解释<br />我们用一个简化了的图像

112
00:08:06,188 --> 00:08:08,819
这有一个简单的6x6的图像

113
00:08:08,819 --> 00:08:14,480
这个图像的左半边是10 右半边是0

114
00:08:14,480 --> 00:08:18,734
如果你以图片形式得到它<br />它将是这个样子的

115
00:08:18,734 --> 00:08:21,775
左半边的10<br />得到更亮的像素强度值

116
00:08:21,775 --> 00:08:25,060
右半边得到比较暗的像素强度值

117
00:08:25,060 --> 00:08:27,890
我们用灰色来表示0

118
00:08:27,890 --> 00:08:32,110
虽然可能也能画成黑色

119
00:08:32,110 --> 00:08:37,654
但是在这个图像的正中间<br />很清晰地有一个明显的垂直边缘

120
00:08:37,654 --> 00:08:42,590
是从白到黑或者说<br />从白到暗色的过度

121
00:08:44,070 --> 00:08:48,808
所以当你用这个3x3的过滤器<br />做卷积运算

122
00:08:48,808 --> 00:08:53,048
这个3x3的过滤器<br />可以被可视化成这样

123
00:08:53,048 --> 00:08:57,575
更明亮的像素点在左边

124
00:08:57,575 --> 00:09:02,080
然后有中间调的颜色在中间<br />然后更暗的在右边

125
00:09:02,080 --> 00:09:05,290
你得到的是在右边的这个矩阵

126
00:09:06,640 --> 00:09:10,130
如果你想 可以验证这个数学运算

127
00:09:10,130 --> 00:09:15,815
比如说这个0 是取元素积

128
00:09:15,815 --> 00:09:18,880
然后与这个3x3的块相乘得到的

129
00:09:18,880 --> 00:09:23,008
然后从最左列你得到10加10加10

130
00:09:23,008 --> 00:09:26,987
然后中间是0 然后-10 -10 -10

131
00:09:26,987 --> 00:09:30,670
这就是为什么你最后在这里得到0

132
00:09:30,670 --> 00:09:35,490
与之不同 30是从这里得到的

133
00:09:36,860 --> 00:09:41,062
从10加10加10得到的

134
00:09:41,062 --> 00:09:47,190
然后-0 -0 这是为什么<br />你最后在那里得到30

135
00:09:47,190 --> 00:09:51,490
如果你把最右边的矩阵画成图像<br />它将会是这样

136
00:09:51,490 --> 00:09:55,240
更亮的区域在正中间

137
00:09:55,240 --> 00:09:59,820
这与检测出的垂直边缘相对应

138
00:09:59,820 --> 00:10:03,630
在这个6x6的图像的中间

139
00:10:03,630 --> 00:10:06,920
这里的维数看起来不太对

140
00:10:06,920 --> 00:10:09,450
检测出来的边缘看起来很厚

141
00:10:09,450 --> 00:10:13,840
那只是因为我们在这个例子中<br />用了一个很小的图像

142
00:10:13,840 --> 00:10:17,100
如果你用一个1000x1000的图像

143
00:10:17,100 --> 00:10:22,190
而不是一个6x6的图像 你会发现

144
00:10:22,190 --> 00:10:27,390
它能很好得检测出<br />在你图像中的垂直边缘

145
00:10:27,390 --> 00:10:28,510
在这个例子中

146
00:10:28,510 --> 00:10:34,225
这个在中间的明亮区域<br />只是用输出图像的方式

147
00:10:34,225 --> 00:10:39,355
来表示有一个强垂直边缘<br />正好在图像的中间

148
00:10:39,355 --> 00:10:44,280
垂直边缘检测里也许能<br />得到一个直观的理解

149
00:10:44,280 --> 00:10:49,315
一个垂直边缘是一个3x3的区域<br />因为我们用的是3x3的过滤器

150
00:10:49,315 --> 00:10:52,706
左边有亮像素

151
00:10:52,706 --> 00:10:55,104
你并不在意中间有什么

152
00:10:55,104 --> 00:10:58,171
然后在右边是暗像素

153
00:10:58,171 --> 00:11:03,011
在这个6x6的图像的中间

154
00:11:03,011 --> 00:11:07,850
可能会有亮像素在左边<br />暗像素在右边

155
00:11:07,850 --> 00:11:12,120
这就是为什么它认为<br />那里有一个垂直边缘

156
00:11:12,120 --> 00:11:16,480
卷积运算提供了一个<br />方便的方法去弄清楚

157
00:11:16,480 --> 00:11:20,200
如何在图像中找到这些垂直边缘

158
00:11:20,200 --> 00:11:23,720
所以现在你知道卷积运算<br />是怎么发挥作用的

159
00:11:23,720 --> 00:11:26,430
在下一个视频中 你会看到如何运用它

160
00:11:26,430 --> 00:11:30,032
作为卷积神经网络中的<br />一个基本构成