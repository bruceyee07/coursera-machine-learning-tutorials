Convolution operation (컨볼루션 연산)은 Convolution neural network (컨볼루션 신경망)의 기본적인 구성 블록들 중 하나입니다. 이번 강의에서는 동기 부여가 될만한 예시로서 edge detection을 사용해서 어떻게 컨볼루션 연산이 작동하는지 보도록 하죠. 이전 강의들에서, 신경망의 초기 레이어가 어떻게 모서리를 감지하는지 말씀 드렸습니다. 그리고 후기 레이어가 어떻게 대상의 일부를 감지할 수 있는지를, 심지어 후기 레이어들이 이 예시에 있는 사람들 얼굴처럼 완전한 물체의 부분들을 어떻게 감지할 수 있는지도 말씀 드렸습니다. 이번 영상에서는, 이미지 안의 모서리를 어떻게 감지하는지 알아봅시다. 예를 들어보겠습니다. 이런 그림이 주어지면, 컴퓨터는 이 사진에서 어떤 대상들이 있는지 알아내야 합니다. 여러분이 해야 하는 첫 번째 일은 바로 
이 이미지 안에 있는 수직 테두리들을 탐지하는 것입니다. 예를 들어, 이 이미지는 난간이 있는 곳에 저런 수직선들을 가지고 있습니다 또한, 행인들과 같은 부류의 수직선도 있습니다. 그런 선들이 이 vertical edge detecThistor (수직선 감지기)에서 탐지되는 것입니다. 그리고 수평선을 감지해야 할 때는, 예를 들자면 이 난간에 아주 강한 수평선이 있는데요 또한 대략 이쪽 부분에서도 감지가 됩니다. 그럼, 어떻게 이런 이미지에서 테두리들을 감지해낼 수 있을까요? 예시를 봐볼까요. 이런 6x6 grayscale 이미지가 있습니다. 이건 grayscale 이미지이므로, 6x6x1 매트릭스라고 할 수 있습니다. 분리된 RGB채널상에 있기 때문에 6x6x3은 아니죠. 이미지 안에 있는 이런 테두리들, 즉 수직선들을 감지하기 위해서는, 우선, 3x3 매트릭스를 만드십시오. 그리고 컨볼루션 신경망 용어로는 이런 걸 필터라고 부릅니다. 그럼 이번엔 3x3필터 혹은 3x3 매트릭스를 만들어보겠습니다. 1, 1, 1, 0, 0, 0, -1, -1, -1 이렇게요. 때로는 연구 보고서에선 이것을 필터가 아니라 kernel이라고 부르기도 합니다. 하지만 이 강의에서는 필터라고 부르도록 하겠습니다. 6x6 이미지를 가지고, 컨볼브 하면 콘볼루션 연산은 이런 별표로 표현됩니다. 그러면 3x3필터로 컨볼브 하십시오. 이 표식에서 한 가지 좀 안타까운 점은 수학에서는 별표가 컨볼루션을 위한 표준 기호이지만, 파이톤에서는 곱셈 혹은 요소 간의 곱셈을 표시하기 위해 쓰여지고 있다는 거죠. 파이톤에서는 곱셈 혹은 요소 간의 곱셈을 표시하기 위해 쓰여지고 있다는 거죠. 이 별표는 두 개의 목적을 가지고 있어, 혼란을 줄 수 있는 기호이지만, 이 강의에서 별표가 컨볼루션을 나타낼 때에, 명확하게 말씀 드리도록 하겠습니다. 이 convolution operator의 결과는 4x4 매트릭스입니다. 4x4 이미지로 생각해도 되겠습니다. 이 4x4결과를 계산할 수 있는 방법은 다음과 같습니다. 4x4 매트릭스의 맨 위 왼쪽에 있는 첫 번째 element(요소)들을 계산하기 위해서는 3x3 필터를 가져다가 원본 인풋이미지의 3x3 영역 위에 붙여 넣기 하는 겁니다. 1, 1, 1 이라고 썼고, 0, 0, 0, -1, -1, -1이라고 썼습니다. 그리고 나서는 Element-wise Product(요소 간의 곱셈) 작업을 하는 겁니다. 첫 번째 것은 3x1 이 되고, 두 번째 것은 1x1 되겠죠. 아래로 내려가서 1x1 그리고 2x1을 더해줍니다. 그냥 1이죠, 그리고 나서 9개의 결과값을 모두 더해주세요. 그러면 가운데 세로 열이 0x0 + 5x0 + 7x0 , 그리고 맨 오른쪽 칸은 0x-1이 됩니다. (8x-1) + (2x-1) 이 9개의 숫자들을 더하면 음의 값 5가 되고 그러니 -5를 바로 여기에 채워주겠습니다. 이 9개의 숫자들은 어느 순서로 더해도 무방합니다. 그냥 첫 번째 열 아래쪽으로 진행하고 그리고 두 번째 행, 그리고 세 번째 이렇게 하면 되는 겁니다. 다음으로는, 두 번째 element를 알아내려면 이 파란 네모 칸을 이렇게 한 칸 오른쪽으로 옮기면 됩니다. 초록색 표시는 없애도록 하죠. 똑같은 element wise product(요소 간의 곱셈)을 하고 나서 더하시면 됩니다. 0x1 이 있습니다 + (5x1) +(7x1) + (1x0) + (8x0) + (2x0) + (2X-1) + (9x-1) + (5x-1) 하세요. 그리고 이 9개 숫자를 더하면 마침내 -4 라는 결과가 나오게 됩니다. 이걸 오른쪽으로 옮겨서, 9개의 연산을 수행해서 모두 더해보십시오. 그럼 0 이 되고, 이 곳은 8 이 될 겁니다. 확인해보려면, 2+9+5 = 16이 되죠. 가운데 세로 열은 0 이 됩니다. 그리고 가장 오른쪽 세로 행은 -4+ -1 + 3x-1 그럼 -8 이 되어, 왼쪽의 16에서 -8을 하고, 그럼 이 곳에 8 이 됩니다. 다음으로, 그 다음 가로 행의 요소를 알아내기 위해 여러분이 해 야할 일은 파란색 네모 칸을 한 칸 아래로 옮겨서 만들고 저 위치 값을 얻는 것입니다. 요소 간 곱셈(element wise product)를 반복 수행하고 덧셈을 하십시오. 그렇게 하시면, -10을 얻게 될 겁니다. 이걸 한 칸 오른쪽으로 이동시키면, -2, 2, 3 이런 식으로 되겠죠. 이렇게 매트릭스 행렬의 나머지 모든 요소들을 채워주세요. 더 명확하게 하자면, 이 -16이 이 아래쪽 3x3 부분으로부터 얻어지면 되는 겁니다. 3x3 매트릭스로 컨볼브된 6x6 매트릭스는 결국 4x4 매트릭스가 되는 것이죠. 이것들이 이미지와 필터입니다. 정말 다양한 차원의 매트릭스죠. 하지만, 왼쪽에 있는 매트릭스는 하나의 이미지처럼 해석하기가 편리합니다. 가운데 있는 것은 필터처럼 해석하고, 오른쪽 것은 아마 또 다른 이미지로 풀이해 볼 수 있을 겁니다. 그리고 이건 vertical edge detector(수직선 감지기)라는 게 분명해 보이는데요 다음 슬라이드에서는 왜, 계속하기 전에 하나 덧붙이자면 이걸 여러분이 프로그래밍 언어로 실행해보면, 실제로는 대부분의 외국어들이 컨볼루션을 표현할 때 별표 보다는 몇 가지의 다른 함수를 사용하고 있다는 것을 알게 될 것입니다. 예를 들어, 이전 예제 연습들에서, Conv-forward라는 함수를 사용하거나 실행시켰었습니다. 만약 tens of flow로 실행하게 되면, tf.nn.cont2d라는 함수가 있습니다. 그리고 또 다른 딥러닝 프로그래밍 체계로 Keras 프로그램 펌웨어, 이건이 과정 뒤 부분에서 같이 보게 될 텐데요. 컨볼루션을 수행하는 cont2d라는 함수가 있습니다. 하지만 컴퓨터 비전을 잘 지원하는 모든 딥러닝 체계들은 이 convolution operator를 실행하기 위해 몇 가지 함수를 사용하게 됩니다. 그럼, 왜 vertical edge detection를 수행하는 것일까요? 다른 예제를 보시죠. 이를 설명하기 위해, 단순화시킨 이미지를 사용해 보겠습니다. 여기 단순한 6x6 이미지가 있습니다. 이미지의 왼쪽 절반은 10이고, 오른쪽 절반은 0 입니다. 이것을 그림으로 생각해본다면, 이렇게 보일 겁니다. 10이 있는 왼쪽 절반은 더 밝은 픽셀 집약 값을 가지고 있고 오른쪽 절반은 더 어두운 픽셀 집약 값을 가지고 있습니다 저는 0을 표현하기 위해서 회색 쉐이드를 사용하고 있습니다 검정색으로 보여지긴 하지만 말이죠. 하지만 이 이미지에서, 가운데에 바로 매우 강한 vertical edge가 있습니다. 흰색에서 검정 혹은 흰색에서 더 어두운 색으로 전환되기 때문이죠. 3x3필터를 사용해서 컨볼브하고 그 결과 3x3 필터가 시각화될 때에는 다음과 같이 됩니다. 왼쪽에 더 밝은 픽셀이 있고 중간 톤의 0이 가운데에 있고, 오른쪽에는 더 어두운 픽셀이 있게 됩니다. 오른쪽과 같은 매트릭스를 얻게 되는 것이죠. 이 연산과정을 확인해보자면, 예를 들어 이 0은 element wise product를 수행하여 얻게 되는 숫자이고, 3x3블록을 가지고 곱셈을 진행하면 됩니다. 그렇게 하여 왼쪽 세로 열 10 + 10 + 10, 그리고 가운데 있는 0 들, 그리고 -10, -10, -10 을 더해서 바로 여기에 있는 0을 결국 얻게 되는 것입니다. 반면 그 반대로, 30이 얻어지는 것은, 10+10+10 -0 -0 으로부터 바로 저기에 있는 30 이 생기게 되는 것이죠. 자, 이 오른쪽 매트릭스의 이미지를 생각해보면 바로 이 가운데에는 이렇게 연한 영역처럼 보일 것입니다. 그리고 이는 6x6 이미지의 중간에 이 vertical edge를 감지한 것과 같습니다. 리고 이는 6x6 이미지의 중간에 이 vertical edge를 감지한 것과 같습니다. 감지된 테두리가 약간 두껍게 보여 이 dimension이 잘못되었다 싶어 보일 수 있는데요, 이는 그냥 이 매우 작은 이미지의 예시로 작업을 하고 있기 때문으로 보면 됩니다. 만약 6x6 이미지가 아니라 1000x1000 이미지 같은 것을 사용하고 있다면, 이미지 속 수직 가장자리들이 잘 감지되며 이 과정이 잘 진행되는 것을 볼 수 있을 것입니다. 이 예시에서, 가운데에 있는 밝은 영역이 바로 아웃풋 이미지인데요, 마치 이미지 중간에 강한 수직 가장자리가 있는 것처럼 보입니다. 이는 아마도 vertical edge detection으로부터 생각해볼 때, 우리가 3x3필터를 사용하고 있기 때문에 vertical edge가 3x3 영역이라는 점입니다. 여기엔 왼쪽에는 밝은 픽셀이 있고 가운데는 그다지 신경 쓰지 않아도 됩니다, 오른쪽에는 어두운 픽셀들이 있습니다. 이 6x6 이미지 중간에는 왼쪽엔 밝은 픽셀이, 그리고 오른쪽에는 어두운 픽셀이 있을 수 있습니다. 따라서 이쪽에 수직 가장자리가 있다고 생각되는 것이죠. 컨벌루션 연산은 이미지에 있는 수직 가장자리를 어떻게 찾을지 구체화시키는 편리한 방법을 제공해줍니다. 지금까지 어떻게 convolution operator가 작동하는지 살펴보았습니다. 다음 강의에서는 컨볼루션 신경망의 기본적인 빌딩블록의 하나로서 어떻게 사용할 수 있을지 알아보도록 하겠습니다.