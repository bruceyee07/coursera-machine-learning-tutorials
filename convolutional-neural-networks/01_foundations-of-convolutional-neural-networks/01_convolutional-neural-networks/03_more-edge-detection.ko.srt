1
00:00:02,026 --> 00:00:06,778
컨벌루션 연산을 통해 vertical edge detector를

2
00:00:06,778 --> 00:00:07,800
구현하는 방법을 살펴 보았습니다

3
00:00:07,800 --> 00:00:12,285
이번 강의에서는, 포지티브 에지와 네거티브 에지의 차이점,

4
00:00:12,285 --> 00:00:16,432
다시 말해, 밝음에서 어두운 에지로의 변화와 어두움에서 밝은 에지로의 변화되는 차이점을 알아보도록 하겠습니다.

5
00:00:16,432 --> 00:00:19,384
또한 어떻게 알고리즘이 학습하게 할 수 있을지 뿐만 아니라

6
00:00:19,384 --> 00:00:21,731
다른 유형의 edge detector를 보게 될 것입니다.

7
00:00:21,731 --> 00:00:26,500
지금까지 해왔던 것처럼 edge detector를 직접 핸드코딩시키는게 아닙니다.

8
00:00:26,500 --> 00:00:28,456
그럼 시작해보겠습니다.

9
00:00:31,612 --> 00:00:36,050
이전 강의에서 보셨던 예시입니다.

10
00:00:36,050 --> 00:00:39,377
6x6, 왼쪽은 밝고 오른쪽은 어두운 이 이미지를 보셨었습니다.

11
00:00:39,377 --> 00:00:43,752
그리고 이걸 vertical edge detection 필터와 합성해서

12
00:00:43,752 --> 00:00:46,390
이미지 가운데에 수직 에지가 감지되도록 했었죠.

13
00:00:47,710 --> 00:00:51,400
색상이 뒤집어져서

14
00:00:51,400 --> 00:00:55,108
왼쪽이 어둡고 오른쪽이 밝은 이미지에서는 어떤 일이 생길까요?

15
00:00:55,108 --> 00:00:59,930
이렇게 하니 10 은 이미지 오른쪽 절반에 있고, 0은 왼쪽에 있군요.

16
00:00:59,930 --> 00:01:03,240
그걸 똑같은 edge detection 필터와 합성하면,

17
00:01:03,240 --> 00:01:07,835
가운데가 30 대신에 -30의 결과를 가지게 됩니다.

18
00:01:07,835 --> 00:01:12,820
이렇게 생긴 그림을 그려볼 수 있을 겁니다.

19
00:01:12,820 --> 00:01:15,566
전환되는 명암이 이렇게 반대로 되기 때문에,

20
00:01:15,566 --> 00:01:18,290
이제 30 또한 반대로 뒤바뀌게 되는 것입니다.

21
00:01:18,290 --> 00:01:21,160
그리고 -30은

22
00:01:21,160 --> 00:01:26,790
밝은 색에서 어둠으로의 변화가 아니라 어두운 색에서 밝은 색으로 변화하는 것이죠.

23
00:01:26,790 --> 00:01:30,689
이 둘 중 어느 경우인지 신경 쓰지 않으면,

24
00:01:30,689 --> 00:01:34,780
이 결과 매트릭스의 절대값을 얻을 수 있습니다.

25
00:01:34,780 --> 00:01:39,364
그러나 이 특정한 필터는 밝은 색에서 어두운 색으로 변하는 에지와

26
00:01:39,364 --> 00:01:41,340
어두운 색에서 밝은 색으로 변화하는 에지의 차이점을 만들어냅니다.

27
00:01:42,500 --> 00:01:45,190
edge detection의 예시를 좀 더 보시죠.

28
00:01:45,190 --> 00:01:49,640
지금까지 공부한 이 3 x 3 필터를 사용하면 vertical edges(수직 모서리)를 감지 할 수 있습니다.

29
00:01:49,640 --> 00:01:53,470
따라서, 이 3x3필터가 수평 모서리를 감지해내는 것도

30
00:01:53,470 --> 00:01:58,160
여러분에게 놀라운 일도 아닐 겁니다.

31
00:01:58,160 --> 00:02:02,450
기억해두실 것은, 이 필터에 따르면, 수직 모서리는

32
00:02:02,450 --> 00:02:06,130
왼쪽에 상대적으로 밝은 픽셀과

33
00:02:06,130 --> 00:02:08,580
상대적으로 어두운 오른쪽 부분에 있는 3x3영역이라는 것입니다.

34
00:02:08,580 --> 00:02:13,080
이와 비슷하게, 수평 모서리는,

35
00:02:13,080 --> 00:02:18,510
픽셀이 위쪽은 상대적으로 밝고 아래쪽은 상대적으로 어두운 3x3 영역이 됩니다.

36
00:02:18,510 --> 00:02:22,392
예시가 하나 있습니다. 이건 좀 더 복잡한데요,

37
00:02:22,392 --> 00:02:27,967
위쪽 왼쪽과 오른쪽 아래 코너에 10들이 있습니다.

38
00:02:27,967 --> 00:02:32,559
따라서 이걸 이미지로 그려보시면,

39
00:02:32,559 --> 00:02:37,379
0이 있는 곳은 어두운 이미지가 되겠죠, 따라서 어두운 영역에 쉐이드를 만들어보겠습니다.

40
00:02:37,379 --> 00:02:41,459
위쪽 왼쪽과 오른쪽 아래 코너가 있는데요.

41
00:02:41,459 --> 00:02:47,190
이걸 수평 모서리 감지기와 합성하면, 이걸 얻을 수 있습니다.

42
00:02:48,470 --> 00:02:51,462
몇 가지 예시를 보자면,

43
00:02:51,462 --> 00:02:55,774
여기 있는 이 30은 이 3x3영역에 대응하는데요,

44
00:02:55,774 --> 00:03:01,407
실제로 위쪽엔 밝은 픽셀이 있고 아래쪽엔 어두운 픽셀들이 있습니다.

45
00:03:01,407 --> 00:03:04,110
바로 여기죠.

46
00:03:04,110 --> 00:03:08,391
강한 포지티브 에지를 만들어내는 것입니다.

47
00:03:08,391 --> 00:03:12,309
그리고 여기에 이 -30은 이 영역에 대응하게 되는데요,

48
00:03:12,309 --> 00:03:16,987
아래쪽은 더 밝고, 위쪽은 어둡게 되는 것이죠

49
00:03:16,987 --> 00:03:21,210
그리고 이게 바로 네거티브 에지의 예시입니다.

50
00:03:21,210 --> 00:03:26,124
다시 말해서, 우리가 6x6같은

51
00:03:26,124 --> 00:03:31,300
상대적으로 작은 이미지들로 작업하고 있다는 사실을 보여주는 것입니다.

52
00:03:31,300 --> 00:03:34,210
하지만 예를 들어 -10같은 이 중간 값들은

53
00:03:34,210 --> 00:03:39,150
왼쪽에 포지티브 에지 부분을 담아내고

54
00:03:39,150 --> 00:03:44,020
오른쪽에 네거티브 에지를 담아낸다는 사실을 보여주는 것입니다.

55
00:03:44,020 --> 00:03:47,120
따라서 그것들을 함께 섞으면 중간 값을 얻게 되는 것이죠.

56
00:03:47,120 --> 00:03:49,050
하지만 이게 매우 큰,

57
00:03:49,050 --> 00:03:54,160
체크 패턴을 가진 1000x1000 정도의 이미지라면,

58
00:03:54,160 --> 00:03:58,176
이런 10의 전환영역은 보이지 않습니다.

59
00:03:58,176 --> 00:04:02,950
중간 값은 이미지 사이즈에 비해 꽤 작을 겁니다.

60
00:04:02,950 --> 00:04:10,220
요약하자면, 다른 필터를 사용하면 수직/수평 에지를 찾도록 도와줍니다.

61
00:04:10,220 --> 00:04:15,320
다시 말해, 우리가 사용한 3x3 수직 에지 detection filter는

62
00:04:15,320 --> 00:04:17,870
가능한 여러 선택 중 하나일 뿐이라는 게 분명한 거죠.

63
00:04:17,870 --> 00:04:20,470
역사적으로 볼 때, 컴퓨터 비전 문헌에서,

64
00:04:20,470 --> 00:04:24,750
어떤 게 최상의 숫자체계인지에 대해 꽤 많은 논의가 있었습니다.

65
00:04:24,750 --> 00:04:29,513
따라서 여러분이 사용할 수 있는 또 다른 것은, 아마도 1, 2

66
00:04:29,513 --> 00:04:32,840
1, 0, 0, 0, -1, -2, -1 일겁니다.

67
00:04:32,840 --> 00:04:35,670
이건 Sobel Filter라고 불리는 겁니다.

68
00:04:35,670 --> 00:04:40,981
이것의 장점은 중앙 열, 중앙픽셀에 에 좀 더 무게를 두어

69
00:04:40,981 --> 00:04:46,620
좀 더 견고하게 만든다는 것입니다.

70
00:04:46,620 --> 00:04:50,711
그러나 컴퓨터 비전 연구원들은 또 다른 세트의 숫자들도 사용하겠죠.

71
00:04:50,711 --> 00:04:54,950
1, 2, 1, 대신에 3, 10, 3, 이렇게 될 수 있을 겁니다, 그렇죠?

72
00:04:54,950 --> 00:04:59,330
그리고 -3 ,-10, -3 이렇게요.

73
00:04:59,330 --> 00:05:01,931
그리고 이건 Scharr Filter라는 겁니다.

74
00:05:01,931 --> 00:05:06,752
이건 약간 다른 특징을 가지고 있습니다

75
00:05:06,752 --> 00:05:10,235
그리고 이건 vertical edge detection만을 위한 겁니다.

76
00:05:10,235 --> 00:05:13,043
그리고 이걸 90도 돌려보시면, horizontal edge detection을 볼 수 있죠.

77
00:05:13,043 --> 00:05:18,350
딥러닝이 떠오르면서, 우리가 배운 것 중의 하나는

78
00:05:18,350 --> 00:05:23,743
복잡한 이미지에서 모서리들을 감지할 때,

79
00:05:23,743 --> 00:05:29,319
컴퓨터 비전 연구원들이 이 9개의 숫자를 택하게 하지 않아도 된다는 겁니다.

80
00:05:29,319 --> 00:05:33,855
여러분은 그냥 그걸 배워서 이 매트릭스의 9개의 숫자들을

81
00:05:33,855 --> 00:05:37,745
파라미터로 처리하면, 백 프로퍼게이션 (역전파)을 사용하는 것을 배울 수 있을 테니까요.

82
00:05:37,745 --> 00:05:42,095
목표는 9개의 파라미터를 배워서 6x6 이미지를 얻어낼 때,

83
00:05:42,095 --> 00:05:46,373
그리고 그걸 3x3 필터와 컨볼브해서

84
00:05:46,373 --> 00:05:48,935
좋은 edge detector를 만들어내도록 하는 거죠.

85
00:05:50,030 --> 00:05:54,840
후속 강의들에서는 파라미터로 이 9개의 숫자들을 처리하여

86
00:05:54,840 --> 00:05:59,571
역전 파가 1, 1, 1, 0, 0, 0, -1, -1을 학습하거나

87
00:05:59,571 --> 00:06:04,680
혹은 Sobel Filter 나 Scharr Filter를 학습하거나,

88
00:06:04,680 --> 00:06:08,364
혹은 이런 핸드코딩된 필터보다

89
00:06:08,364 --> 00:06:13,210
여러분 데이타의 통계를 훨씬 잘 담아낼 수 있는 무언가를 학습하도록 선택하는 것을 알아보겠습니다.

90
00:06:13,210 --> 00:06:17,005
그리고 수직/수평 에지가 아니라,

91
00:06:17,005 --> 00:06:21,219
45도로 된 모서리에서, 아님

92
00:06:21,219 --> 00:06:26,127
70도 혹은 73도 혹은 어느 방향으로 선택하든지 감지하는 것을 배울 수 있습니다.

93
00:06:26,127 --> 00:06:30,597
이 모든 숫자들이 파라미터가 되게 만들고

94
00:06:30,597 --> 00:06:35,356
데이타로부터 자동으로 그걸 배움으로써, 신경망가

95
00:06:35,356 --> 00:06:39,970
low-level features배우고, 에지 같은 특징들을 배우도록 할 수 있을 겁니다.

96
00:06:39,970 --> 00:06:45,467
컴퓨터 비전 연구원들이 수작업으로 이것들을 암호화 시키는 것보다 훨씬 견고하게 할 수 있을 겁니다.

97
00:06:45,467 --> 00:06:51,404
이 모든 계산에는 여전히 컨벌루션 연산이 근간에 있으며,

98
00:06:51,404 --> 00:06:56,773
이는 back propagation으로 하여금 3x3필터든 뭐든 배우게 합니다.

99
00:06:56,773 --> 00:07:02,788
이 위치에서 감지하려 하는 게 어떤 특징이던 지간에 결과물로 내기 위해서

100
00:07:02,788 --> 00:07:08,266
그걸 전체 이미지에 적용시키는 거죠.

101
00:07:08,266 --> 00:07:13,296
그게 수직 에지, 수평 에지, 혹은 또 다른 각도에서의 에지나

102
00:07:13,296 --> 00:07:18,260
심지어 영어로 이름조차 없는 다른 필터일 수도 있습니다.

103
00:07:19,370 --> 00:07:22,945
이 9개의 숫자를 파라미터로 학습되도록 하는 생각은

104
00:07:22,945 --> 00:07:26,890
컴퓨터 비전분야에서 가장 영향력 있는 아이디어의 하나였습니다.

105
00:07:26,890 --> 00:07:31,654
이 과정의 뒷부분에서, 이번 주 후반이 되겠네요,

106
00:07:31,654 --> 00:07:36,034
이 9개의 숫자를 배우기 위해서 back propagation을 사용하는 방법에 대해 자세하게 이야기해보죠.

107
00:07:36,034 --> 00:07:39,638
하지만 우선, 기본 컨벌루션 연산에서

108
00:07:39,638 --> 00:07:41,890
몇 가지 다른 변수나 몇 가지 세부사항에 대해 이야기해봅시다.

109
00:07:41,890 --> 00:07:46,219
다음 강좌에서는 컨볼루션에서 패딩과

110
00:07:46,219 --> 00:07:48,510
스트라이드 사용하는 방법을 이야기해보고 싶습니다

111
00:07:48,510 --> 00:07:52,943
이 두 가지가 convolution neural network 빌딩블록의

112
00:07:52,943 --> 00:07:55,130
중요한 요소들이 될 것입니다.

113
00:07:55,130 --> 00:07:56,420
다음 강좌로 가보시죠