1
00:00:01,410 --> 00:00:05,830
為了要建立深度神經網路，一個

2
00:00:05,830 --> 00:00:10,675
基本卷積運算您需要修改的是填充

3
00:00:10,675 --> 00:00:12,232
我們來看看其運作

4
00:00:12,232 --> 00:00:15,190
我們之前的影片中看過，如果您拿

5
00:00:15,190 --> 00:00:19,385
一個 6乘6 影像卷積一個 3乘3 過濾器

6
00:00:19,385 --> 00:00:23,585
您最終會得到一個 4乘4 矩陣輸出

7
00:00:23,585 --> 00:00:28,080
而這是因為用這 3乘3 過濾器
有可能的位置的數量

8
00:00:28,080 --> 00:00:29,470
也就只有

9
00:00:29,470 --> 00:00:31,780
4乘4 個可能位置

10
00:00:31,780 --> 00:00:37,035
對於這個 3乘3 過濾器對應到您的 6乘6 矩陣

11
00:00:37,035 --> 00:00:41,346
跟數學有關的是
一般而言如果您有

12
00:00:41,346 --> 00:00:45,725
一個 n乘n 影像跟 f乘f 過濾器卷積

13
00:00:45,725 --> 00:00:48,850
那輸出的維度會是

14
00:00:48,850 --> 00:00:58,237
(n-f+1)乘 (n-f+1) 維度

15
00:00:58,237 --> 00:00:59,665
在這個例子

16
00:00:59,665 --> 00:01:03,455
6-3+1 等於 4

17
00:01:03,455 --> 00:01:07,489
這是為什麼您會得到一個 4乘4 輸出

18
00:01:07,489 --> 00:01:10,400
這個有兩個缺點：其一是

19
00:01:10,400 --> 00:01:14,790
如果每次您應用卷積運算，您的影像縮小

20
00:01:14,790 --> 00:01:17,595
您從 6乘6 縮成 4乘4

21
00:01:17,595 --> 00:01:21,716
在您的影像變得太小前，
您只能這樣做幾次

22
00:01:21,716 --> 00:01:23,870
或許它會縮成 1乘1，或者其他

23
00:01:23,870 --> 00:01:26,720
所以，或許您不想您的影像

24
00:01:26,720 --> 00:01:29,902
在每次當您偵測邊緣或者
測試其他特徵時縮小

25
00:01:29,902 --> 00:01:31,605
這是一個缺點

26
00:01:31,605 --> 00:01:33,590
而第二個缺點

27
00:01:33,590 --> 00:01:36,665
而如果您看角落這個像素

28
00:01:36,665 --> 00:01:40,755
這個小像素只會在一次的運算中用到

29
00:01:40,755 --> 00:01:43,490
因為這像素被這 3乘3 區域用到

30
00:01:43,490 --> 00:01:48,905
而，如果您看中間這個像素，
假設這個像素

31
00:01:48,905 --> 00:01:55,380
那有很多的 3乘3 區域
會覆蓋到這個像素

32
00:01:55,380 --> 00:02:01,455
好像如果在角落或是在邊緣的像素
在輸出時用得較少

33
00:02:01,455 --> 00:02:06,390
所以您丟掉了很多靠近邊緣影像的資訊

34
00:02:06,390 --> 00:02:08,735
為了解決這兩個問題

35
00:02:08,735 --> 00:02:12,829
無論是縮小輸出

36
00:02:12,829 --> 00:02:15,485
也就是當您建立深度神經網路

37
00:02:15,485 --> 00:02:19,685
您見到了為什麼您不想讓影像每一次都縮小，
因為如果這樣

38
00:02:19,685 --> 00:02:22,038
或許數百層的深度網路

39
00:02:22,038 --> 00:02:23,710
它每次縮一點

40
00:02:23,710 --> 00:02:27,993
經過上百層後，您會得到很小的影像

41
00:02:27,993 --> 00:02:29,085
這是一個問題

42
00:02:29,085 --> 00:02:38,120
另一個是丟掉很多在影像邊緣的資訊

43
00:02:38,120 --> 00:02:40,740
為了要解決這兩件問題

44
00:02:40,740 --> 00:02:44,774
您可以這樣做，在應用卷積運算前

45
00:02:44,774 --> 00:02:46,959
您可以填充這個影像

46
00:02:46,959 --> 00:02:56,185
在這個例子，假設您將這個影像
多填充了一個邊框

47
00:02:56,185 --> 00:03:00,670
在邊緣多增加了一個像素的邊框

48
00:03:00,670 --> 00:03:02,635
如果您這樣做

49
00:03:02,635 --> 00:03:05,517
那不再是一個 6乘6 影像

50
00:03:05,517 --> 00:03:09,500
您現在填充過的是一個 8乘8 影像

51
00:03:09,500 --> 00:03:14,007
您將這個 8乘8 影像跟 3乘3 影像卷積，

52
00:03:14,007 --> 00:03:16,960
您現在的輸出不是 4乘4 
而是 6乘6

53
00:03:16,960 --> 00:03:23,667
因次您設法保留了
原本輸入 6乘6 的大小

54
00:03:23,667 --> 00:03:25,350
依照慣例，當您填充時

55
00:03:25,350 --> 00:03:33,296
您用 0 來填充，而如果 p 是填充量

56
00:03:33,296 --> 00:03:34,575
那麼這樣的話

57
00:03:34,575 --> 00:03:36,615
p 等於 1

58
00:03:36,615 --> 00:03:41,180
因為我們到處都填ㄧ個
額外一個像素的邊框

59
00:03:41,180 --> 00:03:47,940
那輸出會變成

60
00:03:47,940 --> 00:03:54,360
n+2p-f+1 乘 n+2p-f+1

61
00:03:54,360 --> 00:04:02,480
所以這會變成 6 + 2*1 - 3 + 1

62
00:04:02,480 --> 00:04:06,475
所以 6 + 2*1 - 3 + 1 等於 6

63
00:04:06,475 --> 00:04:12,880
所以您最終會有一個 6乘6 
影像來保留原本影像的大小

64
00:04:12,880 --> 00:04:16,030
所以這一個像素實際上被

65
00:04:16,030 --> 00:04:23,330
這些輸出的元素影響，有效地補充

66
00:04:23,330 --> 00:04:26,700
或許不是被丟棄，而是

67
00:04:26,700 --> 00:04:32,715
從影像的邊緣或者角落少算的資訊

68
00:04:32,715 --> 00:04:34,255
而我在這裡顯示

69
00:04:34,255 --> 00:04:38,240
填充邊緣的只有一個像素的影響

70
00:04:38,240 --> 00:04:42,535
如果要的話，您也可以填兩個像素，這種情況下

71
00:04:42,535 --> 00:04:44,820
您加了另一個邊框

72
00:04:44,820 --> 00:04:50,125
如果要的話，您可以填進更多的像素

73
00:04:50,125 --> 00:04:52,812
我想我這裡畫的

74
00:04:52,812 --> 00:04:55,438
這會是 p 等於 2

75
00:04:55,438 --> 00:05:00,665
至於要填多少

76
00:05:00,665 --> 00:05:04,129
實際上有兩種常用的選項，稱為

77
00:05:04,129 --> 00:05:07,380
有效卷積跟相同卷積

78
00:05:07,380 --> 00:05:10,960
真的不是一個好的名稱，但有效卷積

79
00:05:10,960 --> 00:05:15,170
基本上的意思是沒有填充

80
00:05:15,170 --> 00:05:22,600
這種情況下，您或許有一個 n乘n 影像跟一個

81
00:05:22,600 --> 00:05:25,345
f乘f 過濾器卷積，這會給您

82
00:05:25,345 --> 00:05:30,298
n-f+1 乘 n-f+1 維度的輸出

83
00:05:30,298 --> 00:05:35,060
這就像是我們之前在前面的影片中看過的

84
00:05:35,060 --> 00:05:37,250
我們用 n乘n 影像跟

85
00:05:37,250 --> 00:05:43,095
3乘3 過濾器，而給您 4乘4 的輸出

86
00:05:43,095 --> 00:05:48,545
其他最常用的填充選擇是稱為

87
00:05:48,545 --> 00:05:52,660
相同卷積，意思是當您填充時

88
00:05:52,660 --> 00:05:58,580
輸出的大小跟輸入的大小相同

89
00:05:58,580 --> 00:06:01,795
如果我們認真看這個公式

90
00:06:01,795 --> 00:06:04,635
當您填 p 個像素時

91
00:06:04,635 --> 00:06:11,676
就是當右邊 n 變為 n+2p

92
00:06:11,676 --> 00:06:15,740
減去 f 加 1

93
00:06:15,740 --> 00:06:22,125
所以我們有 n乘n 影像，然後加入一個邊框為 p 像素

94
00:06:22,125 --> 00:06:28,900
輸出的維度會是 n+2p-f+1

95
00:06:28,900 --> 00:06:36,080
所以，如果您要 n+2p-f+1 等於 n

96
00:06:36,080 --> 00:06:38,795
也就是輸出大小跟輸入大小相同

97
00:06:38,795 --> 00:06:42,905
如果您解這個方程式，

98
00:06:42,905 --> 00:06:46,664
兩邊的 n 取消，如果您解 p 的話

99
00:06:46,664 --> 00:06:53,463
這意味著 p 等於 (f-1)/2

100
00:06:53,463 --> 00:06:56,181
所以當 f 是奇數

101
00:06:56,181 --> 00:06:58,990
選擇填充的大小如下

102
00:06:58,990 --> 00:07:01,960
您可以確保輸出的大小跟

103
00:07:01,960 --> 00:07:06,265
輸入大小相同，所以這是為什麼

104
00:07:06,265 --> 00:07:10,795
當過濾器是 3乘3 時，
就像在前面的投影片中

105
00:07:10,795 --> 00:07:15,990
填充量會讓輸出大小跟
輸入大小一樣的會是

106
00:07:15,990 --> 00:07:21,790
(3 - 1) /2 也就是 1

107
00:07:21,790 --> 00:07:23,415
而像另一個例子

108
00:07:23,415 --> 00:07:28,250
如果您的過濾器是 5乘5

109
00:07:28,250 --> 00:07:30,395
所以如果 f 等於 5

110
00:07:30,395 --> 00:07:35,590
如果您將它填入這個方程式，
您會發現當填充量為 2 時

111
00:07:35,590 --> 00:07:43,154
會保留輸出大小跟輸入大小一樣，
當過濾器為 5乘5 時

112
00:07:43,154 --> 00:07:46,440
電腦視覺的慣例是

113
00:07:46,440 --> 00:07:50,435
f 通常是奇數

114
00:07:50,435 --> 00:07:59,070
實際上幾乎都是奇數，
您很少見到偶數的過濾器

115
00:07:59,070 --> 00:08:02,631
電腦視覺用到的過濾器

116
00:08:02,631 --> 00:08:05,280
我想有兩個原因

117
00:08:05,280 --> 00:08:07,320
一是如果 f 是偶數

118
00:08:07,320 --> 00:08:10,155
那您會需要一些不對稱填充

119
00:08:10,155 --> 00:08:15,380
所以只有在當 f 為奇數時，
這種卷積會給您一個自然的填充區域

120
00:08:15,380 --> 00:08:17,180
周邊都用同樣的維度，而不是

121
00:08:17,180 --> 00:08:20,290
在左邊填多一點，右邊填少一點

122
00:08:20,290 --> 00:08:22,104
或者不對稱的東西

123
00:08:22,104 --> 00:08:27,440
其二，當您用奇數維度的過濾器

124
00:08:27,440 --> 00:08:29,770
像是3乘3 或者 5乘5

125
00:08:29,770 --> 00:08:32,860
那它會有一個中心位置，也時候在

126
00:08:32,860 --> 00:08:36,095
電腦視覺最好有一個區分器

127
00:08:36,095 --> 00:08:37,450
最好有一個像素

128
00:08:37,450 --> 00:08:43,527
您可以用中間這個像素來當過濾器的位置

129
00:08:43,527 --> 00:08:48,080
或許這些都不是重大的理由來說 f 總是

130
00:08:48,080 --> 00:08:50,310
奇數，但如果您看卷積的文獻時

131
00:08:50,310 --> 00:08:53,482
您會看到 3乘3 過濾器最常見

132
00:08:53,482 --> 00:08:56,155
也時候會見到 5乘5, 7乘7

133
00:08:56,155 --> 00:08:58,985
有時候，晚一點我們也會

134
00:08:58,985 --> 00:09:02,095
談到 1乘1 的過濾器跟
為什麼用它是有道理的

135
00:09:02,095 --> 00:09:04,130
但只是依照慣例

136
00:09:04,130 --> 00:09:08,335
我建議您也只使用奇數的過濾器

137
00:09:08,335 --> 00:09:10,385
我想您或許可以

138
00:09:10,385 --> 00:09:14,180
獲得較好的性能
即使您想要用偶數的 f 值

139
00:09:14,180 --> 00:09:18,538
但如果您依照電腦視覺的慣例

140
00:09:18,538 --> 00:09:25,865
我通常只用奇數的 f 值，
所以您見到了如何使用填充卷積

141
00:09:25,865 --> 00:09:28,890
要為您的卷積運算做填充

142
00:09:28,890 --> 00:09:31,200
您可以指定

143
00:09:31,200 --> 00:09:34,835
p 一個值，或者您可以說這是一個有效卷積

144
00:09:34,835 --> 00:09:38,595
也就是說 p 等於 0，或者您可以說用相同卷積

145
00:09:38,595 --> 00:09:40,850
也就是填充到您可以確保

146
00:09:40,850 --> 00:09:43,780
輸出跟輸入的維度一樣

147
00:09:43,780 --> 00:09:45,181
這就是填充

148
00:09:45,181 --> 00:09:49,220
在下一段影片，讓我們來談您如何建置跨步卷積