1
00:00:01,580 --> 00:00:05,000
Convolution operation (컨볼루션 연산)은 Convolution neural network (컨볼루션 신경망)의

2
00:00:05,000 --> 00:00:06,870
기본적인 구성 블록들 중 하나입니다.

3
00:00:06,870 --> 00:00:10,050
이번 강의에서는 동기 부여가 될만한 예시로서 edge detection을 사용해서

4
00:00:10,050 --> 00:00:14,030
어떻게 컨볼루션 연산이 작동하는지 보도록 하죠.

5
00:00:17,743 --> 00:00:18,943
이전 강의들에서,

6
00:00:18,943 --> 00:00:23,810
신경망의 초기 레이어가 어떻게 모서리를 감지하는지 말씀 드렸습니다.

7
00:00:23,810 --> 00:00:27,250
그리고 후기 레이어가 어떻게 대상의 일부를 감지할 수 있는지를,

8
00:00:27,250 --> 00:00:31,320
심지어 후기 레이어들이 이 예시에 있는 사람들 얼굴처럼 완전한 물체의

9
00:00:31,320 --> 00:00:33,380
부분들을 어떻게 감지할 수 있는지도 말씀 드렸습니다.

10
00:00:35,270 --> 00:00:40,740
이번 영상에서는, 이미지 안의 모서리를 어떻게 감지하는지 알아봅시다.

11
00:00:40,740 --> 00:00:42,360
예를 들어보겠습니다.

12
00:00:42,360 --> 00:00:46,760
이런 그림이 주어지면, 컴퓨터는 이 사진에서 어떤 대상들이 있는지 알아내야 합니다.

13
00:00:46,760 --> 00:00:53,205
여러분이 해야 하는 첫 번째 일은 바로 
이 이미지 안에 있는 수직 테두리들을 탐지하는 것입니다.

14
00:00:54,650 --> 00:00:59,470
예를 들어, 이 이미지는 난간이 있는 곳에 저런 수직선들을 가지고 있습니다

15
00:00:59,470 --> 00:01:04,040
또한, 행인들과 같은 부류의 수직선도 있습니다.

16
00:01:04,040 --> 00:01:08,420
그런 선들이 이 vertical edge detecThistor (수직선 감지기)에서 탐지되는 것입니다.

17
00:01:09,860 --> 00:01:12,340
그리고 수평선을 감지해야 할 때는,

18
00:01:12,340 --> 00:01:17,180
예를 들자면 이 난간에 아주 강한 수평선이 있는데요

19
00:01:17,180 --> 00:01:20,410
또한 대략 이쪽 부분에서도 감지가 됩니다.

20
00:01:21,520 --> 00:01:25,034
그럼, 어떻게 이런 이미지에서 테두리들을 감지해낼 수 있을까요?

21
00:01:25,034 --> 00:01:26,160
예시를 봐볼까요.

22
00:01:27,670 --> 00:01:31,056
이런 6x6 grayscale 이미지가 있습니다.

23
00:01:31,056 --> 00:01:35,949
이건 grayscale 이미지이므로, 6x6x1 매트릭스라고 할 수 있습니다.

24
00:01:35,949 --> 00:01:40,700
분리된 RGB채널상에 있기 때문에 6x6x3은 아니죠.

25
00:01:41,790 --> 00:01:46,213
이미지 안에 있는 이런 테두리들, 즉 수직선들을 감지하기 위해서는,

26
00:01:46,213 --> 00:01:49,093
우선, 3x3 매트릭스를 만드십시오.

27
00:01:49,093 --> 00:01:53,733
그리고 컨볼루션 신경망 용어로는

28
00:01:53,733 --> 00:01:55,950
이런 걸 필터라고 부릅니다.

29
00:01:57,390 --> 00:02:01,543
그럼 이번엔 3x3필터 혹은

30
00:02:01,543 --> 00:02:08,679
3x3 매트릭스를 만들어보겠습니다. 1, 1, 1, 0, 0, 0, -1, -1, -1 이렇게요.

31
00:02:08,679 --> 00:02:12,947
때로는 연구 보고서에선 이것을 필터가 아니라 kernel이라고 부르기도 합니다.

32
00:02:12,947 --> 00:02:16,370
하지만 이 강의에서는 필터라고 부르도록 하겠습니다.

33
00:02:17,890 --> 00:02:22,730
6x6 이미지를 가지고, 컨볼브 하면

34
00:02:22,730 --> 00:02:27,107
콘볼루션 연산은 이런 별표로 표현됩니다.

35
00:02:29,560 --> 00:02:32,690
그러면 3x3필터로 컨볼브 하십시오.

36
00:02:32,690 --> 00:02:37,410
이 표식에서 한 가지 좀 안타까운 점은

37
00:02:37,410 --> 00:02:41,490
수학에서는 별표가 컨볼루션을 위한 표준 기호이지만,

38
00:02:41,490 --> 00:02:45,648
파이톤에서는 곱셈 혹은 요소 간의 곱셈을 표시하기 위해 쓰여지고 있다는 거죠.

39
00:02:45,648 --> 00:02:48,440
파이톤에서는 곱셈 혹은 요소 간의 곱셈을 표시하기 위해 쓰여지고 있다는 거죠.

40
00:02:48,440 --> 00:02:53,009
이 별표는 두 개의 목적을 가지고 있어, 혼란을 줄 수 있는 기호이지만,

41
00:02:53,009 --> 00:02:58,598
이 강의에서 별표가 컨볼루션을 나타낼 때에, 명확하게 말씀 드리도록 하겠습니다.

42
00:02:58,598 --> 00:03:03,844
이 convolution operator의 결과는 4x4 매트릭스입니다.

43
00:03:03,844 --> 00:03:09,020
4x4 이미지로 생각해도 되겠습니다.

44
00:03:09,020 --> 00:03:13,330
이 4x4결과를 계산할 수 있는 방법은 다음과 같습니다.

45
00:03:13,330 --> 00:03:18,522
4x4 매트릭스의 맨 위 왼쪽에 있는 첫 번째 element(요소)들을 계산하기 위해서는

46
00:03:18,522 --> 00:03:21,848
3x3 필터를 가져다가

47
00:03:21,848 --> 00:03:26,254
원본 인풋이미지의 3x3 영역 위에 붙여 넣기 하는 겁니다.

48
00:03:26,254 --> 00:03:30,920
1, 1, 1 이라고 썼고,

49
00:03:30,920 --> 00:03:34,872
0, 0, 0, -1, -1, -1이라고 썼습니다.

50
00:03:34,872 --> 00:03:38,221
그리고 나서는 Element-wise Product(요소 간의 곱셈) 작업을 하는 겁니다.

51
00:03:38,221 --> 00:03:41,481
첫 번째 것은 3x1 이 되고,

52
00:03:41,481 --> 00:03:46,377
두 번째 것은 1x1 되겠죠.

53
00:03:46,377 --> 00:03:50,398
아래로 내려가서 1x1 그리고 2x1을 더해줍니다.

54
00:03:50,398 --> 00:03:53,340
그냥 1이죠, 그리고 나서 9개의 결과값을 모두 더해주세요.

55
00:03:53,340 --> 00:04:00,451
그러면 가운데 세로 열이 0x0 + 5x0

56
00:04:00,451 --> 00:04:06,357
+ 7x0 , 그리고 맨 오른쪽 칸은 0x-1이 됩니다.

57
00:04:06,357 --> 00:04:09,088
(8x-1) + (2x-1)

58
00:04:09,088 --> 00:04:15,875
이 9개의 숫자들을 더하면 음의 값 5가 되고

59
00:04:15,875 --> 00:04:19,340
그러니 -5를 바로 여기에 채워주겠습니다.

60
00:04:19,340 --> 00:04:22,450
이 9개의 숫자들은 어느 순서로 더해도 무방합니다.

61
00:04:22,450 --> 00:04:27,550
그냥 첫 번째 열 아래쪽으로 진행하고

62
00:04:27,550 --> 00:04:29,620
그리고 두 번째 행, 그리고 세 번째 이렇게 하면 되는 겁니다.

63
00:04:29,620 --> 00:04:33,467
다음으로는, 두 번째 element를 알아내려면

64
00:04:33,467 --> 00:04:39,526
이 파란 네모 칸을 이렇게 한 칸 오른쪽으로 옮기면 됩니다.

65
00:04:39,526 --> 00:04:42,100
초록색 표시는 없애도록 하죠.

66
00:04:42,100 --> 00:04:46,330
똑같은 element wise product(요소 간의 곱셈)을 하고 나서 더하시면 됩니다.

67
00:04:46,330 --> 00:04:52,501
0x1 이 있습니다 + (5x1) +(7x1)

68
00:04:52,501 --> 00:04:57,400
+ (1x0) + (8x0) + (2x0)

69
00:04:57,400 --> 00:05:03,450
+ (2X-1) + (9x-1)

70
00:05:03,450 --> 00:05:10,791
+ (5x-1) 하세요. 그리고 이 9개 숫자를 더하면 마침내 -4 라는 결과가 나오게 됩니다.

71
00:05:10,791 --> 00:05:16,078
이걸 오른쪽으로 옮겨서, 9개의 연산을 수행해서 모두 더해보십시오.

72
00:05:16,078 --> 00:05:19,424
그럼 0 이 되고, 이 곳은 8 이 될 겁니다.

73
00:05:19,424 --> 00:05:26,017
확인해보려면, 2+9+5 = 16이 되죠.

74
00:05:26,017 --> 00:05:29,165
가운데 세로 열은 0 이 됩니다.

75
00:05:29,165 --> 00:05:35,110
그리고 가장 오른쪽 세로 행은 -4+ -1 + 3x-1

76
00:05:35,110 --> 00:05:39,621
그럼 -8 이 되어, 왼쪽의 16에서 -8을 하고,

77
00:05:39,621 --> 00:05:43,796
그럼 이 곳에 8 이 됩니다.

78
00:05:43,796 --> 00:05:47,738
다음으로, 그 다음 가로 행의 요소를 알아내기 위해 여러분이 해 야할 일은

79
00:05:47,738 --> 00:05:52,280
파란색 네모 칸을 한 칸 아래로 옮겨서 만들고

80
00:05:52,280 --> 00:05:54,450
저 위치 값을 얻는 것입니다.

81
00:05:54,450 --> 00:05:59,920
요소 간 곱셈(element wise product)를 반복 수행하고 덧셈을 하십시오.

82
00:05:59,920 --> 00:06:02,967
그렇게 하시면, -10을 얻게 될 겁니다.

83
00:06:05,016 --> 00:06:11,147
이걸 한 칸 오른쪽으로 이동시키면,

84
00:06:11,147 --> 00:06:14,590
-2, 2, 3 이런 식으로 되겠죠.

85
00:06:14,590 --> 00:06:20,050
이렇게 매트릭스 행렬의 나머지 모든 요소들을 채워주세요.

86
00:06:21,400 --> 00:06:26,281
더 명확하게 하자면, 이 -16이 이 아래쪽

87
00:06:26,281 --> 00:06:29,980
3x3 부분으로부터 얻어지면 되는 겁니다.

88
00:06:31,080 --> 00:06:36,600
3x3 매트릭스로 컨볼브된 6x6 매트릭스는 결국 4x4 매트릭스가 되는 것이죠.

89
00:06:38,182 --> 00:06:39,760
이것들이 이미지와 필터입니다.

90
00:06:39,760 --> 00:06:43,390
정말 다양한 차원의 매트릭스죠.

91
00:06:44,640 --> 00:06:49,779
하지만, 왼쪽에 있는 매트릭스는 하나의 이미지처럼 해석하기가 편리합니다.

92
00:06:49,779 --> 00:06:52,564
가운데 있는 것은 필터처럼 해석하고, 오른쪽 것은

93
00:06:52,564 --> 00:06:57,021
아마 또 다른 이미지로 풀이해 볼 수 있을 겁니다.

94
00:06:57,021 --> 00:07:00,830
그리고 이건 vertical edge detector(수직선 감지기)라는 게 분명해 보이는데요

95
00:07:00,830 --> 00:07:03,440
다음 슬라이드에서는 왜,

96
00:07:03,440 --> 00:07:06,097
계속하기 전에 하나 덧붙이자면

97
00:07:06,097 --> 00:07:10,476
이걸 여러분이 프로그래밍 언어로 실행해보면, 실제로는

98
00:07:10,476 --> 00:07:13,840
대부분의 외국어들이 컨볼루션을 표현할 때 별표 보다는 몇 가지의

99
00:07:13,840 --> 00:07:16,800
다른 함수를 사용하고 있다는 것을 알게 될 것입니다.

100
00:07:16,800 --> 00:07:20,010
예를 들어, 이전 예제 연습들에서,

101
00:07:20,010 --> 00:07:24,040
Conv-forward라는 함수를 사용하거나 실행시켰었습니다.

102
00:07:24,040 --> 00:07:28,481
만약 tens of flow로 실행하게 되면,

103
00:07:28,481 --> 00:07:34,528
tf.nn.cont2d라는 함수가 있습니다.

104
00:07:34,528 --> 00:07:37,000
그리고 또 다른 딥러닝 프로그래밍

105
00:07:37,000 --> 00:07:41,538
체계로 Keras 프로그램 펌웨어, 이건이 과정 뒤 부분에서 같이 보게 될 텐데요.

106
00:07:41,538 --> 00:07:46,090
컨볼루션을 수행하는 cont2d라는 함수가 있습니다.

107
00:07:46,090 --> 00:07:49,559
하지만 컴퓨터 비전을 잘 지원하는 모든 딥러닝 체계들은

108
00:07:49,559 --> 00:07:54,218
이 convolution operator를 실행하기 위해 몇 가지 함수를 사용하게 됩니다.

109
00:07:56,813 --> 00:07:59,756
그럼, 왜 vertical edge detection를 수행하는 것일까요?

110
00:07:59,756 --> 00:08:01,700
다른 예제를 보시죠.

111
00:08:03,470 --> 00:08:06,188
이를 설명하기 위해, 단순화시킨 이미지를 사용해 보겠습니다.

112
00:08:06,188 --> 00:08:08,819
여기 단순한 6x6 이미지가 있습니다.

113
00:08:08,819 --> 00:08:14,480
이미지의 왼쪽 절반은 10이고, 오른쪽 절반은 0 입니다.

114
00:08:14,480 --> 00:08:18,734
이것을 그림으로 생각해본다면, 이렇게 보일 겁니다. 10이 있는 왼쪽 절반은

115
00:08:18,734 --> 00:08:21,775
더 밝은 픽셀 집약 값을 가지고 있고

116
00:08:21,775 --> 00:08:25,060
오른쪽 절반은 더 어두운 픽셀 집약 값을 가지고 있습니다

117
00:08:25,060 --> 00:08:27,890
저는 0을 표현하기 위해서 회색 쉐이드를 사용하고 있습니다

118
00:08:27,890 --> 00:08:32,110
검정색으로 보여지긴 하지만 말이죠.

119
00:08:32,110 --> 00:08:37,654
하지만 이 이미지에서, 가운데에 바로 매우 강한 vertical edge가 있습니다.

120
00:08:37,654 --> 00:08:42,590
흰색에서 검정 혹은 흰색에서 더 어두운 색으로 전환되기 때문이죠.

121
00:08:44,070 --> 00:08:48,808
3x3필터를 사용해서 컨볼브하고

122
00:08:48,808 --> 00:08:53,048
그 결과 3x3 필터가 시각화될 때에는 다음과 같이 됩니다.

123
00:08:53,048 --> 00:08:57,575
왼쪽에 더 밝은 픽셀이 있고

124
00:08:57,575 --> 00:09:02,080
중간 톤의 0이 가운데에 있고, 오른쪽에는 더 어두운 픽셀이 있게 됩니다.

125
00:09:02,080 --> 00:09:05,290
오른쪽과 같은 매트릭스를 얻게 되는 것이죠.

126
00:09:06,640 --> 00:09:10,130
이 연산과정을 확인해보자면,

127
00:09:10,130 --> 00:09:15,815
예를 들어 이 0은 element wise product를 수행하여 얻게 되는 숫자이고,

128
00:09:15,815 --> 00:09:18,880
3x3블록을 가지고 곱셈을 진행하면 됩니다.

129
00:09:18,880 --> 00:09:23,008
그렇게 하여 왼쪽 세로 열 10 + 10 + 10,

130
00:09:23,008 --> 00:09:26,987
그리고 가운데 있는 0 들, 그리고 -10, -10, -10 을

131
00:09:26,987 --> 00:09:30,670
더해서 바로 여기에 있는 0을 결국 얻게 되는 것입니다.

132
00:09:30,670 --> 00:09:35,490
반면 그 반대로, 30이 얻어지는 것은,

133
00:09:36,860 --> 00:09:41,062
10+10+10 -0

134
00:09:41,062 --> 00:09:47,190
-0 으로부터 바로 저기에 있는 30 이 생기게 되는 것이죠.

135
00:09:47,190 --> 00:09:51,490
자, 이 오른쪽 매트릭스의 이미지를 생각해보면

136
00:09:51,490 --> 00:09:55,240
바로 이 가운데에는 이렇게 연한 영역처럼 보일 것입니다.

137
00:09:55,240 --> 00:09:59,820
그리고 이는 6x6 이미지의 중간에 이 vertical edge를 감지한 것과 같습니다.

138
00:09:59,820 --> 00:10:03,630
리고 이는 6x6 이미지의 중간에 이 vertical edge를 감지한 것과 같습니다.

139
00:10:03,630 --> 00:10:06,920
감지된 테두리가 약간 두껍게 보여

140
00:10:06,920 --> 00:10:09,450
이 dimension이 잘못되었다 싶어 보일 수 있는데요,

141
00:10:09,450 --> 00:10:13,840
이는 그냥 이 매우 작은 이미지의 예시로 작업을 하고 있기 때문으로 보면 됩니다.

142
00:10:13,840 --> 00:10:17,100
만약 6x6 이미지가 아니라 1000x1000 이미지 같은 것을 사용하고 있다면,

143
00:10:17,100 --> 00:10:22,190
이미지 속 수직 가장자리들이 잘 감지되며

144
00:10:22,190 --> 00:10:27,390
이 과정이 잘 진행되는 것을 볼 수 있을 것입니다.

145
00:10:27,390 --> 00:10:28,510
이 예시에서,

146
00:10:28,510 --> 00:10:34,225
가운데에 있는 밝은 영역이 바로 아웃풋 이미지인데요, 마치 이미지 중간에

147
00:10:34,225 --> 00:10:39,355
강한 수직 가장자리가 있는 것처럼 보입니다.

148
00:10:39,355 --> 00:10:44,280
이는 아마도 vertical edge detection으로부터 생각해볼 때,

149
00:10:44,280 --> 00:10:49,315
우리가 3x3필터를 사용하고 있기 때문에 vertical edge가 3x3 영역이라는 점입니다.

150
00:10:49,315 --> 00:10:52,706
여기엔 왼쪽에는 밝은 픽셀이 있고

151
00:10:52,706 --> 00:10:55,104
가운데는 그다지 신경 쓰지 않아도 됩니다,

152
00:10:55,104 --> 00:10:58,171
오른쪽에는 어두운 픽셀들이 있습니다.

153
00:10:58,171 --> 00:11:03,011
이 6x6 이미지 중간에는

154
00:11:03,011 --> 00:11:07,850
왼쪽엔 밝은 픽셀이, 그리고 오른쪽에는 어두운 픽셀이 있을 수 있습니다.

155
00:11:07,850 --> 00:11:12,120
따라서 이쪽에 수직 가장자리가 있다고 생각되는 것이죠.

156
00:11:12,120 --> 00:11:16,480
컨벌루션 연산은 이미지에 있는 수직 가장자리를 어떻게 찾을지

157
00:11:16,480 --> 00:11:20,200
구체화시키는 편리한 방법을 제공해줍니다.

158
00:11:20,200 --> 00:11:23,720
지금까지 어떻게 convolution operator가 작동하는지 살펴보았습니다.

159
00:11:23,720 --> 00:11:26,430
다음 강의에서는 컨볼루션 신경망의 기본적인 빌딩블록의 하나로서

160
00:11:26,430 --> 00:11:30,032
어떻게 사용할 수 있을지 알아보도록 하겠습니다.