ディープラーニング ネットワークを構築するために行う必要のある 基本の畳み込み処理に対する 1つの修正が パディングだ それが どのように機能するか 見よう 前のビデオで見たものは もし 6 x 6 画像を 3 x 3 フィルターで畳み込むと 4 x 4 出力 4 x 4 行列を得るというものだった なぜなら 3 x 3 フィルターで取り得る位置の数は 単に 4 x 4 の位置だけだ 3 x 3 フィルターを 6 x 6 行列に合わせれば そして この数式は 次のようだ n x n 画像を f x f フィルターに掛けるなら 出力次元は n - f + 1   x   n - f + 1 となる そして この例では 6 - 3 + 1 = 4 だから 4 x 4 の出力になったわけだ これには ２つの欠点がある
1つは 畳み込み処理を適用する度に 画像が縮んでいく 例えば 6 x 6 から 4 x 4 に落ちる 画像が本当に小さくなるまでに 数回しかこれを行えない もしくは 画像は 1 x 1 やそのあたりまで縮むかもしれない 多分 あなたは 画像を縮ませたくないだろう エッジ検出したり 他の特徴量を得る度にはね そう これが1つの欠点だ そして ２番目の欠点がこれだ 角 もしくは 端にあるピクセルに着目すると この小さなピクセルは出力に一度しか使われない なぜなら これは この3 x 3 領域に接しているから 一方 中にあるピクセル このピクセルは 多くの 3 x 3 領域がオーバーラップしている このように 角や端のピクセルは 出力に少ししか使われない つまり 画像の端に近い情報の多くを捨てていることになる そこで これら両方の問題を解決するのに 出力の縮小と もし 本当に深いニューラルネットワークを組んだなら ステップの度に 画像を縮ませたくない理由が分かるだろう
なぜなら もし 100層のディープネットを持ったとすると 層毎に 画像は縮み 100層後には 非常に小さな画像になってしまう これが 1つの問題 もう一つが 画像の端にある多くの情報を捨ててしまうこと それでは この２つの問題を解決するため 畳み込み処理の前にできることがある 画像をパディングすることができる このケースでは 画像に追加の縁を充てる この追加の縁は 端の周りに１ピクセルだ こうすることで 6 x 6 画像の代わりに 膨らませて 8 x 8 画像にした　そして 8 x 8 画像を 3 x 3 画像で畳み込んで これを得る 今度は 4 x 4 ではなく 6 x 6 画像だ このようにして 最初の入力サイズ 6 x 6 を保つことができた パディングでは 慣例で ０値を充てる また p がパディング量だとすると　 この場合は p = 1 だ 追加の１ピクセルの縁を外周全てにパディングするので 出力はこうなる n + 2p - f + 1   x   n + 2p - f + 1 よって これは 6 + 2 x 1 - 3 + 1  x  同じもので 6 + 2 - 3 + 1 = 6 だ これで 最初の画像のサイズを保った 6 x 6 となる そして このピクセルは 確かに これらの出力セル全てに 影響する これは有効で 画像の角や端からの情報を捨てずに それまで失っていたものが減る そして ここに示したが パディングした縁の太さは ちょうど１ピクセルだ もし望むのなら ２ピクセルの縁でパディングできる その場合 もう一つの縁をここに加える そして やろうと思えば もっと多くのピクセルでパディングできる ここに描いたように パディングは２で p = 2 どのくらいパディングするかという点では ２つの一般的な選択肢がある Valid畳み込み と Same畳み込みだ すごい名前ではないが Valid畳み込みとは 基本的には パディング無しを意味する この場合は n x n 画像を f x f フィルターで畳み込むので これは n - f + 1  x  n - f + 1 次元の出力を得る これは 前のビデオで見た例と同様で n x n 画像が
(訳注: n x n ではなく 6 x 6 と言いたかったと思われる) 3 x 3 フィルターで畳み込まれ 4 x 4 出力を得た もう一つの一般的なパディングは Save畳み込みと呼ばれ それは 出力サイズが 入力サイズと同じになることを意味する この式をよく見れば分かるように p ピクセルでパディングすると n は n + 2p と 残りは ええっと -f + 1 よって n x n 画像の外周に p ピクセルの縁をパディングすると 出力サイズの次元は n + 2p - f + 1 よって n + 2p - f + 1 を n と同じにすれば 出力サイズが入力サイズと同じになる これを解けば n は両側で打ち消し合う
そして p について解けば それは p = f - 1 割る 2 となる よって f が奇数なら パディングサイズを次のように決めることで 出力サイズを入力サイズと 同じにできる
だから 例えば 前のスライドのように フィルターが 3 x 3 だった場合 出力サイズを入力サイズと同じにするパディングは (3 - 1) / 2 で これは１だ もう一つ別の例を もし フィルターが 5 x 5 だったなら つまり f = 5 なら この等式に当てはめて ２のパディングが 出力サイズを入力サイズと同じにするために必要だと分かる
フィルターが 5 x 5 の場合は コンピュータ ビジョンの慣例では f は通常奇数である それは実際 殆ど常に奇数であり 偶数のフィルターは 滅多に見ないだろう コンピュータ ビジョンで使われるフィルターでは それには２つの理由が考えられる 1つは もし f が偶数だと 非対称のパディングが必要となる それで f が奇数でありさえすれば この種のSame畳み込みは 自然なパディングサイズを導き それは 外周に同じ次元数を持ち 左を多めに 右を少なめにパディングする等 そんな非対称にならない そして 2番目の理由は もし 奇数次元のフィルターを持てば 3 x 3 や 5 x 5 なら それは 中央の位置を持ち 時々 コンピュータ ビジョンでは 識別子を持ちたい場合があり ピクセルを持つのがいい 中央のピクセルをフィルターの位置を示すのに使うことができる もちろん これらのどれも f が常に奇数であることの大した理由にはならないかもしれない しかし コンピュータ ビジョン界では 3 x 3 フィルターはとても一般的だ それに 5 x 5, 7 x 7 そして 実は時々 我々も後で話すけど 1 x 1 フィルターも意味がある しかし 単に慣例で 単に奇数フィルターを使うことを薦める 多分 f に偶数を使いたいとしても いい性能を出すだろうけど もし 通常のコンピュータ ビジョンに倣うなら 私は単に奇数の f を使う
さぁ パディングした畳み込みがどのようなものが見てきた 畳み込み処理のパディングを指定するのに p の値を指定することができる もしくは 単に Valid畳み込みと言うこともできる それは p = 0 を意味する
また Same畳み込みということもできる それは 出力が入力と同じ次元になるように 必要なだけパディングすることを意味する パディングについては以上だ 次のビデオでは ストライドを変えた畳み込みを実装する方法について話しましょう