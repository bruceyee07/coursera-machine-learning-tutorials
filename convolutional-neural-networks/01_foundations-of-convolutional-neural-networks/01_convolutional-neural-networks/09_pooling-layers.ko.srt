1
00:00:00,000 --> 00:00:02,335
컨볼네트는 컨볼루션 레이어외에도

2
00:00:02,335 --> 00:00:07,130
표현되는 크기를 줄이고,

3
00:00:07,130 --> 00:00:08,510
계산 속도를 높이고

4
00:00:08,510 --> 00:00:12,020
조금 더 견고하게 감지하는 기능을 만들기 위해 pooling 레이어를 사용합니다.

5
00:00:12,020 --> 00:00:16,390
보시죠. pooling 의 예를 살펴본 다음,

6
00:00:16,390 --> 00:00:20,205
이렇게 하면 왜 좋은지에 대해 이야기하겠습니다.

7
00:00:20,205 --> 00:00:24,300
4 x 4 인풋이 있다고 가정해봅시다

8
00:00:24,300 --> 00:00:28,675
max pooling이라고 하는 pooling 유형을 적용하려고 합니다.

9
00:00:28,675 --> 00:00:30,320
이러한 특정한

10
00:00:30,320 --> 00:00:34,375
max pooing의 아웃풋은 2 x 2 아웃풋이 될 것입니다.

11
00:00:34,375 --> 00:00:37,270
이걸 하는 방법은 꽤 간단합니다.

12
00:00:37,270 --> 00:00:40,310
4 x 4 입력을 받아

13
00:00:40,310 --> 00:00:44,280
4 개의 다른 영역으로 나누십시오. 네 군데를 이렇게 색칠해보겠습니다.

14
00:00:44,280 --> 00:00:46,130
그리고 나서, 아웃풋에서

15
00:00:46,130 --> 00:00:47,480
이건 2 x 2 인데요,

16
00:00:47,480 --> 00:00:53,240
각각의 아웃풋은 대응하는 다시 색칠된 영역으로부터 최대 값이 됩니다.

17
00:00:53,240 --> 00:00:54,680
그래서 왼쪽 상단에,

18
00:00:54,680 --> 00:00:57,900
이 네 숫자의 최대 값은 9입니다.

19
00:00:57,900 --> 00:01:01,760
오른쪽 상단의 파란색 숫자의 최대 값은 2입니다

20
00:01:01,760 --> 00:01:04,273
왼쪽 아래, 가장 큰 숫자는 6이고,

21
00:01:04,273 --> 00:01:08,050
오른쪽 아래, 가장 큰 숫자는 3입니다.

22
00:01:08,050 --> 00:01:10,737
따라서 오른쪽의 각 숫자를 계산할 때

23
00:01:10,737 --> 00:01:13,400
이 2 x 2 영역에 대해 최대 값을 취했습니다.

24
00:01:13,400 --> 00:01:18,740
이는 마치 두 개의 필터사이즈를 적용하는 것과 같은 것입니다.

25
00:01:18,740 --> 00:01:25,290
2 x 2 영역을 취해서 스트라이드 2로  처리하고 있기 때문입니다.

26
00:01:25,290 --> 00:01:30,825
이것은 최대 pooling의 하이퍼 파라미터입니다

27
00:01:30,825 --> 00:01:36,540
왜냐하면 값이 9가 되는 2 x 2 영역의

28
00:01:36,540 --> 00:01:39,650
이 필터사이즈로 시작하기 때문이죠.

29
00:01:39,650 --> 00:01:45,580
그리고 나서, 이 영역을 위해 두 칸을 옮겨가면, 값은 2가 됩니다.

30
00:01:45,580 --> 00:01:46,880
다음 행으로 옮겨

31
00:01:46,880 --> 00:01:49,580
두 칸을 아래로 옮겨가면 값은 6이 됩니다.

32
00:01:49,580 --> 00:01:52,570
그리고 다시 오른쪽으로 2칸 옮기면 3을 얻을 수 있죠.

33
00:01:52,570 --> 00:01:54,620
정사각형이 2 x 2 이므로, f=2

34
00:01:54,620 --> 00:01:58,070
스트라이드 = 2 이므로

35
00:01:58,070 --> 00:02:00,210
s=2 입니다.

36
00:02:00,210 --> 00:02:09,526
그래서 최대 pooling이하는 일에 대해 생각해봅시다.

37
00:02:09,526 --> 00:02:15,050
이 4 x 4영역을 feature 세트로 간주해보면

38
00:02:15,050 --> 00:02:19,204
신경망의 레이어의 activation은

39
00:02:19,204 --> 00:02:20,490
큰 숫자가 될 것입니다.

40
00:02:20,490 --> 00:02:23,670
이는 특정한 feature가 감지된다는 것을 의미합니다.

41
00:02:23,670 --> 00:02:26,495
따라서 왼쪽 상단 사분 면에는 이 특별한 feature가 있습니다

42
00:02:26,495 --> 00:02:32,470
이는 수직 모서리거나, 고양이를 감지하려는 거면 고양이의 눈 아니면 수염이 될 수 있습니다.

43
00:02:32,470 --> 00:02:34,820
분명히 그 feature는 왼쪽 상단 사분 면에 존재합니다.

44
00:02:34,820 --> 00:02:40,055
이 feature 자리에 있는 이것은 cat eye 감지기가 아닙니다.

45
00:02:40,055 --> 00:02:43,975
이 feature 자리에 이것은 오른쪽 상단 사분 면에는 실제로 존재하지 않습니다.

46
00:02:43,975 --> 00:02:47,764
따라서 max operation이 하는 일은 어디에서나 feature가 많이 감지되도록 하는 것이고,

47
00:02:47,764 --> 00:02:53,504
이 사분면 중에 하나는 최대 pooling 아웃풋으로 그대로 남게 됩니다.

48
00:02:53,504 --> 00:02:56,265
따라서 max가하는 일은 말하자면,

49
00:02:56,265 --> 00:02:59,780
이 feature들이 이 필터 어디에서든 감지되면,

50
00:02:59,780 --> 00:03:01,348
최대 값을 잡아두는 것입니다.

51
00:03:01,348 --> 00:03:03,510
하지만 이 feature가 감지되지 않으면,

52
00:03:03,510 --> 00:03:07,690
아마도 이 feature는 오른쪽 상단 사분 면에 존재하지 않을 겁니다.

53
00:03:07,690 --> 00:03:11,090
그렇다면 그 숫자들의 최대 값은 여전히 아주 작습니다.

54
00:03:11,090 --> 00:03:15,252
어쩌면 이것이 바로 max pooling의 직관력입니다.

55
00:03:15,252 --> 00:03:16,535
하지만 사람들이 max pooling을

56
00:03:16,535 --> 00:03:19,550
사용하는 주요 이유는

57
00:03:19,550 --> 00:03:23,627
잘 작동하는 많은 실험에서 발견되기 때문이라는 점은 인정해야 합니다.

58
00:03:23,627 --> 00:03:25,646
그리고 방금 설명했던 직관력 때문 일 수도 있습니다.

59
00:03:25,646 --> 00:03:27,375
종종 거론됨에도 불구하고

60
00:03:27,375 --> 00:03:33,020
이게 근본원인인지 아닌지 확실히 아는 사람은 본 적이 없습니다.

61
00:03:33,020 --> 00:03:34,655
max pooling이 컨볼네트에서 잘 작동되는 진짜 근본적인 이유를

62
00:03:34,655 --> 00:03:39,930
아는 사람은 없습니다.

63
00:03:39,930 --> 00:03:43,490
max pooling의 흥미로운 속성 중 하나는

64
00:03:43,490 --> 00:03:47,770
하이퍼 파라미터 집합은 가지고 있지만, 배울 파라미터는 없다는 것입니다.

65
00:03:47,770 --> 00:03:50,293
기울기 강하를 사실 배울 것은 없습니다.

66
00:03:50,293 --> 00:03:51,780
일단 f와 s를 고정시키면,

67
00:03:51,780 --> 00:03:56,876
그것은 이미 고정 된 계산이고, 기울기 강하는 아무 것도 변화시키지 않습니다.

68
00:03:56,876 --> 00:04:00,810
다른 하이퍼 파라미터로 예제를 살펴 보겠습니다.

69
00:04:00,810 --> 00:04:04,675
여기서는 5 x 5 인풋을 사용하고

70
00:04:04,675 --> 00:04:10,290
필터 크기가 3 x 3 인 최대 pooling을 적용 할 것입니다

71
00:04:10,290 --> 00:04:13,815
그래서 f=3 이고, 스트라이드=1 을 사용합시다

72
00:04:13,815 --> 00:04:18,190
이 경우에 아웃풋 크기는 3 x 3이 될 것입니다.

73
00:04:18,190 --> 00:04:20,570
컨볼 레이어의 아웃풋 사이즈를 파악하기 위해

74
00:04:20,570 --> 00:04:23,945
이전 동영상에서 발전시켰던 수식은

75
00:04:23,945 --> 00:04:27,345
최대 pooling에서도 작동합니다.

76
00:04:27,345 --> 00:04:34,345
그 수식은 n + 2p - f 나누기 s 를 하고 여기에 1을 더하는 것입니다

77
00:04:34,345 --> 00:04:38,458
이 수식은 또한 max pooling의 아웃풋 사이 지를 파악하는 데에도 사용할 수 있습니다.

78
00:04:38,458 --> 00:04:41,820
그러나 이 예제에서, 이 3 x 3 아웃풋의 각 원소를 계산해 봅시다.

79
00:04:41,820 --> 00:04:45,080
왼쪽 상단 요소, 80

80
00:04:45,080 --> 00:04:46,670
우리는 그 영역을 살펴볼 것입니다.

81
00:04:46,670 --> 00:04:48,735
필터 크기가 3이고 최대 값이기 때문에

82
00:04:48,735 --> 00:04:51,695
3 x 3 영역이라는 걸 기억하세요.

83
00:04:51,695 --> 00:04:53,715
그럼, 이것은 9가 되겠죠.

84
00:04:53,715 --> 00:04:57,920
그리고 나서 스트라이드=1 이니까 한 칸 옮기십시오,

85
00:04:57,920 --> 00:05:00,960
그러면 파란 상자의 최대값은 9가 됩니다.

86
00:05:00,960 --> 00:05:03,695
한 번 더 옮깁시다.

87
00:05:03,695 --> 00:05:06,235
파란 상자의 최대 값은 5입니다.

88
00:05:06,235 --> 00:05:09,710
그리고 다음 행으로 넘어 가서, 스트라이드=1

89
00:05:09,710 --> 00:05:12,465
이렇게 한 칸씩 아래로 내려가면 됩니다.

90
00:05:12,465 --> 00:05:16,520
이 영역의 최대 값은 9입니다, 이 영역의 최대 값은 9입니다

91
00:05:16,520 --> 00:05:19,970
이 영역의 최대값은,

92
00:05:19,970 --> 00:05:22,516
5가 두 개가 있군요, 최대값 5가 있습니다.

93
00:05:22,516 --> 00:05:26,130
마지막으로, 여기서 최대값은 8 입니다.

94
00:05:26,130 --> 00:05:28,965
여기서 최대값은 6이고,

95
00:05:28,965 --> 00:05:31,350
여기서 최대값은 9입니다.

96
00:05:31,350 --> 00:05:35,810
좋아요, 그래서, 이 하이퍼 파라미터 집합 f=3 인 경우

97
00:05:35,810 --> 00:05:40,007
여기 보이는 아웃풋대로 s=1입니다.

98
00:05:40,007 --> 00:05:44,975
이제까지는 2D 인풋상의 최대 pooling을 보여드렸습니다.

99
00:05:44,975 --> 00:05:47,370
3D 인풋이 있으면

100
00:05:47,370 --> 00:05:53,245
아웃풋 또한 동일한 차수를 가지게 될 것입니다.

101
00:05:53,245 --> 00:05:56,765
예를 들어, 5 x 5 x 2 이미지를 가지고 있고 ,

102
00:05:56,765 --> 00:06:02,360
아웃풋이 3 x 3 x 2 이면,

103
00:06:02,360 --> 00:06:05,045
최대 pooling을 계산하는 방법은

104
00:06:05,045 --> 00:06:08,368
방금 설명한 계산을 각 채널에서 독립적으로 수행하는 것입니다.

105
00:06:08,368 --> 00:06:11,960
따라서 위에 표시된 첫 번째 채널은 여전히 동일합니다.

106
00:06:11,960 --> 00:06:13,790
두 번째 채널의 경우,

107
00:06:13,790 --> 00:06:15,790
방금 그 아래에 그린 이것은

108
00:06:15,790 --> 00:06:19,250
이 슬라이스에 있는 값들에 대해서도 동일한 계산을 하면 됩니다.

109
00:06:19,250 --> 00:06:24,365
그러면 이 두 번째 슬라이스를 완성할 수 있습니다.

110
00:06:24,365 --> 00:06:29,300
그리고 좀 더 일반적으로, 만약 이것이 5 x 5 x 채널 개수 라면

111
00:06:29,300 --> 00:06:34,395
아웃풋은 3 x 3 x 동일한 채널 수 가 될 것입니다.

112
00:06:34,395 --> 00:06:44,541
max pooling computation은 이 각각의 nC 채널상에서 독립적으로 행해집니다.

113
00:06:44,541 --> 00:06:46,520
자, 이게 max pooling입니다.

114
00:06:46,520 --> 00:06:49,815
이것은 자주 사용되지 않는 유형의 pooling이긴 하나,

115
00:06:49,815 --> 00:06:52,870
평균 pooling이라는 것에 대해 간단히 언급 할 것입니다.

116
00:06:52,870 --> 00:06:56,395
따라서 이것은 여러분이 많이 기대하는 부분일 텐데요,

117
00:06:56,395 --> 00:06:59,080
각 필터 내에서 최대 값을 취하는 대신

118
00:06:59,080 --> 00:07:02,040
평균값을 취하는 것입니다.

119
00:07:02,040 --> 00:07:03,250
따라서 이 예에서

120
00:07:03,250 --> 00:07:07,540
보라색 숫자의 평균은 3.75이고,

121
00:07:07,540 --> 00:07:09,940
그 다음에는 1.25가 있죠.

122
00:07:09,940 --> 00:07:12,930
그리고 4와 2가 있습니다

123
00:07:12,930 --> 00:07:17,020
그래서 이것은 하이퍼 파라미터 f=2,

124
00:07:17,020 --> 00:07:21,795
s=2 인 평균 pooling입니다. 다른 하이퍼 파라미터를 선택해도 괜찮습니다.

125
00:07:21,795 --> 00:07:24,640
그래서 요즘에는 최대 pooling이 평균 pooling보다 훨씬 더 자주 사용되는데,

126
00:07:24,640 --> 00:07:28,340
때때로 신경망에 깊이 들어가면

127
00:07:28,340 --> 00:07:32,125
예외적 인 경우도 있습니다.

128
00:07:32,125 --> 00:07:36,670
평균 pooling을 사용하여 표현을

129
00:07:36,670 --> 00:07:40,290
7 x 7 x 1000 로 축소 할 수 있습니다.

130
00:07:40,290 --> 00:07:42,755
모든 공간에 있는 것을 평균을 내면

131
00:07:42,755 --> 00:07:45,625
1 x 1 x 1000이 됩니다.

132
00:07:45,625 --> 00:07:47,475
이 예시를 나중에 보도록 하겠습니다.

133
00:07:47,475 --> 00:07:54,085
하지만 보시다시피, max pooling은 average pooling 보다 신경망에서 훨씬 더 많이 사용됩니다

134
00:07:54,085 --> 00:07:56,305
요약해보자면,

135
00:07:56,305 --> 00:08:00,100
pooling에 대한 하이퍼 파라미터는

136
00:08:00,100 --> 00:08:02,840
필터 크기는 f, 스트라이드는 s,

137
00:08:02,840 --> 00:08:07,360
아마도 파라미터의 일반적인 선택은 f=2, s=2 가 되겠죠

138
00:08:07,360 --> 00:08:11,045
이것은 아주 자주 사용되고 2배 이상으로 높이와 넓이를

139
00:08:11,045 --> 00:08:15,925
대략적으로 줄이는 효과를 가지고 있습니다.

140
00:08:15,925 --> 00:08:21,150
자주 선택되는 하이퍼 파라미터는 f=2, s=2이고

141
00:08:21,150 --> 00:08:23,530
이것 역시 표현되는 높이와 넓이를

142
00:08:23,530 --> 00:08:28,440
2배 이상으로 줄여주는 효과를 가지고 있습니다.

143
00:08:28,440 --> 00:08:32,094
f=3, s=2 가 사용되는 것도 보셨습니다.

144
00:08:32,094 --> 00:08:37,150
또 다른 하이퍼 파라미터는 약간 이진법 같은 것인데요,

145
00:08:37,150 --> 00:08:40,120
최대 pooling을 사용하거나 평균 pooling을 사용하는 것입니다.

146
00:08:40,120 --> 00:08:43,380
원하시면, 패딩하면서 또 하나의 하이퍼 파라미터를 추가하실 수 있습니다

147
00:08:43,380 --> 00:08:48,140
아주 아주 뜸하게 사용되긴 하지만 말이죠.

148
00:08:48,140 --> 00:08:50,080
보통 최대 pooling 하실 때,

149
00:08:50,080 --> 00:08:51,685
패딩은 사용하지 않습니다.

150
00:08:51,685 --> 00:08:55,025
한 가지 예외 경우는 다음 주에 살펴보도록 하겠습니다.

151
00:08:55,025 --> 00:08:57,160
그러나 max pooling의 대부분은

152
00:08:57,160 --> 00:08:59,710
대개 어떤 패딩도 사용하지 않습니다.

153
00:08:59,710 --> 00:09:05,345
따라서 p의 가장 일반적인 값은 p=0 입니다.

154
00:09:05,345 --> 00:09:13,215
그리고 최대 pooling의 인풋은

155
00:09:13,215 --> 00:09:14,945
nC x nH x nH 크기의 볼륨을 입력하는 것입니다.

156
00:09:14,945 --> 00:09:21,265
그러면 이렇게 주어진 크기의 볼륨으로 결과물이 나오겠죠.

157
00:09:21,265 --> 00:09:29,465
그래서 패딩이 없다고 가정하고, 거기에 x nW-f / s 를 합니다.

158
00:09:29,465 --> 00:09:32,015
그리고 x nC 하면 되겠죠.

159
00:09:32,015 --> 00:09:35,295
따라서 인풋 채널의 수는 아웃풋 채널 수와 동일합니다.

160
00:09:35,295 --> 00:09:40,555
왜냐하면 pooling은 각 채널에 독립적으로 적용되기 때문입니다.

161
00:09:40,555 --> 00:09:47,205
pooling에 대해 주의해야 할 점은 배울 파라미터가 없다는 것입니다.

162
00:09:47,205 --> 00:09:50,470
그래서 우리가 잘라내기를 실행할 때,

163
00:09:50,470 --> 00:09:55,645
배경이 최대 pooling을 통해 조정 되 야할 파라미터가 없다는 걸 알게 되죠.

164
00:09:55,645 --> 00:09:58,400
대신에, 여러분이 일단 설정한 이러한 하이퍼 파라미터 변수가 있습니다.

165
00:09:58,400 --> 00:10:01,485
수동으로 혹은 교차 검증을 이용해서 설정된 것이겠죠.

166
00:10:01,485 --> 00:10:03,710
그렇게 하고 나면, 끝난 것입니다.

167
00:10:03,710 --> 00:10:07,140
이것이 신경망에 레이어 에서 계산을 수행하는 정해 된 함수입니다.

168
00:10:07,140 --> 00:10:09,829
사실 배울 것도 없죠.

169
00:10:09,829 --> 00:10:11,999
이건 그냥 정해진 함수니까요.

170
00:10:11,999 --> 00:10:13,350
이게 바로 pooling입니다.

171
00:10:13,350 --> 00:10:15,460
이제 여러분은 컨볼루션 레이어와 pooling 레이어를 만드는 방법을 알게 되었습니다.

172
00:10:15,460 --> 00:10:18,095
다음 비디오에서는

173
00:10:18,095 --> 00:10:20,830
컨볼네트보다 복잡한 예를 살펴 보겠습니다.

174
00:10:20,830 --> 00:10:25,000
이것이 완전히 연결된 레이어를 소개해 줄 것입니다.