1
00:00:02,026 --> 00:00:06,778
您已經看到了卷積運算
如何讓您建置一個

2
00:00:06,778 --> 00:00:07,800
垂直邊緣偵測

3
00:00:07,800 --> 00:00:12,285
在這段影片中，您將會學到
正的跟負的邊緣的不同

4
00:00:12,285 --> 00:00:16,432
也就是介於從亮到暗跟從暗到亮的不同邊緣轉換

5
00:00:16,432 --> 00:00:19,384
而您也會見到不同型態的邊緣偵測

6
00:00:19,384 --> 00:00:21,731
跟如何讓一個演算法學習

7
00:00:21,731 --> 00:00:26,500
而不是像目前我們用手工程式來做邊緣偵測

8
00:00:26,500 --> 00:00:28,456
我們開始吧

9
00:00:31,612 --> 00:00:36,050
這是我們之前的影片看過的例子，您有這個影像

10
00:00:36,050 --> 00:00:39,377
6乘6，左邊是亮的
右邊是暗的

11
00:00:39,377 --> 00:00:43,752
而跟這個垂直邊緣偵測過濾器卷積後得到的

12
00:00:43,752 --> 00:00:46,390
偵測垂直邊緣在影像的正中間

13
00:00:47,710 --> 00:00:51,400
如果這個影像的色彩翻轉呢？

14
00:00:51,400 --> 00:00:55,108
也就是暗的在左邊，亮的在右邊

15
00:00:55,108 --> 00:00:59,930
所以現在 10 在影像的右半邊，而 0 在左邊

16
00:00:59,930 --> 00:01:03,240
如果您用相同的邊緣偵測過濾器卷積

17
00:01:03,240 --> 00:01:07,835
您會得到 -30，而不是 30 在正中間

18
00:01:07,835 --> 00:01:12,820
您可以畫這個圖像，或許像這樣

19
00:01:12,820 --> 00:01:15,566
因為轉換的色彩相反

20
00:01:15,566 --> 00:01:18,290
30 也會跟著相反

21
00:01:18,290 --> 00:01:21,160
而這 -30 

22
00:01:21,160 --> 00:01:26,790
顯示這是暗到亮
而不是從亮到暗

23
00:01:26,790 --> 00:01:30,689
而如果您不關心這兩者不同

24
00:01:30,689 --> 00:01:34,780
您可以用這個輸出矩陣的絕對值

25
00:01:34,780 --> 00:01:39,364
但這特定的過濾器會讓從亮到暗跟

26
00:01:39,364 --> 00:01:41,340
從暗到亮邊緣的值不同

27
00:01:42,500 --> 00:01:45,190
讓我再看一些邊緣偵測的例子

28
00:01:45,190 --> 00:01:49,640
這個我們用過的3乘3過濾器
讓您可以偵測垂直邊緣

29
00:01:49,640 --> 00:01:53,470
所以這或許不會讓您太驚奇，這個

30
00:01:53,470 --> 00:01:58,160
3乘3過濾器
可以讓您偵測水平邊緣

31
00:01:58,160 --> 00:02:02,450
提醒一下，一個垂直邊緣偵測個過濾器是一個

32
00:02:02,450 --> 00:02:06,130
3乘3 區域，這些像素相對的在左邊較亮，

33
00:02:06,130 --> 00:02:08,580
在右邊較暗

34
00:02:08,580 --> 00:02:13,080
同樣地，一個水平邊緣會是 3乘3 區域，而

35
00:02:13,080 --> 00:02:18,510
在上面的像素較亮，
下面一行較暗

36
00:02:18,510 --> 00:02:22,392
這裡有一個例子，是相對較複雜的例子

37
00:02:22,392 --> 00:02:27,967
您有 10 在左上角跟右下角

38
00:02:27,967 --> 00:02:32,559
所以如果您畫這個影像，這個影像會是

39
00:02:32,559 --> 00:02:37,379
在 0 的地方較暗，所以我會在暗的區域填顏色

40
00:02:37,379 --> 00:02:41,459
而在左上角跟右下角

41
00:02:41,459 --> 00:02:47,190
而如果您用這個跟水平邊緣偵測做卷積，您會得到這個

42
00:02:48,470 --> 00:02:51,462
所以拿一些例子來看

43
00:02:51,462 --> 00:02:55,774
這個 30 相當於這個 3乘3 區域

44
00:02:55,774 --> 00:03:01,407
的確有亮的像素在上面，暗的像素在下面

45
00:03:01,407 --> 00:03:04,110
類似在這裡

46
00:03:04,110 --> 00:03:08,391
所以這裡它發現了一個強的正邊緣

47
00:03:08,391 --> 00:03:12,309
而這個 -30 相當於這個區域

48
00:03:12,309 --> 00:03:16,987
實際上下面比較亮，上面比較暗

49
00:03:16,987 --> 00:03:21,210
所以會是一個負的邊緣
在這個例子

50
00:03:21,210 --> 00:03:26,124
再一次，這是一種手工做的例子，我們處理

51
00:03:26,124 --> 00:03:31,300
一個相對較小的影像，
這只是一個 6乘6 影像

52
00:03:31,300 --> 00:03:34,210
但這些中間的值，像是 -10

53
00:03:34,210 --> 00:03:39,150
只是反應一個事實，
過濾器在這裡抓住了

54
00:03:39,150 --> 00:03:44,020
部分在左邊的正邊緣
跟部分在右邊的負邊緣

55
00:03:44,020 --> 00:03:47,120
所以混合在一起給你一些中間值

56
00:03:47,120 --> 00:03:49,050
但如果這是一個很大的

57
00:03:49,050 --> 00:03:54,160
假設 1000 乘 1000 類似棋盤的影像

58
00:03:54,160 --> 00:03:58,176
那您不會看到這些 10 的過渡區域

59
00:03:58,176 --> 00:04:02,950
這些中間值將會相當小
相對於這樣大的影像

60
00:04:02,950 --> 00:04:10,220
所以總結一下，不同的過濾器
會讓您找出垂直跟水平的邊緣

61
00:04:10,220 --> 00:04:15,320
實際上，這個 3乘3 
垂直邊緣偵測過濾器

62
00:04:15,320 --> 00:04:17,870
我們使用到的，只是選項之一

63
00:04:17,870 --> 00:04:20,470
歷史上，在電腦視覺文獻中

64
00:04:20,470 --> 00:04:24,750
有相當多的爭議關於什麼是
最佳的使用數字組

65
00:04:24,750 --> 00:04:29,513
這裡有另外一些您可以用，像是 1,2

66
00:04:29,513 --> 00:04:32,840
1, 0, 0, 0, -1, -2, -1

67
00:04:32,840 --> 00:04:35,670
這是稱為索貝爾過濾器

68
00:04:35,670 --> 00:04:40,981
而用這個的好處是，
它加入了多一些權重在中間行

69
00:04:40,981 --> 00:04:46,620
中間像素，這會讓它更健全

70
00:04:46,620 --> 00:04:50,711
但電腦視覺研究者也會使用其他組數字

71
00:04:50,711 --> 00:04:54,950
像是與其用 1,2,1，可能用 3,10,3，對吧

72
00:04:54,950 --> 00:04:59,330
然後 -3, -10, -3

73
00:04:59,330 --> 00:05:01,931
這是稱為夏爾過濾器

74
00:05:01,931 --> 00:05:06,752
這會有其他稍微不同的特性

75
00:05:06,752 --> 00:05:10,235
而這只是在垂直邊緣偵測上

76
00:05:10,235 --> 00:05:13,043
而如果您將它翻轉 90 度，
您會得到水平邊緣偵測

77
00:05:13,043 --> 00:05:18,350
隨著深度學習的興起，我們學習到的一件事是

78
00:05:18,350 --> 00:05:23,743
當您真的想要偵測邊緣在一些很複雜的影像時，或許您

79
00:05:23,743 --> 00:05:29,319
不需要用電腦視覺研究專家
手工選出的這 9 個數字

80
00:05:29,319 --> 00:05:33,855
或許您就用學習的方式，
將這矩陣的 9 個數字

81
00:05:33,855 --> 00:05:37,745
當作超參數，
您可以在反向傳播中學習

82
00:05:37,745 --> 00:05:42,095
而目標是學習這 9 個參數，
所以當您選擇影像時

83
00:05:42,095 --> 00:05:46,373
這個 6乘6 影像，跟您的 3乘3 過濾器卷積

84
00:05:46,373 --> 00:05:48,935
這會給您一個好的邊緣偵測器

85
00:05:50,030 --> 00:05:54,840
在以後的影片中您會見到，將這 9 個數字

86
00:05:54,840 --> 00:05:59,571
視為參數，反向傳播可以選擇學習 1,1,1,0,0,0

87
00:05:59,571 --> 00:06:04,680
-1,-1,-1, 或者用索貝爾過濾器，
或者用夏爾過濾器做學習

88
00:06:04,680 --> 00:06:08,364
或者更有可能用其他的，更好的來

89
00:06:08,364 --> 00:06:13,210
抓著您資料的統計數字，
比起這些手工打造的過濾器

90
00:06:13,210 --> 00:06:17,005
而不只垂直跟水平邊緣

91
00:06:17,005 --> 00:06:21,219
或許它可以學習偵測 45 度

92
00:06:21,219 --> 00:06:26,127
或者 70度 或者 73度，
或者任何它選擇的方向

93
00:06:26,127 --> 00:06:30,597
所以讓所有這些數字當參數，

94
00:06:30,597 --> 00:06:35,356
從資料中自動學習，
我們發現神經網路可以學習

95
00:06:35,356 --> 00:06:39,970
低階特徵，可以學習的特徵像是邊緣，甚至比

96
00:06:39,970 --> 00:06:45,467
電腦視覺研究員
用手工打造的這些數字更健全

97
00:06:45,467 --> 00:06:51,404
但底層這些計算還是卷積運算

98
00:06:51,404 --> 00:06:56,773
這樣可以讓反向傳播用
它想用的 3乘3 過濾器來做學習

99
00:06:56,773 --> 00:07:02,788
然後應用在整個影像上，在這個位置，這個位置

100
00:07:02,788 --> 00:07:08,266
這個位置，為了要輸出
它像要偵測的不管什麼特徵

101
00:07:08,266 --> 00:07:13,296
垂直邊緣，水平邊緣，或者其他角度

102
00:07:13,296 --> 00:07:18,260
甚至一些我們甚至沒有英文名字的過濾器

103
00:07:19,370 --> 00:07:22,945
您可以將這 9 個數字看成參數來

104
00:07:22,945 --> 00:07:26,890
學習已經是在電腦視覺中
最有力的想法之一

105
00:07:26,890 --> 00:07:31,654
晚一點在這個星期的課程中，我們會實際地談論

106
00:07:31,654 --> 00:07:36,034
您如何使用反向傳播來學習這 9 個數字的細節

107
00:07:36,034 --> 00:07:39,638
但首先，我們先來談一下其他的細節，其他的變形

108
00:07:39,638 --> 00:07:41,890
在基本的卷積運算中

109
00:07:41,890 --> 00:07:46,219
下兩個影片中，我想跟您討論在卷積時如何使用填充跟

110
00:07:46,219 --> 00:07:48,510
不同的跨步

111
00:07:48,510 --> 00:07:52,943
而這兩項會是很重要的

112
00:07:52,943 --> 00:07:55,130
卷積神經網路的基石

113
00:07:55,130 --> 00:07:56,420
讓我們進入下一段影片