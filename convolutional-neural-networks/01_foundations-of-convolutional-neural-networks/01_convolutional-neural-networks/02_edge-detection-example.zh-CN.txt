卷积运算是卷积神经网络的 基础组成单元之一 在这个视频中 我们用边缘检测<br />作为引发兴趣的例子 你将了解卷积运算是如何进行的 在之前的一节中 我已经讨论过神经网络的前几层<br />是怎样检测边缘的 并且后几层可能会<br />检测对象的某些部分 而更后的几层会检测<br />到某些整个的对象 比如在此例中的人脸 在本视频中你将看到<br />如何在一个图像中进行边缘检测 举个例子来看我们举个例子说明 给出一张这样的图片 让电脑算出<br />在这张图片中的物体是什么 你做的第一件事可能是<br />检测图片中的垂直边缘 例如在这个图像中<br />垂直的线是栅栏所在的地方 还有比较垂直的线<br />是这些行人的轮廓 所以在这个垂直边缘检测结果中<br />它们被检测出来了 你也许也想要检测水平边缘 比如说有一个非常明显的<br />水平线段在栅栏在的地方 它也被检测到 大概在这里 所以你怎样才能<br />在像这样的图像中检测边缘呢 我们来看个例子 这里是一个6x6的灰度图像 因为这是一个灰度图像<br />所以只是一个6x6x1的矩阵 而不是6x6x3<br />因为没有分开的RGB通道 为了检测边缘<br />比如这个图像中的垂直边缘 你能做的是建立一个3x3的矩阵 在池化(pooling)过程中<br />用卷积神经网络中的专业术语来说 这会被称为一个过滤器(filter) 我将要建立一个3x3的过滤器 或者说是3x3的矩阵<br />像这样 111 000 -1 -1 -1的 有时候科研论文中会将它<br />称为核(kernel)而不是过滤器 但是在这个视频中我将会用过滤器这个术语 你需要做的是获得6x6的图像<br />并求其卷积 卷积运算用这个星号代替 用这个3x3的过滤器去求它的卷积 稍微有点遗憾的是<br />这个符号在数学中 星号是卷积的标准符号 但是在Python中这被用来表示乘法 也许元素积乘法 所以这个星号有双重用法<br />这是个重复的符号 但是当星号表示卷积的时候<br />我会在这个视频中明确表示 这个卷积运算的输出是<br />一个4x4的矩阵 你可以将它理解为一个4x4的图像 下面是计算这个4x4输出的方法 计算第一个元素 也是就这个<br />4乘以4矩阵中左上角的这个元素 你要做的是用这个3X3的过滤器 把它粘贴到你的原始图像的<br />这块3x3区域上面 我在这里写了111 0 0 0 -1 -1 -1 你需要做的是计算元素积 所以第一个是3乘以1 然后第二个是1乘1<br />把它放到这里 1乘1 然后加上这个 2乘1 然后把九个结果全部加起来 所以中间的列得到<br />0乘0加5乘0加7乘0 然后最右边的列得到1乘-1 8乘-1加上2乘-1 把这九个数字相加你将得到-5 然后我把-5填在这里 对 你当然可以用<br />任何顺序把这九个数字相加 比如说我先计算第一列 然后第二列 然后第三列 接下来 为了计算出第二个元素 你要将蓝色的方形向右平移一步<br />像这样 让我把这里的绿色标记都去掉 你将要求同样的元素积然后相加 所以你有0乘1加上5乘1加7乘1 加1乘0加8乘0加2乘0 加2乘-1加9乘-1加5乘-1 如果你把这九个数加起来<br />你得到-4 以此类推 如果你把这个向右平移得到九个乘积<br />然后把它们相加得到0 然后在这里你应该得到8 只是验证一下 你有2加9加5 得到16 然后中间的列得到0 最右边的列 4加1加3乘-1 得到-8 然后就是在左边的列是16 -8 然后得8 和我们算好的一样 接下来 为了得到下一行的元素 你需要做的是把这个<br />蓝色的方形往下移一步 然后它现在在这个位置 然后再次重复元素积然后相加 如果你这么做了 你在这里得到-10 然后你把它向右移一步 应该得到-2 然后是2 然后是3等等 然后算出矩阵中的所有元素 再解释清楚一点 这个-16是 从右下端的3x3区域得到的 所以用3x3矩阵卷积6x6的矩阵<br />将得到一个4x4的矩阵 这些是图像和过滤器 这些都只是多维的矩阵 不过左边的矩阵可以<br />容易地理解为一个图像 中间这个我们把它理解为<br />一个过滤器 然后右边的这一个<br />也许可以理解为另一个图像 这就是一个垂直边缘检测器 你会在下一页知道为什么是这样的 在我们继续之前我有另一个提醒 那就是如果你将这运用到编程语言中<br />在实践中 大部分的编程语言<br />都会有一些不同的方法 而不用一个星号去标记卷积 比如说在编程练习中 你会实现一个conv_forward函数 如果你用TensorFlow做 有一个函数tf.nn.conv2d 而在其他的深度学习编程框架中 比如Keras 后面会学到 有一个函数Conv2D来实现卷积运算 但是所有支持卷积的深度学习框架 都会有一些函数实现这个卷积运算 为什么这是在进行垂直边缘检测呢 让我们看看另一个例子。 为了更好的解释<br />我们用一个简化了的图像 这有一个简单的6x6的图像 这个图像的左半边是10 右半边是0 如果你以图片形式得到它<br />它将是这个样子的 左半边的10<br />得到更亮的像素强度值 右半边得到比较暗的像素强度值 我们用灰色来表示0 虽然可能也能画成黑色 但是在这个图像的正中间<br />很清晰地有一个明显的垂直边缘 是从白到黑或者说<br />从白到暗色的过度 所以当你用这个3x3的过滤器<br />做卷积运算 这个3x3的过滤器<br />可以被可视化成这样 更明亮的像素点在左边 然后有中间调的颜色在中间<br />然后更暗的在右边 你得到的是在右边的这个矩阵 如果你想 可以验证这个数学运算 比如说这个0 是取元素积 然后与这个3x3的块相乘得到的 然后从最左列你得到10加10加10 然后中间是0 然后-10 -10 -10 这就是为什么你最后在这里得到0 与之不同 30是从这里得到的 从10加10加10得到的 然后-0 -0 这是为什么<br />你最后在那里得到30 如果你把最右边的矩阵画成图像<br />它将会是这样 更亮的区域在正中间 这与检测出的垂直边缘相对应 在这个6x6的图像的中间 这里的维数看起来不太对 检测出来的边缘看起来很厚 那只是因为我们在这个例子中<br />用了一个很小的图像 如果你用一个1000x1000的图像 而不是一个6x6的图像 你会发现 它能很好得检测出<br />在你图像中的垂直边缘 在这个例子中 这个在中间的明亮区域<br />只是用输出图像的方式 来表示有一个强垂直边缘<br />正好在图像的中间 垂直边缘检测里也许能<br />得到一个直观的理解 一个垂直边缘是一个3x3的区域<br />因为我们用的是3x3的过滤器 左边有亮像素 你并不在意中间有什么 然后在右边是暗像素 在这个6x6的图像的中间 可能会有亮像素在左边<br />暗像素在右边 这就是为什么它认为<br />那里有一个垂直边缘 卷积运算提供了一个<br />方便的方法去弄清楚 如何在图像中找到这些垂直边缘 所以现在你知道卷积运算<br />是怎么发挥作用的 在下一个视频中 你会看到如何运用它 作为卷积神经网络中的<br />一个基本构成