1
00:00:00,630 --> 00:00:04,090
Strided 컨볼루션는 컨볼루션 신경망에서 사용되는

2
00:00:04,090 --> 00:00:09,550
컨볼루션의 기본적인 빌딩블록의 또 다른 하나입니다.

3
00:00:09,550 --> 00:00:11,156
예시를 들어보죠.

4
00:00:11,156 --> 00:00:16,709
이 7x7 이미지를 3x3필터와 컨벌브한다고 생각해봅시다,

5
00:00:16,709 --> 00:00:19,290
일반적인 대신에

6
00:00:19,290 --> 00:00:23,795
2 스트라이드으로 처리 할 것입니다.

7
00:00:23,795 --> 00:00:29,260
즉, 이 왼쪽 상단 3x3 영역에 있는 Element-wise product (요소 간의 곱셈)을 평소대로 진행하고

8
00:00:29,260 --> 00:00:35,725
곱하고 더하면 91이 됩니다.

9
00:00:35,725 --> 00:00:39,010
파란색 상자를 한 칸 씩 이동하는 대신

10
00:00:39,010 --> 00:00:41,545
2칸을 옆으로 이동합니다.

11
00:00:41,545 --> 00:00:45,996
우리는 이렇게 두 걸음씩 점프해보겠습니다.

12
00:00:45,996 --> 00:00:51,130
왼쪽 상단 코너가 여기서 시작해서 여기 시작 부로 어떻게 이동했는지 유의하십시오.

13
00:00:51,130 --> 00:00:52,825
한 칸을 뛰어 넘는 거죠.

14
00:00:52,825 --> 00:00:59,290
그리고 나서, 일반적인 방법대로 요소 간 곱셈을 하고 합하면 100이됩니다.

15
00:00:59,290 --> 00:01:00,580
이제 우리는 그걸 다시 할 것인데요,

16
00:01:00,580 --> 00:01:04,390
파란색 상자를 두 칸 건너 뛰세요

17
00:01:04,390 --> 00:01:08,105
여기에 오게 되고, 83이 됩니다.

18
00:01:08,105 --> 00:01:11,125
다음 행으로 가서,

19
00:01:11,125 --> 00:01:13,810
다시 한 칸이 아니라 두 칸을 이동하고,

20
00:01:13,810 --> 00:01:17,870
그럼 파란색 상자가 이쪽으로 가게 되겠죠.

21
00:01:17,870 --> 00:01:24,953
우리가 어떻게 포지션 중 하나를 건너뛰고 있는지, 그리고 어떻게 하면 69 가 되는지 잘 보십시오.

22
00:01:24,953 --> 00:01:27,740
그리고 다시 두 칸을 건너뛰면,

23
00:01:27,740 --> 00:01:31,775
91이 되고 이런 식으로 127이 됩니다.

24
00:01:31,775 --> 00:01:38,250
그리고 마지막 행은 44, 72, 74.

25
00:01:38,250 --> 00:01:43,615
이 예에서 우리는 7x7 매트릭스를

26
00:01:43,615 --> 00:01:49,530
3x3매트릭스와 컨벌브해서 3x3 결과물을 얻게 됩니다.

27
00:01:49,530 --> 00:01:54,207
이 인풋과 아웃풋 크기는 다음 공식에 따라 산정됩니다.

28
00:01:54,207 --> 00:01:56,080
N×N 이미지가 있는 경우

29
00:01:56,080 --> 00:02:00,202
F와F 필터로 컨벌루션됩니다.

30
00:02:00,202 --> 00:02:09,835
그리고 패딩 P와 스트라이드 S를 사용하는 경우,

31
00:02:09,835 --> 00:02:17,633
이 예제에서 S=2 이고, N+2 P에서 F를 뺀 아웃풋이 나오게 되는 거죠.

32
00:02:17,633 --> 00:02:20,755
이제 S 단계를 거치므로,

33
00:02:20,755 --> 00:02:22,455
한 번에 한 칸 옮기고,

34
00:02:22,455 --> 00:02:29,423
S 로 나눈 다음 1을 더해주세요. 그런 다음 똑같은 방식을 적용하면 되겠습니다.

35
00:02:29,423 --> 00:02:37,165
예시에서, 7+0-3 가 되고,

36
00:02:37,165 --> 00:02:44,920
스트라이드 2로 나눈 다음 1을 더하면

37
00:02:44,920 --> 00:02:49,705
2분의 4+1, 즉 3이 됩니다.

38
00:02:49,705 --> 00:02:54,062
이런 방식으로 3x3 아웃풋으로 결론 낼 수 있는 겁니다.

39
00:02:54,062 --> 00:03:02,115
자, 마지막으로, 이 부분이 정수가 아니면 어떻게 될까요?

40
00:03:02,115 --> 00:03:04,405
이 경우 남는 숫자를 잘라버리고

41
00:03:04,405 --> 00:03:10,775
이 표기법이 floor를 표시하도록 해줍니다.

42
00:03:10,775 --> 00:03:14,395
이 표시는 Z의 floor라는 뜻이죠.

43
00:03:14,395 --> 00:03:18,075
이는 Z를 내림 해서 가장 가까운 정수로 만들라는 뜻입니다.

44
00:03:18,075 --> 00:03:21,640
이렇게 구현되는 방식은

45
00:03:21,640 --> 00:03:26,230
이미지 또는 패딩에 더해진 이미지 내에

46
00:03:26,230 --> 00:03:29,740
파란 상자가 완전히 포함되어 있는 경우에만 파란상자 곱셈을 취하는 것입니다.

47
00:03:29,740 --> 00:03:32,590
만약 이 파란색 상자 종류 중 일부가

48
00:03:32,590 --> 00:03:35,935
바깥쪽에 걸쳐있다면, 그 계산은 하지 마세요.

49
00:03:35,935 --> 00:03:41,080
생성 된 해당 출력이 있기 전에 3x3 필터가

50
00:03:41,080 --> 00:03:44,955
이미지 또는 이미지에 더해진 패딩 영역을

51
00:03:44,955 --> 00:03:47,110
완전히 포함해야 한다고 생각한다면,

52
00:03:47,110 --> 00:03:50,020
그것 또한 고정관념입니다.

53
00:03:50,020 --> 00:03:55,670
그러므로, 아웃풋 크기를 계산해내는 올바른 방법은

54
00:03:55,670 --> 00:04:01,990
N+2p-f를 S로 나누었을 때 정수가 아닌 경우 내림 하는 것입니다.

55
00:04:01,990 --> 00:04:04,205
dimension을 요약해보자면,

56
00:04:04,205 --> 00:04:07,780
NxN 매트릭스 혹은 NxN 이미지를

57
00:04:07,780 --> 00:04:12,620
패딩 P와 스트라이드 S와 컨벌브하면

58
00:04:12,620 --> 00:04:16,993
아웃풋 사이즈는 이러한 dimension을 가지게 될 겁니다.

59
00:04:16,993 --> 00:04:21,000
때로는 그럴 필요가 없기도 하지만, 여기 정수가 생기도록 여기 있는 모든 숫자들을 선택할 수 있다는 건 좋죠,

60
00:04:21,000 --> 00:04:27,660
내림 하는 것도 괜찮습니다.

61
00:04:27,660 --> 00:04:32,900
그러나 N, F, P 및 S 값의 몇 가지 예를 통해 편하게 작업하시고

62
00:04:32,900 --> 00:04:35,850
원하는 경우 이 수식이 출력 크기에 맞는지

63
00:04:35,850 --> 00:04:41,331
확인해보십시오.

64
00:04:41,331 --> 00:04:45,880
이제 계속 진행하기 전에

65
00:04:45,880 --> 00:04:49,480
cross-correlation (교차 상관)과 컨벌루션의 차이점에 대해 기술적인 의견을 덧붙이고 싶은데요,

66
00:04:49,480 --> 00:04:53,735
이는 컨볼루션 신경망을 실행할 때 영향을 미치게 됩니다.

67
00:04:53,735 --> 00:04:59,790
다른 수학 교과서나 신호 처리 교재를 읽어보면,

68
00:04:59,790 --> 00:05:05,690
표기법에 있어 생길 수 있는 불일치점이 하나 있습니다. 그게 뭐냐 하면,

69
00:05:05,690 --> 00:05:07,850
전형적인 수학 교과서를 보면,

70
00:05:07,850 --> 00:05:12,650
요소 간 곱셈과 덧셈을 하기 전에 컨벌루션 이 정의 되는 방식에 있어서,

71
00:05:12,650 --> 00:05:16,370
사실 먼저 수행해야 하는 한 단계가 더 있습니다.

72
00:05:16,370 --> 00:05:20,550
6 x6 행렬을 3x3 필터로 콘볼부하는 것입니다.

73
00:05:20,550 --> 00:05:24,980
우선, 3x3 필터를 취해

74
00:05:24,980 --> 00:05:30,280
가로, 세로축 모두 옆으로 돌려보면 3, 4, 5, 1, 0, 2, -1, 9, 7 가 될 겁니다.

75
00:05:30,280 --> 00:05:38,580
3은 여기로 하고, 4는 저쪽으로,

76
00:05:38,580 --> 00:05:43,070
5는 저쪽, 그리고 두 번째 행은

77
00:05:43,070 --> 00:05:49,660
1, 0, 2, -1, 9, 7이 됩니다.

78
00:05:49,660 --> 00:05:53,120
이것은 실제로 3x3개 필터를 취하여

79
00:05:53,120 --> 00:05:58,218
수직 축과 수평 축 둘 다로 좁힙니다

80
00:05:58,218 --> 00:06:04,225
그리고 나서, 옆으로 돌려진 이 매트릭스가 여기에 복사합니다

81
00:06:04,225 --> 00:06:06,175
아웃풋을 계산하려면,

82
00:06:06,175 --> 00:06:08,650
2x7

83
00:06:08,650 --> 00:06:10,045
3x2를 더하고

84
00:06:10,045 --> 00:06:15,275
7x5를 더하는 이런 방식으로 진행합니다.

85
00:06:15,275 --> 00:06:19,910
이 옆으로 돌린 행렬을 곱해서

86
00:06:19,910 --> 00:06:25,415
4x4 아웃풋의 왼쪽 상단 행의 원소들을 계산하면 됩니다.

87
00:06:25,415 --> 00:06:31,425
그런 다음 9 개의 숫자를 가져 와서

88
00:06:31,425 --> 00:06:35,916
한 칸 이동하고, 또 한 칸 이동시키세요.

89
00:06:35,916 --> 00:06:38,990
이 강의의 컨벌루션 연산을 다루는 방법은

90
00:06:38,990 --> 00:06:43,495
이 좁히는 작업을 건너뛰고 진행했습니다.

91
00:06:43,495 --> 00:06:45,930
기술적으로, 우리가 실제로 하고 있는 것,

92
00:06:45,930 --> 00:06:49,360
즉, 지난 강의에서 사용해온 작업은

93
00:06:49,360 --> 00:06:54,180
때로는 컨볼루션이 아닌 교차 상관 입니다

94
00:06:54,180 --> 00:06:57,645
그러나 관례에 따르는 딥러닝 문헌에서는

95
00:06:57,645 --> 00:07:01,760
우리는 이것을 컨벌루션 연산이라고 부릅니다

96
00:07:01,760 --> 00:07:06,215
간단히 요약하자면, 기계 학습의 관례에 따라,

97
00:07:06,215 --> 00:07:10,730
우리는 일반적으로 이 skipping operation을 신경 쓰지 않고,

98
00:07:10,730 --> 00:07:15,200
기술적으로는 이 작업을 교차 상관이라고 할 수도 있지만

99
00:07:15,200 --> 00:07:20,165
대부분의 딥러닝 문헌에서는 이것을 컨벌루션 연산라고 부릅니다.

100
00:07:20,165 --> 00:07:23,430
그래서 저는 이 강의에서도 이 관례대로 사용할 예정입니다.

101
00:07:23,430 --> 00:07:28,155
많은 기계 관련 문헌을 읽는다면

102
00:07:28,155 --> 00:07:30,320
대부분의 사람들이 이렇게 돌린 매트릭스를 사용하지 않고

103
00:07:30,320 --> 00:07:35,490
컨벌루션 연산로 부르는 것을 볼 수 있을 것입니다.

104
00:07:35,490 --> 00:07:40,120
신호 처리나 특정 수학 분야에서

105
00:07:40,120 --> 00:07:43,615
컨벌루션 연산가 컨볼루션 정의대로 을  뒤집기를 하면

106
00:07:43,615 --> 00:07:49,870
A*B 먼저 컨벌브하고

107
00:07:49,870 --> 00:07:53,320
C와 컨벌브하면

108
00:07:53,320 --> 00:07:58,505
A를 컨벌브 된 B와 C에 나중에 컨벌브하는 것과 같다는 것이 밝혀졌습니다.

109
00:07:58,505 --> 00:08:02,080
이것은 일부 신호 처리 애플리케이션에 적합하지만

110
00:08:02,080 --> 00:08:05,860
심층 신경망 의 경우에는 그다기 상관이 없기 때문에

111
00:08:05,860 --> 00:08:08,680
이 이중 mirroring operation을 생략해서

112
00:08:08,680 --> 00:08:14,450
코드를 단순화시키고, 신경망도 제대로 작동하게 할 수 있습니다.

113
00:08:14,450 --> 00:08:18,380
관례에 따라, 대부분 사람들은 이걸 컨벌루션이라고 부릅니다.

114
00:08:18,380 --> 00:08:24,240
수학자들이 때때로 이걸 교차 상관이라고 부르는 걸 선호긴 하지만,

115
00:08:24,240 --> 00:08:28,352
이것은 문제점 연습에서 실행하는 것에는

116
00:08:28,352 --> 00:08:31,860
영향을 미치지 않아야 하며

117
00:08:31,860 --> 00:08:38,222
딥러닝 문헌을 읽고 이해하는 데에 영향을 주어서는 안됩니다.

118
00:08:38,222 --> 00:08:41,600
지금까지 컨볼루션을 수행하는 방법과

119
00:08:41,600 --> 00:08:45,715
패딩과 컨볼루션 스트라이드를 사용하는 방법을 보셨습니다.

120
00:08:45,715 --> 00:08:49,795
하지만 지금까지 보신 것은

121
00:08:49,795 --> 00:08:51,545
6 x6보다 큰 매트릭스에 관한 컨벌루션이었습니다.

122
00:08:51,545 --> 00:08:55,670
다음 강좌에서는, 볼륨에 대해 컨볼루션을 수행하는 방법을 볼 수 있습니다.

123
00:08:55,670 --> 00:08:59,730
그러면 컨볼루션을 훨씬 더 강력한 것으로 만들 수 있습니다.

124
00:08:59,730 --> 00:09:01,580
다음 동영상으로 넘어 갑시다.