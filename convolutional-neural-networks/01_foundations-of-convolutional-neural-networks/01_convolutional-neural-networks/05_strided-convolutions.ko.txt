Strided 컨볼루션는 컨볼루션 신경망에서 사용되는 컨볼루션의 기본적인 빌딩블록의 또 다른 하나입니다. 예시를 들어보죠. 이 7x7 이미지를 3x3필터와 컨벌브한다고 생각해봅시다, 일반적인 대신에 2 스트라이드으로 처리 할 것입니다. 즉, 이 왼쪽 상단 3x3 영역에 있는 Element-wise product (요소 간의 곱셈)을 평소대로 진행하고 곱하고 더하면 91이 됩니다. 파란색 상자를 한 칸 씩 이동하는 대신 2칸을 옆으로 이동합니다. 우리는 이렇게 두 걸음씩 점프해보겠습니다. 왼쪽 상단 코너가 여기서 시작해서 여기 시작 부로 어떻게 이동했는지 유의하십시오. 한 칸을 뛰어 넘는 거죠. 그리고 나서, 일반적인 방법대로 요소 간 곱셈을 하고 합하면 100이됩니다. 이제 우리는 그걸 다시 할 것인데요, 파란색 상자를 두 칸 건너 뛰세요 여기에 오게 되고, 83이 됩니다. 다음 행으로 가서, 다시 한 칸이 아니라 두 칸을 이동하고, 그럼 파란색 상자가 이쪽으로 가게 되겠죠. 우리가 어떻게 포지션 중 하나를 건너뛰고 있는지, 그리고 어떻게 하면 69 가 되는지 잘 보십시오. 그리고 다시 두 칸을 건너뛰면, 91이 되고 이런 식으로 127이 됩니다. 그리고 마지막 행은 44, 72, 74. 이 예에서 우리는 7x7 매트릭스를 3x3매트릭스와 컨벌브해서 3x3 결과물을 얻게 됩니다. 이 인풋과 아웃풋 크기는 다음 공식에 따라 산정됩니다. N×N 이미지가 있는 경우 F와F 필터로 컨벌루션됩니다. 그리고 패딩 P와 스트라이드 S를 사용하는 경우, 이 예제에서 S=2 이고, N+2 P에서 F를 뺀 아웃풋이 나오게 되는 거죠. 이제 S 단계를 거치므로, 한 번에 한 칸 옮기고, S 로 나눈 다음 1을 더해주세요. 그런 다음 똑같은 방식을 적용하면 되겠습니다. 예시에서, 7+0-3 가 되고, 스트라이드 2로 나눈 다음 1을 더하면 2분의 4+1, 즉 3이 됩니다. 이런 방식으로 3x3 아웃풋으로 결론 낼 수 있는 겁니다. 자, 마지막으로, 이 부분이 정수가 아니면 어떻게 될까요? 이 경우 남는 숫자를 잘라버리고 이 표기법이 floor를 표시하도록 해줍니다. 이 표시는 Z의 floor라는 뜻이죠. 이는 Z를 내림 해서 가장 가까운 정수로 만들라는 뜻입니다. 이렇게 구현되는 방식은 이미지 또는 패딩에 더해진 이미지 내에 파란 상자가 완전히 포함되어 있는 경우에만 파란상자 곱셈을 취하는 것입니다. 만약 이 파란색 상자 종류 중 일부가 바깥쪽에 걸쳐있다면, 그 계산은 하지 마세요. 생성 된 해당 출력이 있기 전에 3x3 필터가 이미지 또는 이미지에 더해진 패딩 영역을 완전히 포함해야 한다고 생각한다면, 그것 또한 고정관념입니다. 그러므로, 아웃풋 크기를 계산해내는 올바른 방법은 N+2p-f를 S로 나누었을 때 정수가 아닌 경우 내림 하는 것입니다. dimension을 요약해보자면, NxN 매트릭스 혹은 NxN 이미지를 패딩 P와 스트라이드 S와 컨벌브하면 아웃풋 사이즈는 이러한 dimension을 가지게 될 겁니다. 때로는 그럴 필요가 없기도 하지만, 여기 정수가 생기도록 여기 있는 모든 숫자들을 선택할 수 있다는 건 좋죠, 내림 하는 것도 괜찮습니다. 그러나 N, F, P 및 S 값의 몇 가지 예를 통해 편하게 작업하시고 원하는 경우 이 수식이 출력 크기에 맞는지 확인해보십시오. 이제 계속 진행하기 전에 cross-correlation (교차 상관)과 컨벌루션의 차이점에 대해 기술적인 의견을 덧붙이고 싶은데요, 이는 컨볼루션 신경망을 실행할 때 영향을 미치게 됩니다. 다른 수학 교과서나 신호 처리 교재를 읽어보면, 표기법에 있어 생길 수 있는 불일치점이 하나 있습니다. 그게 뭐냐 하면, 전형적인 수학 교과서를 보면, 요소 간 곱셈과 덧셈을 하기 전에 컨벌루션 이 정의 되는 방식에 있어서, 사실 먼저 수행해야 하는 한 단계가 더 있습니다. 6 x6 행렬을 3x3 필터로 콘볼부하는 것입니다. 우선, 3x3 필터를 취해 가로, 세로축 모두 옆으로 돌려보면 3, 4, 5, 1, 0, 2, -1, 9, 7 가 될 겁니다. 3은 여기로 하고, 4는 저쪽으로, 5는 저쪽, 그리고 두 번째 행은 1, 0, 2, -1, 9, 7이 됩니다. 이것은 실제로 3x3개 필터를 취하여 수직 축과 수평 축 둘 다로 좁힙니다 그리고 나서, 옆으로 돌려진 이 매트릭스가 여기에 복사합니다 아웃풋을 계산하려면, 2x7 3x2를 더하고 7x5를 더하는 이런 방식으로 진행합니다. 이 옆으로 돌린 행렬을 곱해서 4x4 아웃풋의 왼쪽 상단 행의 원소들을 계산하면 됩니다. 그런 다음 9 개의 숫자를 가져 와서 한 칸 이동하고, 또 한 칸 이동시키세요. 이 강의의 컨벌루션 연산을 다루는 방법은 이 좁히는 작업을 건너뛰고 진행했습니다. 기술적으로, 우리가 실제로 하고 있는 것, 즉, 지난 강의에서 사용해온 작업은 때로는 컨볼루션이 아닌 교차 상관 입니다 그러나 관례에 따르는 딥러닝 문헌에서는 우리는 이것을 컨벌루션 연산이라고 부릅니다 간단히 요약하자면, 기계 학습의 관례에 따라, 우리는 일반적으로 이 skipping operation을 신경 쓰지 않고, 기술적으로는 이 작업을 교차 상관이라고 할 수도 있지만 대부분의 딥러닝 문헌에서는 이것을 컨벌루션 연산라고 부릅니다. 그래서 저는 이 강의에서도 이 관례대로 사용할 예정입니다. 많은 기계 관련 문헌을 읽는다면 대부분의 사람들이 이렇게 돌린 매트릭스를 사용하지 않고 컨벌루션 연산로 부르는 것을 볼 수 있을 것입니다. 신호 처리나 특정 수학 분야에서 컨벌루션 연산가 컨볼루션 정의대로 을  뒤집기를 하면 A*B 먼저 컨벌브하고 C와 컨벌브하면 A를 컨벌브 된 B와 C에 나중에 컨벌브하는 것과 같다는 것이 밝혀졌습니다. 이것은 일부 신호 처리 애플리케이션에 적합하지만 심층 신경망 의 경우에는 그다기 상관이 없기 때문에 이 이중 mirroring operation을 생략해서 코드를 단순화시키고, 신경망도 제대로 작동하게 할 수 있습니다. 관례에 따라, 대부분 사람들은 이걸 컨벌루션이라고 부릅니다. 수학자들이 때때로 이걸 교차 상관이라고 부르는 걸 선호긴 하지만, 이것은 문제점 연습에서 실행하는 것에는 영향을 미치지 않아야 하며 딥러닝 문헌을 읽고 이해하는 데에 영향을 주어서는 안됩니다. 지금까지 컨볼루션을 수행하는 방법과 패딩과 컨볼루션 스트라이드를 사용하는 방법을 보셨습니다. 하지만 지금까지 보신 것은 6 x6보다 큰 매트릭스에 관한 컨벌루션이었습니다. 다음 강좌에서는, 볼륨에 대해 컨볼루션을 수행하는 방법을 볼 수 있습니다. 그러면 컨볼루션을 훨씬 더 강력한 것으로 만들 수 있습니다. 다음 동영상으로 넘어 갑시다.