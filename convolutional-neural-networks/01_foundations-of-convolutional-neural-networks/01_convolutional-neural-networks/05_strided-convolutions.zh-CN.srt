1
00:00:00,630 --> 00:00:04,090
Strided(带步长的)卷积是在卷积神经网络中

2
00:00:04,090 --> 00:00:09,550
组成基础卷积模块的另一部分

3
00:00:09,550 --> 00:00:11,156
请看这个例子

4
00:00:11,156 --> 00:00:16,709
假设你想用3X3过滤器对这个7X7的图片进行卷积

5
00:00:16,709 --> 00:00:19,290
除了使用平常的方式

6
00:00:19,290 --> 00:00:23,795
我们这次用2为步长的方式进行卷积

7
00:00:23,795 --> 00:00:29,260
这意味着，在左上角3X3的区域进行元素间相乘是不变的

8
00:00:29,260 --> 00:00:35,725
之后把这些乘积相加得到91

9
00:00:35,725 --> 00:00:39,010
但是，这次不把蓝色区域移动一个步长

10
00:00:39,010 --> 00:00:41,545
而是将蓝色区域移动两个步长

11
00:00:41,545 --> 00:00:45,996
这样，我们移动两步到了新的位置

12
00:00:45,996 --> 00:00:51,130
注意到蓝色区域的左上角从这个位置到这个位置

13
00:00:51,130 --> 00:00:52,825
跳过了一个元素

14
00:00:52,825 --> 00:00:59,290
之后进行和平常一样，进行元素间相乘，并把结果相加得到100

15
00:00:59,290 --> 00:01:00,580
现在我们要重复进行刚才的操作

16
00:01:00,580 --> 00:01:04,390
确保蓝色区域跳过两个步长

17
00:01:04,390 --> 00:01:08,105
移到这里，得到83

18
00:01:08,105 --> 00:01:11,125
现在，我要将蓝色区域移到下一行

19
00:01:11,125 --> 00:01:13,810
再一次移动两个步长

20
00:01:13,810 --> 00:01:17,870
而不是移动一个步长。这样，蓝色区域被移到这里。

21
00:01:17,870 --> 00:01:24,953
注意我们是跳过了一个步长的。这样，这部分卷积值为69

22
00:01:24,953 --> 00:01:27,740
现在，再一次跳过两个步长

23
00:01:27,740 --> 00:01:31,775
这个结果为91，下一个为127

24
00:01:31,775 --> 00:01:38,250
最后一行的三个结果为44,72,74

25
00:01:38,250 --> 00:01:43,615
这样，我们用3X3的过滤器对7X7的矩阵进行卷积

26
00:01:43,615 --> 00:01:49,530
得到了一个3X3的输出

27
00:01:49,530 --> 00:01:54,207
输入和输出的维度间的关系可以用以下的方程进行表示

28
00:01:54,207 --> 00:01:56,080
如果你有一个NxN大小的图像

29
00:01:56,080 --> 00:02:00,202
用一个FxF大小的过滤器对这个图像进行卷积

30
00:02:00,202 --> 00:02:09,835
对图像使用p层填充，并假设步长为S。在这个例子中，

31
00:02:09,835 --> 00:02:17,633
S为2。此时，得到的结果的维度为N+2P-F

32
00:02:17,633 --> 00:02:20,755
由于每次要移动S步长

33
00:02:20,755 --> 00:02:22,455
而不是一步步进行

34
00:02:22,455 --> 00:02:29,423
所以要除以S，再加上1后得到这个公式。现在可以应用这个公式

35
00:02:29,423 --> 00:02:37,165
在我们的例子中，7+0-3

36
00:02:37,165 --> 00:02:44,920
得4，再除以2，再加上1，等于

37
00:02:44,920 --> 00:02:49,705
4除以2，得2，2+1等于3

38
00:02:49,705 --> 00:02:54,062
这就是为什么我们得到这个3X3的输出矩阵

39
00:02:54,062 --> 00:03:02,115
还有一个细节，如果这个分数中，分子不能被分母整除得到整数怎么办？

40
00:03:02,115 --> 00:03:04,405
这时，我们可以向下取整

41
00:03:04,405 --> 00:03:10,775
用这个标志表示对于某个值向下取整

42
00:03:10,775 --> 00:03:14,395
这又叫floor(z)

43
00:03:14,395 --> 00:03:18,075
它表示最接近z的小于z的整数

44
00:03:18,075 --> 00:03:21,640
之所以这样，是因为

45
00:03:21,640 --> 00:03:26,230
蓝色区域被像素或补充的元素填满时，得到的是正数

46
00:03:26,230 --> 00:03:29,740
如果蓝色区域

47
00:03:29,740 --> 00:03:32,590
部分没有被图像或图像加填充部分覆盖

48
00:03:32,590 --> 00:03:35,935
就这样落在外部的时候，我们不能进行计算

49
00:03:35,935 --> 00:03:41,080
这说明，3X3的过滤器

50
00:03:41,080 --> 00:03:44,955
必须全部落在原图像

51
00:03:44,955 --> 00:03:47,110
或原图像加上填充的范围之内

52
00:03:47,110 --> 00:03:50,020
就形成了这样的约定

53
00:03:50,020 --> 00:03:55,670
之后，计算输出维度的正确做法是

54
00:03:55,670 --> 00:04:01,990
如果(N+2P-F)/S不是整数的话，则将其向下取整。

55
00:04:01,990 --> 00:04:04,205
总结一下维度的计算

56
00:04:04,205 --> 00:04:07,780
如果你有一个NxN的图像或矩阵

57
00:04:07,780 --> 00:04:12,620
将其填充P层元素后，用FxF大小的过滤器，以步长为S的方式

58
00:04:12,620 --> 00:04:16,993
进行卷积。输出的矩阵大小为(N+2P-F)/S+1

59
00:04:16,993 --> 00:04:21,000
我们可以选择这些数的数值，使结果为整数

60
00:04:21,000 --> 00:04:27,660
尽管你不必考虑这些。使用向下取整也是很正常的。

61
00:04:27,660 --> 00:04:32,900
但是如果你想的话，你尝试一些N，F，P，S的值

62
00:04:32,900 --> 00:04:35,850
来说服自己

63
00:04:35,850 --> 00:04:41,331
这个公式可以得到正确的维度

64
00:04:41,331 --> 00:04:45,880
现在，在继续之前，

65
00:04:45,880 --> 00:04:49,480
因为你们要自己实现卷积神经网络，所以

66
00:04:49,480 --> 00:04:53,735
我要做点关于交叉相关与卷积的说明。

67
00:04:53,735 --> 00:04:59,790
如果你读不同的数学课本或是信号处理的课本

68
00:04:59,790 --> 00:05:05,690
在符号表示上，本课程可能与其有不一致的情况。

69
00:05:05,690 --> 00:05:07,850
如果你看标准的数学课本，

70
00:05:07,850 --> 00:05:12,650
对于卷积的定义，其实在做元素间相乘并求和的之前，

71
00:05:12,650 --> 00:05:16,370
例如在用这个3x3的过滤器对6x6矩阵进行卷积之前

72
00:05:16,370 --> 00:05:20,550
你其实需要做另外一个步奏，

73
00:05:20,550 --> 00:05:24,980
你先将3x3过滤器沿水平轴进行翻转

74
00:05:24,980 --> 00:05:30,280
同样对竖直轴进行翻转。这样3,4,5,1,0,2,-1,9,7会

75
00:05:30,280 --> 00:05:38,580
变成,3到这,4到这

76
00:05:38,580 --> 00:05:43,070
5到这。之后是第二行

77
00:05:43,070 --> 00:05:49,660
变成这样。1,0,2,-1,9,7

78
00:05:49,660 --> 00:05:53,120
这样就将3x3过滤器

79
00:05:53,120 --> 00:05:58,218
对水平和竖直轴进行镜像映射

80
00:05:58,218 --> 00:06:04,225
之后，将其放进矩阵中，放到这。

81
00:06:04,225 --> 00:06:06,175
计算结果

82
00:06:06,175 --> 00:06:08,650
2乘以7

83
00:06:08,650 --> 00:06:10,045
加上3乘以2

84
00:06:10,045 --> 00:06:15,275
加上7乘以5，,以此类推。

85
00:06:15,275 --> 00:06:19,910
计算出这些值是为了

86
00:06:19,910 --> 00:06:25,415
计算4x4输出矩阵中的左上角元素

87
00:06:25,415 --> 00:06:31,425
之后将这九个值

88
00:06:31,425 --> 00:06:35,916
右移一个步长，以此类推。

89
00:06:35,916 --> 00:06:38,990
我们在本视频中定义的卷积操作

90
00:06:38,990 --> 00:06:43,495
将翻转操作省略了。

91
00:06:43,495 --> 00:06:45,930
技术层面来说，实际上

92
00:06:45,930 --> 00:06:49,360
我们在之前的视频中进行的操作

93
00:06:49,360 --> 00:06:54,180
应该是叫交叉相关，而不是卷积。

94
00:06:54,180 --> 00:06:57,645
但是在深度学习文献中，由于约定

95
00:06:57,645 --> 00:07:01,760
我们只不过将其称为卷积。

96
00:07:01,760 --> 00:07:06,215
总结一下，在机器学习的约定中，

97
00:07:06,215 --> 00:07:10,730
我们通常忽略掉翻转的操作。

98
00:07:10,730 --> 00:07:15,200
技术上，我们进行的操作最好称之为交叉相关。

99
00:07:15,200 --> 00:07:20,165
但是，大多数深度学习的文献都叫它卷积操作。

100
00:07:20,165 --> 00:07:23,430
所以，在本课程的视频中，我将延续这一约定。

101
00:07:23,430 --> 00:07:28,155
如果你读过许多机器学习的相关文献

102
00:07:28,155 --> 00:07:30,320
你就会发现

103
00:07:30,320 --> 00:07:35,490
大多数人叫这个卷积，并不需要做翻转

104
00:07:35,490 --> 00:07:40,120
事实上，在信号处理或其他数学分支领域

105
00:07:40,120 --> 00:07:43,615
对卷积核进行翻转

106
00:07:43,615 --> 00:07:49,870
会使卷积核保持

107
00:07:49,870 --> 00:07:53,320
（A卷积B）卷积C等于A卷积（B卷积C)

108
00:07:53,320 --> 00:07:58,505
这一性质在数学上叫结合率（associativity）

109
00:07:58,505 --> 00:08:02,080
这一性质在信号处理领域很有用

110
00:08:02,080 --> 00:08:05,860
但对深度神经网络而言，它并不重要

111
00:08:05,860 --> 00:08:08,680
所以元素间相乘并求和简化了代码

112
00:08:08,680 --> 00:08:14,450
而且这一改变后，神经网络照常工作

113
00:08:14,450 --> 00:08:18,380
为了方便，我们大部分人叫这个卷积

114
00:08:18,380 --> 00:08:24,240
即使有时数学家更喜欢管它叫交叉相关

115
00:08:24,240 --> 00:08:28,352
但是叫法对你在练习中写的代码没有影响

116
00:08:28,352 --> 00:08:31,860
并且对你

117
00:08:31,860 --> 00:08:38,222
阅读理解深度学习文献的能力没有影响

118
00:08:38,222 --> 00:08:41,600
你现在已经看到了如何进行卷积

119
00:08:41,600 --> 00:08:45,715
也看到了如何进行通过填充和跨步长进行卷积

120
00:08:45,715 --> 00:08:49,795
但是现在，我们看到的都是对矩阵进行卷积

121
00:08:49,795 --> 00:08:51,545
比如对6 x 6矩阵

122
00:08:51,545 --> 00:08:55,670
在下个视频中，如果在3维体积中进行卷积

123
00:08:55,670 --> 00:08:59,730
这会使卷积操作具有更加强大的魔力

124
00:08:59,730 --> 00:09:01,580
我们下一节再见