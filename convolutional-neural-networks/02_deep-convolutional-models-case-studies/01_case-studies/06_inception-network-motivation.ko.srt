1
00:00:00,000 --> 00:00:03,370
컨볼넷을 위한 레이어를 디자인 할 때,

2
00:00:03,370 --> 00:00:05,430
1 x 3 필터를 원하십니까,

3
00:00:05,430 --> 00:00:07,385
혹은 3 x 3, 5 x 5,

4
00:00:07,385 --> 00:00:09,180
또는 pooling 레이어를 원하시나요?

5
00:00:09,180 --> 00:00:11,920
인셉션망은 이야기하고자 하는 것은,

6
00:00:11,920 --> 00:00:13,095
왜 당신은 그것들 전부를 해야 합니까? 라는 겁니다.

7
00:00:13,095 --> 00:00:16,255
그리고 이것은 네트워크 아키텍처를 더욱 복잡하게 만듭니다.

8
00:00:16,255 --> 00:00:18,380
그러나 이것은 또한 상당히 잘 작동합니다. 어떻게 작동하는지 봅시다

9
00:00:18,380 --> 00:00:19,720
어떻게 이루어지고 있는지 함께 이야기해봅시다.

10
00:00:19,720 --> 00:00:23,380
예를 들어 28 x 28 x 192 차원 볼륨으로

11
00:00:23,380 --> 00:00:26,990
입력했다고 가정 해 봅시다.

12
00:00:26,990 --> 00:00:32,500
인셉션망 또는 인셉션 레이어가 말하고자 하는 것은

13
00:00:32,500 --> 00:00:36,600
컨볼 레이어에서 여러분이 원하는 필터사이즈를 고르는 대신에

14
00:00:36,600 --> 00:00:40,205
여러분은 컨볼루션 레이어와 pooling 레이어 중에 어떤 것은 원하는지 입니다.

15
00:00:40,205 --> 00:00:46,795
전부 다 해봅시다. 1 x 1 컨볼 루션을 사용할 수 있다면,

16
00:00:46,795 --> 00:00:50,750
28 x 28 x 아무개로 아웃풋을 할 것입니다.

17
00:00:50,750 --> 00:00:56,180
28 x 28 x 64 output 이라고 하면,

18
00:00:56,180 --> 00:00:58,405
여기에 볼륨이 있죠

19
00:00:58,405 --> 00:01:06,510
어쩌면 당신은 3 x 3을 시도해보고 싶을 것이고, 20 x 12 x 128 아웃풋이 될 겁니다.

20
00:01:06,510 --> 00:01:13,975
그러면 여러분은 이 두 번째 볼륨을 첫 번째 볼륨 옆에 쌓아 올리시면 됩니다.

21
00:01:13,975 --> 00:01:16,415
그리고 차원을 일치 시키려면,

22
00:01:16,415 --> 00:01:19,470
이것을 같은 컨볼루션으로 만들어 봅시다.

23
00:01:19,470 --> 00:01:23,500
따라서 아웃풋 차수는 높이와 너비 측면에서

24
00:01:23,500 --> 00:01:26,965
인풋차수와 마찬가지로 28 x 28입니다.

25
00:01:26,965 --> 00:01:31,300
그러나 이 예에서는 28 x 28 x 128 입니다.

26
00:01:31,300 --> 00:01:34,510
그리고 아마 양쪽에 다 걸으라고 말할지도 모릅니다.

27
00:01:34,510 --> 00:01:36,710
아마 5 x 5필터가 더 잘 효과적일 수 있으니까요.

28
00:01:36,710 --> 00:01:44,755
그러니 그것도 해봅시다. 그리고 이건 아웃풋 28 x 28 x 32 가 됩니다..

29
00:01:44,755 --> 00:01:49,435
그리고 같은 컨볼루션을 사용하여 치수를 동일하게 유지하십시오.

30
00:01:49,435 --> 00:01:52,715
그리고 아마도 당신은 컨볼루션 레이어를 원치 않으실 테니,

31
00:01:52,715 --> 00:01:58,560
pooling을 적용 해 보도록 합시다. 그러면 어떤 다른 아웃풋이 될 테고, 그럼 그걸 쌓아봅시다

32
00:01:58,560 --> 00:02:05,070
여기에 pooling 아웃풋이 28 x 28 x 32입니다.

33
00:02:05,070 --> 00:02:09,195
이 모든 차수가 잘 맞도록,

34
00:02:09,195 --> 00:02:12,560
실제로 최대 pooling을 위해 패딩을 사용해야 합니다.

35
00:02:12,560 --> 00:02:15,950
따라서 이것은 비정상적인 pooling입니다.

36
00:02:15,950 --> 00:02:19,985
인풋 값이 28 x 28보다 높길 원하고, 아웃풋 값이 차수를 똑같이 맞추어

37
00:02:19,985 --> 00:02:24,395
28 x 28 로 되길 원한다면,

38
00:02:24,395 --> 00:02:31,020
pooling을 위해 스트라이드는 1 그리고 동일한 패딩을 사용해야 합니다.

39
00:02:31,020 --> 00:02:34,230
따라서 이 세부사항을 어쩌면 시시해 보일지도 모릅니다.

40
00:02:34,230 --> 00:02:35,520
계속 해봅시다.

41
00:02:35,520 --> 00:02:39,310
이 모든 것이 나중에 효과적일 수 있도록 만들 것 입니다.

42
00:02:39,310 --> 00:02:43,170
그러나 이런 인셉션 모듈을 사용하면

43
00:02:43,170 --> 00:02:46,080
볼륨과 아웃풋을 인풋할 수 있습니다

44
00:02:46,080 --> 00:02:48,640
이 경우에, 이 모든 숫자들을 더하면,

45
00:02:48,640 --> 00:02:51,705
32 + 32 + 128 + 64는

46
00:02:51,705 --> 00:02:54,915
256 이 됩니다.

47
00:02:54,915 --> 00:03:01,515
따라서 여러분은 28 x 28 x 129의 인셉션 모듈 인풋과

48
00:03:01,515 --> 00:03:06,275
28 x 28 x 256 아웃풋을 갖게 될 것입니다.

49
00:03:06,275 --> 00:03:11,300
이것은 인셉션망의 핵심입니다.

50
00:03:11,300 --> 00:03:13,260
이는 Christian Szegedy, Wei Liu,

51
00:03:13,260 --> 00:03:15,130
Yangqing Jia와 Pierre Sermanet,

52
00:03:15,130 --> 00:03:17,750
Scott Reed와 Dragomir Anguelov, 그리고 Dumitru Erhan,

53
00:03:17,750 --> 00:03:20,660
Vincent Vanhoucke 와 Andrew Rabinovich 에 의해 창설된 것이죠.

54
00:03:20,660 --> 00:03:23,950
기본 아이디어는

55
00:03:23,950 --> 00:03:30,000
이러한 필터 사이즈 원하는 pooling을 선택해서 그것에게 할당 대신에

56
00:03:30,000 --> 00:03:33,200
여러분이 모든 것을 하고 모든 아웃풋이 연결되도록 하면 됩니다.

57
00:03:33,200 --> 00:03:36,270
그리고 네트워크가 원하는 파라미터가 무엇이든,

58
00:03:36,270 --> 00:03:40,050
원하는 필터 사이즈 조합이 무엇이든, 이를 다 학습하게 두십시오.

59
00:03:40,050 --> 00:03:42,420
이제 우리가 여기에서 설명한 것처럼

60
00:03:42,420 --> 00:03:44,745
인셉션 레이어에 문제가 있다는 것이 밝혀졌습니다.

61
00:03:44,745 --> 00:03:46,795
바로 계산 비용입니다.

62
00:03:46,795 --> 00:03:48,060
다음 슬라이드에서

63
00:03:48,060 --> 00:03:54,485
여기 블럭을 만드는 이 5 x 5 필터의 계산 비용이

64
00:03:54,485 --> 00:03:56,655
얼마나 되는지 알아 보겠습니다

65
00:03:56,655 --> 00:04:02,735
이전 슬라이드의 5 x 5 포트에 초점을 맞추기 위해

66
00:04:02,735 --> 00:04:07,010
28 x 28 x 192 블록을 인풋하고

67
00:04:07,010 --> 00:04:14,620
32 개 필터를 가진 5 x 5 동일한 컨볼루션을 28 x 28 x 32 아웃풋으로 실행하십시오.

68
00:04:14,620 --> 00:04:18,750
이전 슬라이드 나는 이것을 얇은 자주색 슬라이드로 그렸었습니다.

69
00:04:18,750 --> 00:04:23,035
그래서 저는 좀 더 평범 해 보이는 푸른 색 블록으로 그려 넣을 것입니다.

70
00:04:23,035 --> 00:04:30,700
따라서 이 20 × 20 x 32로 아웃풋 하는 데 드는 계산 비용을 살펴 보겠습니다.

71
00:04:30,700 --> 00:04:38,065
아웃풋에는 32 개의 채널이 있고 각 필터는 5 x 5 x 192 가 될 것이기 때문에

72
00:04:38,065 --> 00:04:44,805
여러분은 32개의 필터를 가지고 있습니다.

73
00:04:44,805 --> 00:04:48,410
따라서 아웃풋 사이즈가 20 x 20 x 32가 되고,

74
00:04:48,410 --> 00:04:53,600
28 x 28 x 32를 계산해야 합니다.

75
00:04:53,600 --> 00:04:58,685
이 각각을 위해서 이 많은 곱셈을 해야만 하는 것입니다, 그렇죠?

76
00:04:58,685 --> 00:05:01,185
5 x 5 x 192

77
00:05:01,185 --> 00:05:03,550
필요한 곱셈의 총액은

78
00:05:03,550 --> 00:05:07,010
각각의 아웃풋 값을 계산하기 위해 필요한 곱셈의 수에다가

79
00:05:07,010 --> 00:05:12,615
계산해야 할 아웃풋 값의 수를 곱하면 됩니다.

80
00:05:12,615 --> 00:05:15,330
그리고 이 숫자들을 모두 곱하면,

81
00:05:15,330 --> 00:05:18,790
이것은 1 억 2 천만입니다.

82
00:05:18,790 --> 00:05:24,725
따라서 현대 컴퓨터에서 1 억 2 천만 배의 곱셈을 할 수는 있지만

83
00:05:24,725 --> 00:05:27,385
여전히 비싼 작업입니다.

84
00:05:27,385 --> 00:05:32,390
다음 슬라이드에서는, 이전 강의에서 배웠던

85
00:05:32,390 --> 00:05:34,210
1 x 1 컨볼루션의 아이디어를 사용하는 방법을 알아보도록 하겠습니다.

86
00:05:34,210 --> 00:05:38,630
이렇게 하면 계산 비용을 약 10 배 감축 할 수 있습니다.

87
00:05:38,630 --> 00:05:44,400
약 1 억 2 천만에서 약 1/10 배로 곱하십시오.

88
00:05:44,400 --> 00:05:48,575
따라서 번호 120을 기억해 두십시오.

89
00:05:48,575 --> 00:05:52,045
다음 슬라이드에서 1 억 2 천만과 비교할 수 있습니다.

90
00:05:52,045 --> 00:05:58,540
여기에 28 x 28 x 192를 인풋하고

91
00:05:58,540 --> 00:06:03,020
28 x 28 x 32의 아웃풋을 하기 위한 대체 아키텍쳐가 있습니다.

92
00:06:03,020 --> 00:06:05,175
192 채널 대신 16 채널로 볼륨을 줄이기 위해서

93
00:06:05,175 --> 00:06:14,580
볼륨을 사용하고, 1 x 1 컨볼루션을 사용할 것입니다.

94
00:06:14,580 --> 00:06:17,370
그리고 나면 이 매우 작은 볼륨에

95
00:06:17,370 --> 00:06:21,915
최종 아웃풋을 제공하기 위해 5 x 5 컨볼루션 실행시킬 것입니다.

96
00:06:21,915 --> 00:06:24,665
인풋과 아웃풋 차수는 여전히 동일하다는 점에 주목해 주십시오.

97
00:06:24,665 --> 00:06:31,280
이전 슬라이드와 마찬가지로 28 x 28 x 192를 입력하고,

98
00:06:31,280 --> 00:06:33,865
28 x 28 x 32로 아웃풋 하십시오.

99
00:06:33,865 --> 00:06:37,340
이렇게 해서 우리는 왼쪽에 있는 이 엄청난 양의 볼륨을 사용하는 것입니다.

100
00:06:37,340 --> 00:06:42,110
그리고 우리는 이것을 이 만큼 더 작은 중간크기의 볼륨으로 축소시켰습니다.

101
00:06:42,110 --> 00:06:46,740
이는 192채널 대신에 16개 채널만 가지고 있습니다.

102
00:06:46,740 --> 00:06:53,000
때때로 이것을 병목 레이어라고 부릅니다, 그렇죠?

103
00:06:53,600 --> 00:06:59,890
병목은 일반적으로 어떤 물체의 가장 작은 부분이기 때문에 이렇게 부르는 것 같군요, 그렇죠?

104
00:06:59,890 --> 00:07:04,820
그래서 당신이 이것처럼 보이는 유리 병을 가지고 있다면,

105
00:07:04,820 --> 00:07:09,065
코르크가 어디에 있어야 하는지 아시겠죠.

106
00:07:09,065 --> 00:07:13,615
병목 현상은이 병의 가장 작은 부분입니다.

107
00:07:13,615 --> 00:07:18,035
마찬가지로 병목 레이어는 이 네트워크의 가장 작은 부분입니다.

108
00:07:18,035 --> 00:07:22,625
크기를 다시 늘리기 전에 representation을 작게 만듭니다.

109
00:07:22,625 --> 00:07:26,945
이제 계산 된 비용을 살펴 보겠습니다.

110
00:07:26,945 --> 00:07:30,320
1 x 1 컨볼루션을 적용하기 위해

111
00:07:30,320 --> 00:07:32,510
16 개의 필터가 있습니다.

112
00:07:32,510 --> 00:07:37,145
각 필터는 1 x 1 x 192의 차수가 될 것이고

113
00:07:37,145 --> 00:07:40,170
이 192는 192와 일치 할 것입니다.

114
00:07:40,170 --> 00:07:43,300
따라서 28 x 28 x16볼륨으로

115
00:07:43,300 --> 00:07:45,870
계산하는 비용은 좋을 것입니다.

116
00:07:45,870 --> 00:07:48,205
여러분은 이 많은 아웃풋이 필요하며

117
00:07:48,205 --> 00:07:54,900
이들 각각을 위해 192번의 곱셈을 해야만 합니다.

118
00:07:54,900 --> 00:07:58,515
1 x 1 x 192 이렇게 쓸 수 있었겠죠?

119
00:07:58,515 --> 00:08:00,960
다시 말해, 이걸 곱하면,

120
00:08:00,960 --> 00:08:02,650
이것은 240만입니다.

121
00:08:02,650 --> 00:08:04,370
대략 240만 입니다.

122
00:08:04,370 --> 00:08:05,655
두 번째 것은 어떻죠?

123
00:08:05,655 --> 00:08:11,325
이것이 첫 번째 컨볼루션 레이어의 비용입니다.

124
00:08:11,325 --> 00:08:15,670
이 두 번째 컨볼루션 레이어의 비용은 잘 될 것입니다.

125
00:08:15,670 --> 00:08:17,290
이렇게 많은 아웃풋이 있습니다.

126
00:08:17,290 --> 00:08:19,340
그래서 28 x 32 x 32

127
00:08:19,340 --> 00:08:28,200
그리고 나서 각 아웃풋에 대해 5 x 5 x 16 차원 필터를 적용해야 합니다.

128
00:08:28,200 --> 00:08:31,305
따라서 5 x 5 x 16 가 되는 것이죠.

129
00:08:31,305 --> 00:08:36,520
그리고 이 둘을 곱하면 10.0million이 됩니다.

130
00:08:36,520 --> 00:08:41,160
따라서 필요한 총 곱셈의 수는 131

131
00:08:41,160 --> 00:08:45,020
1240 만 배수의 곱셈의 합계입니다.

132
00:08:45,020 --> 00:08:47,955
그리고 이것을 이전 슬라이드와 비교해보십시오.

133
00:08:47,955 --> 00:08:53,095
계산 비용을 약 1 억 2 천만에서

134
00:08:53,095 --> 00:08:55,810
약 10분의 1 배까지

135
00:08:55,810 --> 00:08:59,335
천이백만 곱셈으로 줄이는 겁니다.

136
00:08:59,335 --> 00:09:02,345
필요한 덧셈 횟수는

137
00:09:02,345 --> 00:09:06,305
수행해야 하는 곱셈의 수와 매우 유사합니다.

138
00:09:06,305 --> 00:09:10,230
그렇기 때문에 저는 곱셈의 횟수를 세고 있습니다.

139
00:09:10,230 --> 00:09:13,490
요약하면,

140
00:09:13,490 --> 00:09:16,140
신경망 레이어를 구축하고 있고,

141
00:09:16,140 --> 00:09:17,820
1 x 1 을 원하는지,

142
00:09:17,820 --> 00:09:20,095
3 x 3, 5 x 5, 혹은 pooling 레이어,

143
00:09:20,095 --> 00:09:23,560
아님 인셉션 모듈을 원하는지 결정할 필요가 없다면, 전부 계산하고

144
00:09:23,560 --> 00:09:25,645
결과값을 연결하십시오.

145
00:09:25,645 --> 00:09:28,720
계산 비용의 문제점을 살펴봤습니다.

146
00:09:28,720 --> 00:09:32,460
어떻게 1 x 1 컨볼루션을 사용하는지 알아보았는데요.

147
00:09:32,460 --> 00:09:34,585
이 병목 레이어를 생성해서

148
00:09:34,585 --> 00:09:38,115
계산 비용을 크게 줄일 수 있었습니다.

149
00:09:38,115 --> 00:09:39,725
이제 여러분은 아마도

150
00:09:39,725 --> 00:09:43,370
representation의 크기를 너무 과하게 줄인 건지,

151
00:09:43,370 --> 00:09:46,730
신경 네트워크의 성능을 해치고 있는지 궁금해하고 계실 것입니다.

152
00:09:46,730 --> 00:09:52,440
병목 레이어를 구현하면

153
00:09:52,440 --> 00:09:56,530
representation의 크기를 상당히 줄일 수 있고

154
00:09:56,530 --> 00:09:59,240
성능을 해치는 것처럼 보이지는 않지만

155
00:09:59,240 --> 00:10:01,700
많은 계산 량을 절약 할 수 있습니다.

156
00:10:01,700 --> 00:10:07,835
따라서 이것이 인셉션 모듈의 핵심 아이디어입니다.

157
00:10:07,835 --> 00:10:09,790
그것들을 합쳐서

158
00:10:09,790 --> 00:10:14,100
다음 강의에서 완전 인셉션망은 어떻게 생겼는지 보여드리도록 하겠습니다.