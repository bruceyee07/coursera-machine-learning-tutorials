컨볼넷을 위한 레이어를 디자인 할 때, 1 x 3 필터를 원하십니까, 혹은 3 x 3, 5 x 5, 또는 pooling 레이어를 원하시나요? 인셉션망은 이야기하고자 하는 것은, 왜 당신은 그것들 전부를 해야 합니까? 라는 겁니다. 그리고 이것은 네트워크 아키텍처를 더욱 복잡하게 만듭니다. 그러나 이것은 또한 상당히 잘 작동합니다. 어떻게 작동하는지 봅시다 어떻게 이루어지고 있는지 함께 이야기해봅시다. 예를 들어 28 x 28 x 192 차원 볼륨으로 입력했다고 가정 해 봅시다. 인셉션망 또는 인셉션 레이어가 말하고자 하는 것은 컨볼 레이어에서 여러분이 원하는 필터사이즈를 고르는 대신에 여러분은 컨볼루션 레이어와 pooling 레이어 중에 어떤 것은 원하는지 입니다. 전부 다 해봅시다. 1 x 1 컨볼 루션을 사용할 수 있다면, 28 x 28 x 아무개로 아웃풋을 할 것입니다. 28 x 28 x 64 output 이라고 하면, 여기에 볼륨이 있죠 어쩌면 당신은 3 x 3을 시도해보고 싶을 것이고, 20 x 12 x 128 아웃풋이 될 겁니다. 그러면 여러분은 이 두 번째 볼륨을 첫 번째 볼륨 옆에 쌓아 올리시면 됩니다. 그리고 차원을 일치 시키려면, 이것을 같은 컨볼루션으로 만들어 봅시다. 따라서 아웃풋 차수는 높이와 너비 측면에서 인풋차수와 마찬가지로 28 x 28입니다. 그러나 이 예에서는 28 x 28 x 128 입니다. 그리고 아마 양쪽에 다 걸으라고 말할지도 모릅니다. 아마 5 x 5필터가 더 잘 효과적일 수 있으니까요. 그러니 그것도 해봅시다. 그리고 이건 아웃풋 28 x 28 x 32 가 됩니다.. 그리고 같은 컨볼루션을 사용하여 치수를 동일하게 유지하십시오. 그리고 아마도 당신은 컨볼루션 레이어를 원치 않으실 테니, pooling을 적용 해 보도록 합시다. 그러면 어떤 다른 아웃풋이 될 테고, 그럼 그걸 쌓아봅시다 여기에 pooling 아웃풋이 28 x 28 x 32입니다. 이 모든 차수가 잘 맞도록, 실제로 최대 pooling을 위해 패딩을 사용해야 합니다. 따라서 이것은 비정상적인 pooling입니다. 인풋 값이 28 x 28보다 높길 원하고, 아웃풋 값이 차수를 똑같이 맞추어 28 x 28 로 되길 원한다면, pooling을 위해 스트라이드는 1 그리고 동일한 패딩을 사용해야 합니다. 따라서 이 세부사항을 어쩌면 시시해 보일지도 모릅니다. 계속 해봅시다. 이 모든 것이 나중에 효과적일 수 있도록 만들 것 입니다. 그러나 이런 인셉션 모듈을 사용하면 볼륨과 아웃풋을 인풋할 수 있습니다 이 경우에, 이 모든 숫자들을 더하면, 32 + 32 + 128 + 64는 256 이 됩니다. 따라서 여러분은 28 x 28 x 129의 인셉션 모듈 인풋과 28 x 28 x 256 아웃풋을 갖게 될 것입니다. 이것은 인셉션망의 핵심입니다. 이는 Christian Szegedy, Wei Liu, Yangqing Jia와 Pierre Sermanet, Scott Reed와 Dragomir Anguelov, 그리고 Dumitru Erhan, Vincent Vanhoucke 와 Andrew Rabinovich 에 의해 창설된 것이죠. 기본 아이디어는 이러한 필터 사이즈 원하는 pooling을 선택해서 그것에게 할당 대신에 여러분이 모든 것을 하고 모든 아웃풋이 연결되도록 하면 됩니다. 그리고 네트워크가 원하는 파라미터가 무엇이든, 원하는 필터 사이즈 조합이 무엇이든, 이를 다 학습하게 두십시오. 이제 우리가 여기에서 설명한 것처럼 인셉션 레이어에 문제가 있다는 것이 밝혀졌습니다. 바로 계산 비용입니다. 다음 슬라이드에서 여기 블럭을 만드는 이 5 x 5 필터의 계산 비용이 얼마나 되는지 알아 보겠습니다 이전 슬라이드의 5 x 5 포트에 초점을 맞추기 위해 28 x 28 x 192 블록을 인풋하고 32 개 필터를 가진 5 x 5 동일한 컨볼루션을 28 x 28 x 32 아웃풋으로 실행하십시오. 이전 슬라이드 나는 이것을 얇은 자주색 슬라이드로 그렸었습니다. 그래서 저는 좀 더 평범 해 보이는 푸른 색 블록으로 그려 넣을 것입니다. 따라서 이 20 × 20 x 32로 아웃풋 하는 데 드는 계산 비용을 살펴 보겠습니다. 아웃풋에는 32 개의 채널이 있고 각 필터는 5 x 5 x 192 가 될 것이기 때문에 여러분은 32개의 필터를 가지고 있습니다. 따라서 아웃풋 사이즈가 20 x 20 x 32가 되고, 28 x 28 x 32를 계산해야 합니다. 이 각각을 위해서 이 많은 곱셈을 해야만 하는 것입니다, 그렇죠? 5 x 5 x 192 필요한 곱셈의 총액은 각각의 아웃풋 값을 계산하기 위해 필요한 곱셈의 수에다가 계산해야 할 아웃풋 값의 수를 곱하면 됩니다. 그리고 이 숫자들을 모두 곱하면, 이것은 1 억 2 천만입니다. 따라서 현대 컴퓨터에서 1 억 2 천만 배의 곱셈을 할 수는 있지만 여전히 비싼 작업입니다. 다음 슬라이드에서는, 이전 강의에서 배웠던 1 x 1 컨볼루션의 아이디어를 사용하는 방법을 알아보도록 하겠습니다. 이렇게 하면 계산 비용을 약 10 배 감축 할 수 있습니다. 약 1 억 2 천만에서 약 1/10 배로 곱하십시오. 따라서 번호 120을 기억해 두십시오. 다음 슬라이드에서 1 억 2 천만과 비교할 수 있습니다. 여기에 28 x 28 x 192를 인풋하고 28 x 28 x 32의 아웃풋을 하기 위한 대체 아키텍쳐가 있습니다. 192 채널 대신 16 채널로 볼륨을 줄이기 위해서 볼륨을 사용하고, 1 x 1 컨볼루션을 사용할 것입니다. 그리고 나면 이 매우 작은 볼륨에 최종 아웃풋을 제공하기 위해 5 x 5 컨볼루션 실행시킬 것입니다. 인풋과 아웃풋 차수는 여전히 동일하다는 점에 주목해 주십시오. 이전 슬라이드와 마찬가지로 28 x 28 x 192를 입력하고, 28 x 28 x 32로 아웃풋 하십시오. 이렇게 해서 우리는 왼쪽에 있는 이 엄청난 양의 볼륨을 사용하는 것입니다. 그리고 우리는 이것을 이 만큼 더 작은 중간크기의 볼륨으로 축소시켰습니다. 이는 192채널 대신에 16개 채널만 가지고 있습니다. 때때로 이것을 병목 레이어라고 부릅니다, 그렇죠? 병목은 일반적으로 어떤 물체의 가장 작은 부분이기 때문에 이렇게 부르는 것 같군요, 그렇죠? 그래서 당신이 이것처럼 보이는 유리 병을 가지고 있다면, 코르크가 어디에 있어야 하는지 아시겠죠. 병목 현상은이 병의 가장 작은 부분입니다. 마찬가지로 병목 레이어는 이 네트워크의 가장 작은 부분입니다. 크기를 다시 늘리기 전에 representation을 작게 만듭니다. 이제 계산 된 비용을 살펴 보겠습니다. 1 x 1 컨볼루션을 적용하기 위해 16 개의 필터가 있습니다. 각 필터는 1 x 1 x 192의 차수가 될 것이고 이 192는 192와 일치 할 것입니다. 따라서 28 x 28 x16볼륨으로 계산하는 비용은 좋을 것입니다. 여러분은 이 많은 아웃풋이 필요하며 이들 각각을 위해 192번의 곱셈을 해야만 합니다. 1 x 1 x 192 이렇게 쓸 수 있었겠죠? 다시 말해, 이걸 곱하면, 이것은 240만입니다. 대략 240만 입니다. 두 번째 것은 어떻죠? 이것이 첫 번째 컨볼루션 레이어의 비용입니다. 이 두 번째 컨볼루션 레이어의 비용은 잘 될 것입니다. 이렇게 많은 아웃풋이 있습니다. 그래서 28 x 32 x 32 그리고 나서 각 아웃풋에 대해 5 x 5 x 16 차원 필터를 적용해야 합니다. 따라서 5 x 5 x 16 가 되는 것이죠. 그리고 이 둘을 곱하면 10.0million이 됩니다. 따라서 필요한 총 곱셈의 수는 131 1240 만 배수의 곱셈의 합계입니다. 그리고 이것을 이전 슬라이드와 비교해보십시오. 계산 비용을 약 1 억 2 천만에서 약 10분의 1 배까지 천이백만 곱셈으로 줄이는 겁니다. 필요한 덧셈 횟수는 수행해야 하는 곱셈의 수와 매우 유사합니다. 그렇기 때문에 저는 곱셈의 횟수를 세고 있습니다. 요약하면, 신경망 레이어를 구축하고 있고, 1 x 1 을 원하는지, 3 x 3, 5 x 5, 혹은 pooling 레이어, 아님 인셉션 모듈을 원하는지 결정할 필요가 없다면, 전부 계산하고 결과값을 연결하십시오. 계산 비용의 문제점을 살펴봤습니다. 어떻게 1 x 1 컨볼루션을 사용하는지 알아보았는데요. 이 병목 레이어를 생성해서 계산 비용을 크게 줄일 수 있었습니다. 이제 여러분은 아마도 representation의 크기를 너무 과하게 줄인 건지, 신경 네트워크의 성능을 해치고 있는지 궁금해하고 계실 것입니다. 병목 레이어를 구현하면 representation의 크기를 상당히 줄일 수 있고 성능을 해치는 것처럼 보이지는 않지만 많은 계산 량을 절약 할 수 있습니다. 따라서 이것이 인셉션 모듈의 핵심 아이디어입니다. 그것들을 합쳐서 다음 강의에서 완전 인셉션망은 어떻게 생겼는지 보여드리도록 하겠습니다.