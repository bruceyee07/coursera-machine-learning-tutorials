1
00:00:00,000 --> 00:00:03,836
대부분의 컴퓨터 비전 작업은 더 많은 데이터를 사용할 수 있습니다. 

2
00:00:03,836 --> 00:00:07,350
데이터 증강(data augmentation)은 컴퓨터 비전 시스템의 성능을 향상시키는 데 

3
00:00:07,350 --> 00:00:11,995
자주 사용되는 기술 중 하나입니다. 

4
00:00:11,995 --> 00:00:15,535
저는 컴퓨터 비전이 꽤 복잡한 과제라고 생각합니다

5
00:00:15,535 --> 00:00:16,745
여러분이 이 이미지와

6
00:00:16,745 --> 00:00:21,870
이 모든 픽셀을 입력 한 다음, 이 사진 안에 보이는 것이 무엇인지 알아내야 합니다. 

7
00:00:21,870 --> 00:00:26,615
그리고 그렇게하기 위해서는 복잡하고 복잡한 기능을 배워야 할 필요가있어 보입니다.

8
00:00:26,615 --> 00:00:32,160
실제로, 더 많은 데이터를 가지고있는 거의 모든 경쟁 비전 작업이 도움이 될 것입니다. 

9
00:00:32,160 --> 00:00:36,580
이것은 때로는 충분한 데이터를 얻을 수있는 다른 도메인과는 달리 

10
00:00:36,580 --> 00:00:39,610
더 많은 데이터를 확보해야하는 부담을 느끼지 않습니다.

11
00:00:39,610 --> 00:00:42,428
그러나 저는 오늘날이 데이터 컴퓨터 비전은 

12
00:00:42,428 --> 00:00:44,655
대다수의 컴퓨터 비전 문제로 인해 

13
00:00:44,655 --> 00:00:47,655
충분한 데이터를 얻을 수 없다고 생각합니다. 

14
00:00:47,655 --> 00:00:50,783
그리고 이것은 머신러닝의 모든 응용 프로그램에 적용되는 것은 아니지만 

15
00:00:50,783 --> 00:00:53,490
컴퓨터 비전에 맞는 것처럼 느껴집니다. 

16
00:00:53,490 --> 00:00:57,120
즉, 컴퓨터 비전 모델에서 훈련할 때 

17
00:00:57,120 --> 00:00:59,880
종종 데이터 증강이 도움이 된다는 것입니다. 

18
00:00:59,880 --> 00:01:02,520
그리고 이것은 이전 학습을 사용하거나 

19
00:01:02,520 --> 00:01:05,720
누군가가 사전 훈련한 방법들을 사용해 시작하거나, 

20
00:01:05,720 --> 00:01:09,055
혹은 처음부터 무언가를 훈련 시키려고 하든간에 사실입니다. 

21
00:01:09,055 --> 00:01:13,755
컴퓨터 비전에서 보편적인 데이터 증강에 대해 살펴 보겠습니다. 

22
00:01:13,755 --> 00:01:19,920
아마도 가장 간단한 데이터 확대 방법은 수직 축에서 미러링하는 것일겁니다. 

23
00:01:19,920 --> 00:01:22,995
여기서 트레이닝 세트에 이 예가 있으면

24
00:01:22,995 --> 00:01:27,045
오른쪽으로 그 이미지를 가져 오기 위해 수평으로 뒤집습니다.

25
00:01:27,045 --> 00:01:29,300
그리고 대부분의 컴퓨터 비전 작업에서 

26
00:01:29,300 --> 00:01:33,475
왼쪽 그림이 고양이라면 거울은 고양이 일뿐입니다. 

27
00:01:33,475 --> 00:01:35,610
미러링 작업을 통해 

28
00:01:35,610 --> 00:01:38,890
그림에서 인식하고자하는 내용을 그대로 유지하면

29
00:01:38,890 --> 00:01:43,395
좋은 데이터 증강 기법을 사용할 수 있습니다. 

30
00:01:43,395 --> 00:01:47,035
또 다른 일반적으로 사용되는 기술은 무작위 자르기(random cropping)입니다. 

31
00:01:47,035 --> 00:01:48,725
이 데이터 세트가 주어지면

32
00:01:48,725 --> 00:01:50,190
몇 가지 무작위 자를 크롭구역을 선택해 봅시다. 

33
00:01:50,190 --> 00:01:51,536
그래서 여러분은 그것을 골라 낼 수 있고,

34
00:01:51,536 --> 00:01:56,442
그 크롭을 가져 가거나, 그 크롭을 이 크롭에가져갈 수도 있고,

35
00:01:56,442 --> 00:01:59,460
이걸 취해서, 이 크롭을 취하고, 

36
00:01:59,460 --> 00:02:02,508
그러면 여러분의 데이터 세트의 다른 무작위 크롭인 

37
00:02:02,508 --> 00:02:04,350
트레이닝 샘플에 주기 위해 다른 예시들을 여러분에게 줄 것입니다. 

38
00:02:04,350 --> 00:02:08,310
그래서 무작위 크롭핑은 완벽한 데이터 증강이 아닙니다

39
00:02:08,310 --> 00:02:14,760
만약 여러분이 고양이 인것으로 보이는 이 크롭을 취하면 어떻게 될까요?

40
00:02:14,760 --> 00:02:18,110
하지만 실제로는 여러분의 무작위 크롭들이 

41
00:02:18,110 --> 00:02:21,920
실제 이미지의 합리적으로 커다란 부분이기만 하다면 가치가 있을것입니다. 

42
00:02:21,920 --> 00:02:26,700
따라서 미러링(mirroring)과 무작위 크롭(random cropping)가 자주 사용되며 

43
00:02:26,700 --> 00:02:29,580
이론적으로는 회전(rotation), 이미지 깎기와 같은 것을 . 

44
00:02:29,580 --> 00:02:31,086
사용할 수 있습니다.

45
00:02:31,086 --> 00:02:34,233
이렇게 이미지에 적용하고 

46
00:02:34,233 --> 00:02:35,883
왜곡 시키며 

47
00:02:35,883 --> 00:02:39,130
다양한 형태의 지엽적인 뒤틀림 등을 적용 할 수 있습니다.

48
00:02:39,130 --> 00:02:42,253
실제로이 모든 것들을 시도하는 데 아무런 해가 없습니다.

49
00:02:42,253 --> 00:02:45,805
실제로는 조금 덜 사용되거나 

50
00:02:45,805 --> 00:02:48,159
복잡성 때문에 사용되는 것처럼 보이기는 하지만,

51
00:02:48,159 --> 00:02:58,345
일반적으로 사용되는 데이터 증강의 두 번째 유형은 색상 이동입니다. 

52
00:02:58,345 --> 00:03:01,080
이와 같은 그림이 주어진다면 

53
00:03:01,080 --> 00:03:04,950
R, G 및 B 채널에

54
00:03:04,950 --> 00:03:09,783
다른 왜곡을 추가한다고 가정 해 봅시다. 

55
00:03:09,783 --> 00:03:12,260
이 예에서는 빨강 및 파랑 채널에 추가하고 

56
00:03:12,260 --> 00:03:16,410
녹색 채널에서 뺍니다. 

57
00:03:16,410 --> 00:03:20,320
그래서 빨강과 파랑이 보라색입니다. 

58
00:03:20,320 --> 00:03:23,360
이렇게하면 전체 이미지가 좀 더 보라색으로 변하게되어 

59
00:03:23,360 --> 00:03:27,080
트레이닝 세트에 왜곡된 이미지가 생성됩니다. 

60
00:03:27,080 --> 00:03:29,435
설명을 위해,

61
00:03:29,435 --> 00:03:32,775
색상과 연습에 약간의 변화를 주려고 하는데요, 

62
00:03:32,775 --> 00:03:39,720
매우 작을지도 모르는 이 분포로부터 R, G 및 B를 끌어와서 그릴 수 있습니다. 

63
00:03:39,720 --> 00:03:43,608
여러분이 할 일은 R,G,B의 다른 값들을 취하고

64
00:03:43,608 --> 00:03:46,410
색상 채널을 왜곡시키기 위해 사용하는 것입니다. 

65
00:03:46,410 --> 00:03:48,480
따라서, 두 번째 예에서는,

66
00:03:48,480 --> 00:03:50,695
빨간색이 적고 

67
00:03:50,695 --> 00:03:52,415
녹색과 파란색이 많아지면서, 

68
00:03:52,415 --> 00:03:57,109
이미지가 약간 노란 색으로 변합니다. 

69
00:03:57,109 --> 00:04:01,407
리고 여기, 우리는 훨씬 더 파랗게 만들고 있습니다

70
00:04:01,407 --> 00:04:03,155
조금 더 길게 만듭니다. 

71
00:04:03,155 --> 00:04:04,868
그러나 실제로, R, G, B 값은 

72
00:04:04,868 --> 00:04:09,465
어떤 확률 분포로부터 도출됩니다. 

73
00:04:09,465 --> 00:04:15,370
그리고 이것에 대한 동기는 아마 햇빛이 약간 노랗거나

74
00:04:15,370 --> 00:04:20,187
어쩌면 목표물 조명이 조금 더 노란색이라면,

75
00:04:20,187 --> 00:04:23,730
이미지의 색상을 쉽게 바꿀 수 있지만,

76
00:04:23,730 --> 00:04:27,745
고양이의 신원이나 내용의 정체성 , 

77
00:04:27,745 --> 00:04:30,840
레이블 y는 여전히 동일하게 유지됩니다.

78
00:04:30,840 --> 00:04:35,798
이러한 색상 왜곡을 적용하거나 색상 이동을 사용하면 

79
00:04:35,798 --> 00:04:46,435
학습 알고리즘이 이미지 색상의 변화에보다 강력해집니다. 

80
00:04:46,435 --> 00:04:54,880
이 강의를 듣는 고급 학습자들께 말씀을 덧붙이자면, 

81
00:04:54,880 --> 00:04:59,997
빨간색을 사용할 때 제가 이제 이야기 할 내용은 이해하지 못해도 괜찮습니다. 

82
00:04:59,997 --> 00:05:04,280
R, G 및 B를 샘플링하는 다양한 방법이 있습니다. 

83
00:05:04,280 --> 00:05:08,790
색상 왜곡을 구현하는 방법 중 하나는 PCA라는 알고리즘을 사용하는 것 입니다. 

84
00:05:08,790 --> 00:05:11,465
이것은 Principles Component Analysis라고 불리며, 

85
00:05:11,465 --> 00:05:14,345
제가 Coursera의 

86
00:05:14,345 --> 00:05:22,750
ml-class.org 머신 러닝(Machine Learning) 과정에서 말씀드렸었습니다. 

87
00:05:22,750 --> 00:05:29,080
그러나 이것에 대한 자세한 내용은 사실 AlexNet 논문에서 주어지며,	

88
00:05:29,080 --> 00:05:36,080
때로는 PCA 색상 증강 (PCA Color Augmentation)라고도합니다. 

89
00:05:36,080 --> 00:05:41,585
그러나 예를 들어 PCA 색상 증강의 대략적인 아이디어는

90
00:05:41,585 --> 00:05:44,160
이미지가 주로 자주색인 경우, 

91
00:05:44,160 --> 00:05:47,540
주로 빨간색과 파란색 색조가 있고 

92
00:05:47,540 --> 00:05:49,010
녹색은 거의 없습니다. 

93
00:05:49,010 --> 00:05:52,399
그러면 PCA 색상 증강으로 

94
00:05:52,399 --> 00:05:55,120
빨간색과 파란색으로 많이 추가 및 제거할 것입니다 

95
00:05:55,120 --> 00:05:56,510
이렇게 되면 모든 녹색과 균형을 이루기 때문에 

96
00:05:56,510 --> 00:06:01,770
색조의 전체 색상이 동일하게 유지됩니다. 

97
00:06:01,770 --> 00:06:05,390
이 점을 이해하지 못했다해도 걱정하지 마십시오. 

98
00:06:05,390 --> 00:06:09,677
그러나 온라인에서 검색하시면, 

99
00:06:09,677 --> 00:06:13,905
AlexNet 문서에서 자세한 내용을 읽고 싶으시다면, 

100
00:06:13,905 --> 00:06:18,500
PCA 색상 증강에 대한 오픈 소스 구현을 찾아서 사용할 수 있습니다.

101
00:06:18,500 --> 00:06:21,685
그리고 그걸 사용하시면 됩니다. 

102
00:06:21,685 --> 00:06:30,010
자, 트레이닝 데이터를 하드 디스크에 저장하고 

103
00:06:30,010 --> 00:06:33,705
이 둥근 버킷 기호를 사용하여 하드 디스크를 나타낼 수 있습니다. 

104
00:06:33,705 --> 00:06:36,000
그리고 작은 트레이닝 세트를 가지고 있다면, 

105
00:06:36,000 --> 00:06:38,336
여러분은 거의 모든 것을 할 수 있고, 잘 해내실 것입니다.

106
00:06:38,336 --> 00:06:42,785
하지만 마지막 훈련 세트는 사람들이 자주 구현하는 방법입니다. 

107
00:06:42,785 --> 00:06:52,705
즉, 하드 디스크의 이미지를 지속적으로 로드하는 CPU 스레드가 있을 수 있습니다. 

108
00:06:52,705 --> 00:07:00,235
따라서, 여러분은 하드 디스크에서 들어오는 이미지 스트림이 가지는 것입니다.

109
00:07:00,235 --> 00:07:08,535
그리고 여러분이 할 수 있는 일은 CPU 스레드를 사용하여 왜곡을 구현하는 것입니다. 

110
00:07:08,535 --> 00:07:11,000
무작위 크롭핑

111
00:07:11,000 --> 00:07:13,795
혹은 색상 이동 또는 미러링은 아직 안하고 있죠. 

112
00:07:13,795 --> 00:07:16,710
하지만 그래도 각 이미지에서 

113
00:07:16,710 --> 00:07:21,000
왜곡된 버전으로 끝낼 수 있습니다. 

114
00:07:21,000 --> 00:07:22,950
자,이 이미지를 보도록 하겠습니다. 

115
00:07:22,950 --> 00:07:28,310
이제 이것을 미러링 할 것입니다. 그리고 색상 왜곡 등도 구현할 수 있다면,

116
00:07:28,310 --> 00:07:35,120
그리고 이 이미지가 색이 바뀌면 

117
00:07:35,120 --> 00:07:41,470
결국 다른 색깔의 고양이로 끝납니다.

118
00:07:41,470 --> 00:07:48,395
따라서 CPU 스레드는 배치 (batch) 또는 실제로 많은 데이터 배치를 만드는 데 왜곡이 필요한지 여부를

119
00:07:48,395 --> 00:07:56,810
실행 뿐 아니라 데이터를 지속적으로 로드합니다. 

120
00:07:56,810 --> 00:08:05,045
그리고 이 데이터는 훈련을 실행하기 위해 다른 스레드 나 다른 프로세스로 끊임없이 전달되며,

121
00:08:05,045 --> 00:08:08,815
훈련을 위한 대규모 신경망이 있는 경우는 

122
00:08:08,815 --> 00:08:14,075
CPU 또는 많이 증가하고 있는 GPU에서 수행 할 수 있습니다. 

123
00:08:14,075 --> 00:08:17,710
따라서 데이터 증강을 구현하는 꽤 일반적인 방법은

124
00:08:17,710 --> 00:08:22,235
데이터를 로딩하고 

125
00:08:22,235 --> 00:08:26,540
왜곡을 실행하는 역할을 하는 하나의 스레드, 

126
00:08:26,540 --> 00:08:30,635
거의 네 개의 스레드를 가지는 것입니다.

127
00:08:30,635 --> 00:08:32,840
그리고 나서, 다른 스레드나 

128
00:08:32,840 --> 00:08:35,935
다른 해당 프로세스를 전달해서 트레이닝을 하는 것입니다 .

129
00:08:35,935 --> 00:08:38,435
그리고 종종 이것과 이것은

130
00:08:38,435 --> 00:08:39,650
병렬로 실행될 수 있습니다. 

131
00:08:39,650 --> 00:08:46,121
데이터 확장을 위한 것이죠. 

132
00:08:46,121 --> 00:08:49,970
그리고 심층 신경망을 훈련하는 다른 부분과 마찬가지로 

133
00:08:49,970 --> 00:08:55,250
데이터 증강 과정은 몇 개의 하이퍼 파라미터를 가지고 있습니다 예를 들어 

134
00:08:55,250 --> 00:09:00,965
어떻게 색상 이동을 실행할 것인지, 무작위 크롭핑에는 정확히 어떤 파라미터를 사용하는지와 같은 것들입니다. 

135
00:09:00,965 --> 00:09:03,500
따라서 컴퓨터 비전의 다른 곳과 마찬가지로,

136
00:09:03,500 --> 00:09:06,335
시작하기 좋은 곳은 다른 사람들이 데이터 증강을 어떻게 사용하는지 보기위해 

137
00:09:06,335 --> 00:09:10,920
다른 사람의 오픈 소스 도구를 사용하는 것입니다. 

138
00:09:10,920 --> 00:09:15,640
하지만 물론, 분산을 더 많이 포착하고 싶고, 

139
00:09:15,640 --> 00:09:19,235
다른 사람의 오픈 소스 도구는 그렇지 않다고 생각한다면,

140
00:09:19,235 --> 00:09:24,230
스스로 하이퍼 파라미터를 사용하는 것이 합리적 일 수 있습니다. 

141
00:09:24,230 --> 00:09:27,980
이렇게 컴퓨터 시각 응용 프로그램이 더 잘 작동하도록 

142
00:09:27,980 --> 00:09:31,250
데이터 증강 기능을 사용하시기를 바랍니다.