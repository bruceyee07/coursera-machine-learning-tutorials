1
00:00:00,270 --> 00:00:04,351
여러분은 컨볼네트에 대해 많은 것을 배웠습니다.

2
00:00:04,351 --> 00:00:08,888
컨볼네트의 아키텍처부터 이미지 인식,

3
00:00:08,888 --> 00:00:13,590
객체 감지, 얼굴 인식 및 신경 스타일 변형에 이르기까지 모든 것을 배웠습니다.

4
00:00:13,590 --> 00:00:17,626
그리고 비록 대부분의 논의가 2D 같은 이미지에 초점을 맞추고 있지만

5
00:00:17,626 --> 00:00:21,205
이미지들은 아주 널리 보급되어 있어서,

6
00:00:21,205 --> 00:00:26,135
많은 아이디어가 2D 이미지 만이 아니라,

7
00:00:26,135 --> 00:00:30,640
3D 데이터나 1D 데이터에도 적용됩니다. 한 번 보시죠.

8
00:00:30,640 --> 00:00:33,048
한번 자세히 살펴볼까요.

9
00:00:33,048 --> 00:00:38,506
이 과정의 첫 번째 주에는 2D 컨볼루션에 대해 배웠습니다.

10
00:00:38,506 --> 00:00:44,340
14 x 14 이미지를 인풋하고 5 x 5 필터로 컨볼빙 하는 것이었죠.

11
00:00:44,340 --> 00:00:49,097
그리고 14 x 14 가 5 x 5 와 어떻게 컨벌브 되어 있는지를 보았을 때

12
00:00:49,097 --> 00:00:52,590
10 x 10 출력을 얻을 수 있었습니다.

13
00:00:52,590 --> 00:00:58,662
여러 채널이 있는 경우, 어쩌면 14 x 14 x 3

14
00:00:58,662 --> 00:01:03,170
이것은 5 x 5 이고, 똑같이 3 을 매치 시켰죠.

15
00:01:03,170 --> 00:01:08,460
그리고 나면 여러 개의 필터가 생기는데, 즉 16개 필터가 되고, 최종적으로 10 x 10 x 16이 됩니다.

16
00:01:08,460 --> 00:01:14,430
이와 비슷한 개념으로 1D 데이터에도 적용됩니다.

17
00:01:14,430 --> 00:01:21,328
예를 들어, 왼쪽에는 심전도라고도 하는 심전도 신호가 있습니다.

18
00:01:21,328 --> 00:01:25,577
기본적으로 가슴 위에 전극을 놓으면

19
00:01:25,577 --> 00:01:29,910
심장 박동에 따라 가슴에 위에서 달라지는 작은 전압을 측정합니다.

20
00:01:29,910 --> 00:01:34,562
심장 박동에 의해 생성 된 작은 전기파는.

21
00:01:34,562 --> 00:01:36,823
한 쌍의 전극으로 측정 할 수 있기 때문에

22
00:01:36,823 --> 00:01:40,490
그래서 이것은 누군가의 심장이 뛰는, EKG 즉 심전도입니다.

23
00:01:40,490 --> 00:01:45,930
그래서 이 봉우리들 각각은 하나의 심장 박동에 해당합니다.

24
00:01:45,930 --> 00:01:49,970
만약 EKG 신호를 사용하여 의료 진단을 하고 싶다면

25
00:01:49,970 --> 00:01:55,062
예를 들어, 여러분은 1D 데이타를 가지게 될 것입니다.

26
00:01:55,062 --> 00:02:01,610
왜냐하면 EKG는 각 순간의 전압을 보여주는 시계열의기 때문입니다.

27
00:02:01,610 --> 00:02:04,500
따라서 14 x 14 차원 인풋이 아닌

28
00:02:04,500 --> 00:02:08,160
14 차원 인풋 만 있을 수 있습니다.

29
00:02:08,160 --> 00:02:11,770
그리고 이 경우, 1 차원 필터를 사용하여 이를 컨볼루션 할 수 있습니다.

30
00:02:11,770 --> 00:02:16,420
따라서 5 x 5가 아닌 5 차원 필터 만 있으면 됩니다.

31
00:02:16,420 --> 00:02:21,481
따라서 2D 데이터를 사용하면, 컨볼루션 통해 동일한 5 x 5 피쳐 검출기를 사용하여

32
00:02:21,481 --> 00:02:26,950
이미지 전체의 여러 위치에 이것을 적용 할 수 있습니다.

33
00:02:26,950 --> 00:02:31,110
이것이 10 x 10 출력을 얻는 방법입니다.

34
00:02:31,110 --> 00:02:36,258
1D 필터로 할 수 있는 것은 5 차원 필터를 사용하고

35
00:02:36,258 --> 00:02:42,860
이 1D 신호를 통해 여러 다른 위치에서 유사하게 적용하는 것입니다.

36
00:02:42,860 --> 00:02:45,510
그리고 만약 여러분이 이 컨볼루션을 적용한다면,

37
00:02:45,510 --> 00:02:50,270
여러분이 이 14차원의 것이 5 차원의 것으로 컨벌브 되어

38
00:02:50,270 --> 00:02:55,370
10 차원 아웃풋을 제공할 것입니다.

39
00:02:55,370 --> 00:03:00,496
다시 말하지만, 여러 개의 채널이 있는 경우, 이 경우는

40
00:03:00,496 --> 00:03:06,381
채널 1개만 사용할 수 있죠. EKG는 한 개의 전극만 있으니까요, 따라서 5 x 1 이죠. .

41
00:03:06,381 --> 00:03:12,468
필터가 16 개인 경우, 결국 거기에 10 x 16이 있고

42
00:03:12,468 --> 00:03:16,300
이것은 컨볼네트의 한 층이 될 수 있습니다.

43
00:03:16,300 --> 00:03:20,257
그리고 컨볼네트의 다음 레이어에 대해, 10 x 16 차원 인풋을 입력하면

44
00:03:20,257 --> 00:03:25,560
5 차원 필터로 다시 컨벌루션 할 수 있습니다.

45
00:03:25,560 --> 00:03:29,583
그렇다면 여기에는 16 개의 채널이 있으므로, 일치하는 채널이 있습니다.

46
00:03:29,583 --> 00:03:34,585
32 개의 필터가 있는 경우, 다른 레이어의 출력은 6 x 32입니다.

47
00:03:34,585 --> 00:03:39,190
필터가 32 개이죠, 그렇죠?

48
00:03:39,190 --> 00:03:42,268
그리고 2D 데이터와 유사하게,

49
00:03:42,268 --> 00:03:46,779
이것은 10 x 10 x 16 데이터와 비슷하며.

50
00:03:46,779 --> 00:03:51,860
5 x 5 x 16으로 컨벌브 합니다, 그러면 일치하는 것이 생기죠.

51
00:03:51,860 --> 00:03:54,568
그러면 6 x 6 차원 출력이 나오며

52
00:03:54,568 --> 00:03:58,080
32 개의 필터가 있습니다. 이것이 32 개의 필터가 만들어지는 곳이죠.

53
00:03:58,080 --> 00:04:03,567
따라서 이러한 모든 아이디어는 1D 데이터에도 적용됩니다.

54
00:04:03,567 --> 00:04:08,884
여기에서 이와 같은 동일한 기능 감지기를 다양한 위치에 적용 할 수 있습니다.

55
00:04:08,884 --> 00:04:13,430
예를 들어 심전도 신호에서 다른 심 박동을 감지합니다.

56
00:04:13,430 --> 00:04:18,505
그러나 이 시계 열을 따라 다른 위치에서도 심 박동을 감지하기 위해 동일한 피처 세트를 사용하여

57
00:04:18,505 --> 00:04:23,836
1D 데이터에서도 컨볼네트를 사용할 수 있습니다.

58
00:04:23,836 --> 00:04:28,501
1D 데이터 응용 프로그램과 함께, 여러분은 실제로 recurrent neural network를 사용하는데,

59
00:04:28,501 --> 00:04:30,790
이것은 다음 과정에서 배우게 됩니다.

60
00:04:30,790 --> 00:04:36,520
그러나 어떤 사람들은 이러한 문제에서 컨볼네트들을 사용해 볼 수도 있습니다.

61
00:04:36,520 --> 00:04:39,990
다음 과정에서는, 시퀀스 모델 상에서,

62
00:04:39,990 --> 00:04:43,310
recurring neural network과 LCM, 그리고 이런 다른 모델들에 대해서 이야기하도록 하겠습니다.

63
00:04:43,310 --> 00:04:47,545
우리는 1D 컨볼네트 과 순차적 데이터에 따라 명시적으로 설계된 다른 모델을

64
00:04:47,545 --> 00:04:51,070
사용하는 것에 대한 장단점에 대해 이야기 할 것입니다.

65
00:04:51,070 --> 00:04:54,290
이것이 2D에서 1D 로의 일반화입니다.

66
00:04:54,290 --> 00:04:56,510
3D 데이터는 어떻습니까?

67
00:04:56,510 --> 00:04:58,900
3 차원 데이터 란 무엇입니까?

68
00:04:58,900 --> 00:05:04,720
1D 숫자 목록이나 2D 행렬 대신에.

69
00:05:04,720 --> 00:05:11,060
3 차원 인풋 볼륨 인 3D 블록이 있습니다

70
00:05:11,060 --> 00:05:15,123
여기에 CT 스캔을 하는 경우의 예가 있습니다.

71
00:05:15,123 --> 00:05:20,510
이것은 신체의 3 차원 모델을 제공하는 X-ray 스캔 유형입니다.

72
00:05:20,510 --> 00:05:24,746
그러나 CT 스캔 이하는 일은 신체를 통해 다른 조각을 필요로 한다는 것입니다.

73
00:05:24,746 --> 00:05:28,465
그래서 제가 여기서 하고 있는 CT 스캔을 통해 스캔 할 때,

74
00:05:28,465 --> 00:05:33,507
여러분은 인간의 몸통의 다른 슬라이스들이 어떻게 보이는지 볼 수 있습니다.

75
00:05:33,507 --> 00:05:37,090
그래서이 데이터는 근본적으로 3 차원 입니다

76
00:05:37,090 --> 00:05:43,039
이 데이터를 생각하는 한 가지 방법은

77
00:05:43,039 --> 00:05:46,558
데이터의 높이, 폭, 깊이가 같은지 여부입니다.

78
00:05:46,558 --> 00:05:50,359
이것이 이 볼륨을 통과하는 다른 슬라이스

79
00:05:50,359 --> 00:05:53,840
몸을 통과하는 다른 슬라이스입니다.

80
00:05:53,840 --> 00:05:57,660
따라서 컨볼네트을 적용하여 이 3 차원 CAT 스캔 또는 CT 스캔에서 피쳐를 감지하려는 경우

81
00:05:57,660 --> 00:06:02,470
첫 번째 슬라이드의 아이디어를

82
00:06:02,470 --> 00:06:07,020
3 차원 컨볼루션으로 일반화 할 수 있습니다.

83
00:06:07,020 --> 00:06:10,356
따라서 3D 볼륨이 있는 경우

84
00:06:10,356 --> 00:06:15,764
단순화를 위해 14 x 14 x 14 로,

85
00:06:15,764 --> 00:06:21,770
즉, 인풋 CT 스캔의 높이, 너비 및 깊이를 말합니다.

86
00:06:21,770 --> 00:06:25,735
다시 말하지만 이미지와 마찬가지로 모든 요소가 정사각형이어야 하며

87
00:06:25,735 --> 00:06:29,450
3D 볼륨은 완벽한 큐브 일 필요는 없습니다

88
00:06:29,450 --> 00:06:32,210
따라서 이미지의 높이와 너비는 달라질 수 있으며

89
00:06:32,210 --> 00:06:36,118
같은 방식으로, CT 스캔의 높이와 너비 및 깊이가 다를 수 있습니다.

90
00:06:36,118 --> 00:06:40,560
하지만 여기서 토론을 단순화 시키기 위해, 14 x 14 x 14를 사용하고 있습니다. .

91
00:06:40,560 --> 00:06:45,849
그리고 이것을 5 x 5 x 5 필터로 바꾸면

92
00:06:45,849 --> 00:06:50,788
이제 필터가 3 차원이어서

93
00:06:50,788 --> 00:06:55,863
10 x 10 x 10 볼륨이 됩니다.

94
00:06:55,863 --> 00:07:01,366
기술적으로, 채널 수인 경우 1을 사용할 수도 있습니다.

95
00:07:01,366 --> 00:07:06,715
따라서 이것은 3D 볼륨 일 뿐이지만 데이터의 채널 수에 차이가 있을 수 있습니다.

96
00:07:06,715 --> 00:07:11,489
그러면 1도 마찬가지입니다.

97
00:07:11,489 --> 00:07:17,472
여기 채널 수와 여기 채널 수가 일치해야 하기 때문입니다.

98
00:07:17,472 --> 00:07:22,371
그리고 나서 16 개의 필터가 있다면 5 x 5 x 5 x 1이되고

99
00:07:22,371 --> 00:07:24,790
다음 출력은 10 x 10 x 10 x 16이 될 것입니다.

100
00:07:24,790 --> 00:07:30,129
따라서 이것은 컨볼네트의 3D 데이터에 대한 하나의 레이어가 될 수 있습니다.

101
00:07:30,129 --> 00:07:36,660
컨볼네트은 5 x 5 x 5 x 16 차원 필터로 다시 컨벌브 시킵니다.

102
00:07:36,660 --> 00:07:40,666
따라서 이 채널 수는 평소처럼 데이터와 일치해야하며

103
00:07:40,666 --> 00:07:46,190
32 개의 필터가 있는 경우. 여러분이 보았던 컨볼네트 이미지와 유사합니다.

104
00:07:46,190 --> 00:07:54,350
그러면 6 x 6 x 6볼륨이 32채널을 가로지르게 됩니다.

105
00:07:54,350 --> 00:07:57,992
3D 데이터는

106
00:07:57,992 --> 00:08:02,020
또한 3차원 컨볼네트를 사용하여 직접 학습할 수 있습니다.

107
00:08:02,020 --> 00:08:07,500
이러한 필터가 수행하는 작업은 실제로 3D 데이터, 즉,

108
00:08:08,730 --> 00:08:13,180
CAT 스캔, 3D 스캔의 한 예시인 의학 스캔, 이것들을 가로질러 피쳐를 감지하는 것 입니다.

109
00:08:13,180 --> 00:08:18,450
그러나 3D 볼륨으로 처리할 수 있는 또 다른 데이터 예시는 바로 영화 데이터입니다.

110
00:08:18,450 --> 00:08:23,410
다른 슬라이스는 영화를 통해 서로 다른 조각이 될 수 있습니다.

111
00:08:23,410 --> 00:08:28,171
그리고 이것을 사용하여 모션이나 영화에서 행동을 취하는 사람들을 감지 할 수 있습니다.

112
00:08:28,171 --> 00:08:31,868
2D 데이터에서 3D 데이터뿐만 아니라 1D까지

113
00:08:31,868 --> 00:08:35,520
컨볼네트의 일반화에 관한 내용이었습니다.

114
00:08:35,520 --> 00:08:40,395
이미지 데이터가 널리 보급되어 컨볼네트의 대다수가 이미지 데이터의 2D 데이터에 있지만,

115
00:08:40,395 --> 00:08:45,420
이 다른 모델들도 여러분에게 도움이 되기를 바랍니다.

116
00:08:45,420 --> 00:08:48,588
여기까지입니다. 그리고 이것이 이번 주의 마지막 동영상이자,

117
00:08:48,588 --> 00:08:51,570
컨볼네트에 관한 이 강의의 마지막 동영상입니다.

118
00:08:51,570 --> 00:08:53,810
여러분은 컨볼네트에 대해 많은 것을 배웠고

119
00:08:53,810 --> 00:08:58,380
여러분의 많은 아이디어가 미래의 작업을 위해 유용하게 사용되기를 바랍니다.

120
00:08:58,380 --> 00:09:01,600
이 강의를 끝내는 걸 축하 드리고,

121
00:09:01,600 --> 00:09:04,150
이번 주 연습문제들도 즐겁게 해 주셨으면 좋겠습니다.

122
00:09:04,150 --> 00:09:07,850
다음 sequence model(시퀀스 모델)에 관한 다음 과정에서 여러분을 만날 것을 기대하겠습니다.