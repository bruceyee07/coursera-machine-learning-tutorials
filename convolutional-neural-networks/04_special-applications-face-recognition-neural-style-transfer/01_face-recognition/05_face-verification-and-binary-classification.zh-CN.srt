1
00:00:00,000 --> 00:00:02,580
Triplet Loss是一种学习

2
00:00:02,580 --> 00:00:05,950
用于人脸识别的ConvNet的参数的好办法

3
00:00:05,950 --> 00:00:08,490
还有一种方法可以用来学习这些参数

4
00:00:08,490 --> 00:00:11,475
让我来给你们展示下如何将人脸识别

5
00:00:11,475 --> 00:00:15,175
当做一种直接的二元分类问题

6
00:00:15,175 --> 00:00:17,085
另一种训练神经网络的方法

7
00:00:17,085 --> 00:00:19,740
是利用这一对神经网络

8
00:00:19,740 --> 00:00:25,260
这个Siamese网络让他们都计算这些embeddings

9
00:00:25,260 --> 00:00:27,255
可能有128维的embeddings

10
00:00:27,255 --> 00:00:28,770
也许有更高的维度

11
00:00:28,770 --> 00:00:31,530
然后将这些输入到

12
00:00:31,530 --> 00:00:36,375
一个逻辑回归单元后做出预测

13
00:00:36,375 --> 00:00:42,705
如果这两个是同一个人,目标结果将会输出1

14
00:00:42,705 --> 00:00:46,530
如果是两个不同的人,结果将会输出0

15
00:00:46,530 --> 00:00:52,960
所以，这是一种将人脸识别当做二元分类的方法

16
00:00:52,960 --> 00:00:58,890
训练一个这样的系统是triplet loss的替代方案

17
00:00:58,890 --> 00:01:03,405
那么，什么是这个最终的逻辑回归单元真正在做的呢？

18
00:01:03,405 --> 00:01:08,400
这个输出y帽，假设是一个

19
00:01:08,400 --> 00:01:12,750
被用于一系列的特征的sigmoid function

20
00:01:12,750 --> 00:01:18,690
这里，我们并不是要将数据直接输入，你所能做的是计算这些编码之间的不同

21
00:01:18,690 --> 00:01:20,795
让我来告诉你，我是什么意思

22
00:01:20,795 --> 00:01:30,020
举个例子，我写一个求和，

23
00:01:30,020 --> 00:01:35,525
分别对两个编码，按元素地计算K从1到128的绝对值之和

24
00:01:35,525 --> 00:01:39,930
让我将这个写完然后我们就会看到这意味着什么

25
00:01:39,930 --> 00:01:45,335
在这个表达式中，f（xi）是图像xi的编码

26
00:01:45,335 --> 00:01:52,210
下标k表示这个向量的第k个元素

27
00:01:52,210 --> 00:01:59,625
这个就是将这两种不同编码之间的逐个元素的差的绝对值的和

28
00:01:59,625 --> 00:02:03,240
你可以将这128个数字想象为

29
00:02:03,240 --> 00:02:07,140
你输入到逻辑回归中的特征

30
00:02:07,140 --> 00:02:11,350
你将会发现逻辑回归会有额外的变量wi

31
00:02:11,350 --> 00:02:16,030
以及b，就像正常的逻辑回归单元一样

32
00:02:16,030 --> 00:02:21,990
然后你将会在这128个特征上训练出恰当的权重

33
00:02:21,990 --> 00:02:24,105
用来判断这两张图片

34
00:02:24,105 --> 00:02:28,225
是同一个人还是不同的人

35
00:02:28,225 --> 00:02:31,035
所以，这将会是一种十分合理的方式

36
00:02:31,035 --> 00:02:37,300
用来学会预测0或1，来表示这些图片是同一个人的还是不同的人的

37
00:02:37,300 --> 00:02:40,230
还有其他一些变种，你可以用来

38
00:02:40,230 --> 00:02:44,220
计算我画了绿线的这个公式

39
00:02:44,220 --> 00:02:51,405
例如，另一种公式是这样的f（xi）k-f（xj）k

40
00:02:51,405 --> 00:02:56,220
取平方根，然后再除以

41
00:02:56,220 --> 00:03:02,980
f（xi）k+f（xj）k.这有时也被称为chi square公式

42
00:03:02,980 --> 00:03:05,700
这是希腊字母chi

43
00:03:05,700 --> 00:03:08,874
这有时也被叫做chi square相似度

44
00:03:08,874 --> 00:03:15,810
这是在这篇DeepFace论文中所给出的另一种公式变种

45
00:03:15,810 --> 00:03:18,015
我在之前也提到过这篇文章

46
00:03:18,015 --> 00:03:20,760
在这个学习框架中

47
00:03:20,760 --> 00:03:23,801
输入是一对图片

48
00:03:23,801 --> 00:03:28,920
这是你的训练输入x，输出y

49
00:03:28,920 --> 00:03:32,085
是0或者1，取决于你的输入

50
00:03:32,085 --> 00:03:35,680
是一对相同的照片还是不同的照片

51
00:03:35,680 --> 00:03:37,070
就像之前那样

52
00:03:37,070 --> 00:03:40,065
你所在训练的是Siamese Network，这意味着

53
00:03:40,065 --> 00:03:44,035
上面这个神经网络的参数和下面

54
00:03:44,035 --> 00:03:48,455
这个神经网络的参数是相同的或者说是紧紧捆绑在一起

55
00:03:48,455 --> 00:03:52,235
这个系统依然可以工作得非常好

56
00:03:52,235 --> 00:03:53,420
最后，顺带提一下的是

57
00:03:53,420 --> 00:03:58,905
一个计算方面的小技巧，可以极大地帮助你实现神经网络

58
00:03:58,905 --> 00:04:00,375
假设这是新的图片

59
00:04:00,375 --> 00:04:03,910
这是一个正在走进来的员工，他希望这个十字转门

60
00:04:03,910 --> 00:04:08,815
将会为他而打开，这是一张来自你数据库里的图片

61
00:04:08,815 --> 00:04:11,190
你并不需要每次都计算

62
00:04:11,190 --> 00:04:17,520
这个embedding

63
00:04:17,520 --> 00:04:20,970
你可以预先计算出它

64
00:04:20,970 --> 00:04:22,970
所以当新的员工走入时

65
00:04:22,970 --> 00:04:29,500
你所要做的就是用上面这个卷积神经网络来计算出编码，然后用它

66
00:04:29,500 --> 00:04:31,020
与你之前计算出的编码

67
00:04:31,020 --> 00:04:36,730
进行比较，然后计算出预测结果y帽

68
00:04:36,730 --> 00:04:40,770
由于你并不需要存储原始的图像

69
00:04:40,770 --> 00:04:44,880
并且假如你拥有一个非常大的员工数据库

70
00:04:44,880 --> 00:04:50,935
你并不需要每次都为每一个在你数据库中的员工计算出编码

71
00:04:50,935 --> 00:04:52,980
这就是预计算的概念

72
00:04:52,980 --> 00:04:56,880
其中一些编码可以节约相当大的计算量

73
00:04:56,880 --> 00:05:00,775
这种预计算的方法适用于

74
00:05:00,775 --> 00:05:02,950
你可以把人脸识别当做

75
00:05:02,950 --> 00:05:07,485
一个二元分类问题的基于Siamese网络架构的方法

76
00:05:07,485 --> 00:05:11,160
也适用于你通过Triplet Loss函数

77
00:05:11,160 --> 00:05:15,070
来学习编码，就像在之前的在几个视频中所描述的那样

78
00:05:15,070 --> 00:05:16,760
所以，让我们来总结下

79
00:05:16,760 --> 00:05:19,530
将人脸验证当做一个监督学习的问题

80
00:05:19,530 --> 00:05:23,460
你创建了一个包含多对图片的训练集

81
00:05:23,460 --> 00:05:28,045
当目标标识是1时

82
00:05:28,045 --> 00:05:34,366
意味着这一对图片来自同一个人，当目标标识是0时

83
00:05:34,366 --> 00:05:38,880
意味着这一对图片来自不同的人.然后你用反向传播

84
00:05:38,880 --> 00:05:40,845
不同的图片对来训练

85
00:05:40,845 --> 00:05:45,660
来训练神经网络，来训练Siamese网络

86
00:05:45,660 --> 00:05:49,755
这样，你刚才所看到的就是将人脸验证

87
00:05:49,755 --> 00:05:53,918
以及人脸识别当做二元分类问题的方法

88
00:05:53,918 --> 00:05:55,645
这种方法也能够实现非常好的效果

89
00:05:55,645 --> 00:05:57,645
所以，我希望你现在能够知道

90
00:05:57,645 --> 00:05:59,490
要训练你自己的人脸验证系统

91
00:05:59,490 --> 00:06:05,000
或者人脸识别系统你可以怎样做One-shot learning