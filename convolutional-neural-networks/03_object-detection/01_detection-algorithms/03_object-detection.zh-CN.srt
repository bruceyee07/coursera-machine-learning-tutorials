1
00:00:00,000 --> 00:00:05,695
你已经了解了目标定位和地标（特征点）检测

2
00:00:05,695 --> 00:00:09,470
现在让我们来开始搭建一个目标检测算法

3
00:00:09,470 --> 00:00:13,005
在这节视频中，你将会学习如何用一个<br />卷积神经网络(ConvNet)

4
00:00:13,005 --> 00:00:18,150
和滑动窗口(sliding windows)检测的算法进行目标检测

5
00:00:18,150 --> 00:00:21,154
假设你想搭建一个汽车检测算法

6
00:00:21,154 --> 00:00:22,315
你可以这样做

7
00:00:22,315 --> 00:00:24,734
你可以先创建一个有标记的训练数据集，X和对应的y

8
00:00:24,734 --> 00:00:29,100
训练集中包含紧密剪裁的汽车样例

9
00:00:29,100 --> 00:00:32,970
比如说，这张图像X是一个正类(是汽车)的样例

10
00:00:32,970 --> 00:00:35,140
这是一辆车，这也是一辆车

11
00:00:35,140 --> 00:00:37,755
这不是一辆车，这也不是一辆车

12
00:00:37,755 --> 00:00:39,840
考虑到我们这个训练集的目的

13
00:00:39,840 --> 00:00:43,733
你可以用紧密剪裁的汽车图像

14
00:00:43,733 --> 00:00:47,365
也就是说X(图像中)基本上只包含车

15
00:00:47,365 --> 00:00:49,650
你可以拍一张照片

16
00:00:49,650 --> 00:00:52,340
把其余不是车的部分全部剪裁掉

17
00:00:52,340 --> 00:00:57,450
然后得到一张汽车居中并占几乎全部画面的图像

18
00:00:57,450 --> 00:01:01,090
有了这个有标记的训练数据集

19
00:01:01,090 --> 00:01:05,412
你就可以训练一个卷积神经网络

20
00:01:05,412 --> 00:01:07,977
输入一张紧密剪裁的图像

21
00:01:07,977 --> 00:01:12,135
然后卷积神经网络负责输出y

22
00:01:12,135 --> 00:01:15,090
1或0，是或不是车

23
00:01:15,090 --> 00:01:17,044
当你训练好了这个卷积神经网络之后

24
00:01:17,044 --> 00:01:20,515
你就可以把它用在滑动窗口检测中了

25
00:01:20,515 --> 00:01:21,870
具体方法是

26
00:01:21,870 --> 00:01:25,560
如果你有一张这样的测试图像，你要做的是

27
00:01:25,560 --> 00:01:29,625
先选择一个如图所示的窗口尺寸

28
00:01:29,625 --> 00:01:35,070
然后将一个小的矩形窗口(的图像)<br />输入到这个卷积神经网络中

29
00:01:35,070 --> 00:01:38,670
也就是说，只取这个小的红色框内(的图像)

30
00:01:38,670 --> 00:01:41,235
把它输入到卷积神经网络中

31
00:01:41,235 --> 00:01:43,020
然后让卷积神经网络做一个预测

32
00:01:43,020 --> 00:01:47,215
假设对于（图中左上角）那个红色小框的区域

33
00:01:47,215 --> 00:01:50,640
它会说那个红色小框里没有车

34
00:01:50,640 --> 00:01:52,310
在滑动窗口检测算法中

35
00:01:52,310 --> 00:01:56,900
你然后要做的是输入

36
00:01:56,900 --> 00:02:00,000
传递第二个图像作为输入

37
00:02:00,000 --> 00:02:03,970
把这个移动了一点的红色小框范围内的图像<br />输入卷积神经网络

38
00:02:03,970 --> 00:02:06,715
也就是说你只输入这个红色框区域内的图像

39
00:02:06,715 --> 00:02:10,665
到卷积神经网络中，再运行一遍卷积神经网络

40
00:02:10,665 --> 00:02:16,275
然后再用第三个图像做同样的工作

41
00:02:16,275 --> 00:02:23,415
一直继续，直到你滑动窗口遍历了图像中的所有位置

42
00:02:23,415 --> 00:02:28,975
我这里用了一个比较大的滑动步长(stride) <br />只为了让来让动画更快

43
00:02:28,975 --> 00:02:34,700
但是基本思路是
遍历所有这个(红色窗口)尺寸的图像区域

44
00:02:34,700 --> 00:02:38,460
将这些小的裁剪出来的图像

45
00:02:38,460 --> 00:02:45,125
传递到卷积神经网络中 <br />然后将一定步长下每个位置(的图像)分类为0或1

46
00:02:45,125 --> 00:02:47,085
现在，遍历完一次

47
00:02:47,085 --> 00:02:54,230
用这个称为“滑动窗口”，遍历完图像之后

48
00:02:54,230 --> 00:02:55,295
你再重复一次

49
00:02:55,295 --> 00:02:57,710
不过这次用更大的窗口口

50
00:02:57,710 --> 00:03:02,191
也就是说现在你取一个稍微大一点的区域

51
00:03:02,191 --> 00:03:06,440
根据卷积神经网络的要求调整这个区域的大小

52
00:03:06,440 --> 00:03:10,235
然后把它输入到卷积神经网络中

53
00:03:10,235 --> 00:03:15,305
把这个窗口在一定步长下继续滑动

54
00:03:15,305 --> 00:03:20,500
遍历整个图像

55
00:03:20,500 --> 00:03:26,283
然后你可以用更大的窗口再执行第三次

56
00:03:26,283 --> 00:03:29,738
我们的期望是，如果这么做

57
00:03:29,738 --> 00:03:36,080
只要图像中某处有一辆车，就会有某个窗口

58
00:03:36,080 --> 00:03:40,200
比如说你输入这个窗口区域里的图像

59
00:03:40,200 --> 00:03:44,890
我们希望卷积神经网络会输出1

60
00:03:44,890 --> 00:03:47,825
这样你就检测到了这里有一辆车

61
00:03:47,825 --> 00:03:52,895
这个算法之所以被称为滑动窗口检测，是因为你把这些窗口

62
00:03:52,895 --> 00:03:58,745
这些正方形边框，在一定步长下滑过整个图像

63
00:03:58,745 --> 00:04:05,770
然后判定每个方框内的区域是否含有车

64
00:04:05,770 --> 00:04:10,055
不过，滑动窗口检测有一个很大的缺点

65
00:04:10,055 --> 00:04:12,704
就是它的计算成本

66
00:04:12,704 --> 00:04:16,460
因为你裁剪出了很多不同的正方形的图像

67
00:04:16,460 --> 00:04:21,370
并让每个图像都单独通过卷积神经网络的运算

68
00:04:21,370 --> 00:04:24,505
如果你使用了一个不密集的步长

69
00:04:24,505 --> 00:04:26,745
一个很大的步长，一个很大的步幅

70
00:04:26,745 --> 00:04:31,598
那么通过卷积神经网络的窗口数量会减少

71
00:04:31,598 --> 00:04:35,810
但是比较粗糙的颗粒度会影响算法表现

72
00:04:35,810 --> 00:04:39,630
而如果你用了比较精细的颗粒度，也就是很小的步长

73
00:04:39,630 --> 00:04:44,005
那么这些小区域的数量会巨大

74
00:04:44,005 --> 00:04:48,995
将他们全部通过卷积神经网络意味着很高的计算成本

75
00:04:48,995 --> 00:04:54,180
因此，在神经网络兴起之前，人们常用更简单的分类器

76
00:04:54,180 --> 00:04:56,910
把一个简单的线性分类器

77
00:04:56,910 --> 00:05:00,450
运用在手动设计的特征上进行目标检测

78
00:05:00,450 --> 00:05:04,870
而且在那个时代，因为每个分类器的计算成本都相对较低

79
00:05:04,870 --> 00:05:06,480
只是一个线性方程

80
00:05:06,480 --> 00:05:08,980
滑动窗口检测是可行的

81
00:05:08,980 --> 00:05:10,395
不是一个差方法

82
00:05:10,395 --> 00:05:15,450
但是卷积神经网络运行一次分类任务的代价更高

83
00:05:15,450 --> 00:05:21,125
这样的滑动窗口检测慢得不可行

84
00:05:21,125 --> 00:05:26,305
而且除非你用很精细的颗粒度，也就是很小的步长

85
00:05:26,305 --> 00:05:32,850
你最终很难在图像中精确地定位到目标

86
00:05:32,850 --> 00:05:38,575
幸运的是，这个计算成本的问题有一个很好的解决方案

87
00:05:38,575 --> 00:05:41,845
更确切地说，滑动窗口目标检测器

88
00:05:41,845 --> 00:05:45,935
可以用卷积的形式(convolutionally)来更高效地实现

89
00:05:45,935 --> 00:05:48,310
让我们在下一节视频中看看如何做到