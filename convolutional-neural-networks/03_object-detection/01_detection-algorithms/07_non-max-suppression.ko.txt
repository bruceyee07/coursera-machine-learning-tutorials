지금까지 이것에 대해 배웠던 객체 탐지의 문제점 중 하나는 알고리즘이 동일한 객체에 대해 다수의 탐지 체를 찾을 수 있다는 것입니다. 객체를 한 번만 탐지하는 게 아니라, 여러 번 탐지 할 수 있습니다. non-max 억제는 알고리즘이 각 객체를 한 번만 탐지하는지 확인하는 방법입니다. 예를 들어 봅시다. 예제를 하나 풀어보죠. 이 이미지에서 보행자, 자동차 및 오토바이를 탐지하고 싶다고 가정 해 보겠습니다. 이 위에 그리드를 배치 할 수 있습니다. 이것은 19 x 19그리드 입니다. 자, 기술적으로 이 차는 단지 하나의 중간 지점을 가지고 있기 때문에, 단지 하나의 그리드 셀에 할당되어야 합니다. 그리고 왼쪽의 차에는 중간 지점이 하나뿐이므로 기술적으로 그리드 셀 중 하나만이 차가 있다는 것을 예측할 것입니다. 실제적으로, 이 분할 셀들 각각에 대해 객체 분류와 위치 파악 알고리즘을 실행하고 있습니다. 따라서 이 분할 셀은 자동차의 중심이 그 안에 있다고 생각할 수도 있고 이렇게 할 수도 있고, 이렇게 할 수도 있고, 왼쪽의 자동차도 마찬가지 일 수 있습니다 아마도 이 상자뿐만 아니라 이전에 보았던 테스트 이미지 일 경우 그 상자가 자동차 에있는 것, 아마도 이 상자, 이 상자 및 아마도 다른 사람들도 또한 자동차를 찾은 것으로 생각할 것입니다 non max 억제가 어떻게 작동하는지 예제를 통해 살펴 보겠습니다. 361 개의 그리드 셀에 있는 모든 그리드 셀에서 이미지 분류 및 로컬라이제이션 알고리즘을 실행하고 있기 때문에 많은 사람들이 손을 들고 "내 Pc, 여기에 객체가 있다"라고 생각할 확률이 크죠. 19의 제곱, 즉 361 개 중에서 두 개의 그리드 셀을 가진 것이 아니라 그들은 객체를 탐지했다고 생각하는 것이죠. 따라서 알고리즘을 실행할 때 각 객체에 대해 여러 탐지가 이루어질 수 있습니다. 따라서, non-max 억제가 하는 일은 이러한 탐지를 깨끗하게 정리하는 것입니다. 자동차 당 하나의 탐지만 하게 되는 것이죠. 자동차 당 여러 개의 탐지를 하는 것이 아닙니다. 자세히 말하자면, 이게 하는 일은 먼저 각각의 탐지와 관련된 확률을 조사하는 것 입니다. Pc , 이것은 이번 주 문제 연습에서 배울 세부 사항인데요 실제로 Pc 에 C1 , C2 또는 C3 를 곱하는 것을 가리킵니다. 그러나 지금은 단지 Pc가 탐지 될 가능성을 말하고 있습니다. 그리고 이것은 우선 가장 큰 것을 취합니다. 이 경우 0.9입니다. " ‘그건 내 가장 자신있는 탐지입니다.’ 그러니 이걸 밝아지게 하고, '여기에서 자동차를 발견했다' 고 말하십시오. 그렇게 하고 나면, non-max 억제 파트는 남아있는 모든 직사각형을 보게 됩니다. 많이 겹쳐있고 높은 IoU를 가지고 있으며, 막 아웃풋한 것을 가지고 있는 모든 것들은 억제되어질 것입니다. 0.6과 0.7의 이 두 직사각형은 이 둘 모두 밝은 파란색 직사각형 모양으로 많이 겹쳐집니다. 따라서, 여러분은 이 둘을 억제시켜서 그것들이 지금 억제되고 있는 중이라는 걸 보여주기 위해 어둡게 만들 것입니다. 다음으로는, 남아있는 직사각형을 살펴보고 가장 높은 확률과 가장 높은 Pc를 가진 것을 찾아내십시오. 이 경우에 이것은 0.8 입니다. 자 그럼 이 방법대로 하고, ‘여기에서 자동차를 탐지해냈어요’ 라고 말하기로 합시다. 그리고 나서, non-max 억제파트는 높은 IoU를 가진 다른 것들은 지워버릴 것입니다. 그럼 이제, 모든 직사각형은 밝아지거나 어두워졌습니다. 어두워진 직사각형들을 없애고 싶다면 밝아진 것들만 남기고, 그러면 이것들이 여러분의 두 개의 최종 예측이 됩니다. 이것은 non-max 억제입니다. non-max는 최대의 확률 분류를 아웃풋하지만 최대치가 아닌 근접한 것을 억제 할 것임을 의미합니다. 따라서 이름이 non-max 억제인 것이죠. 알고리즘의 세부 사항을 살펴 보겠습니다. 먼저, 19 x 19 크기의 그리드에서 19 x 19 x 8 아웃풋 볼륨을 얻습니다. 이 예시에서는 여러분이 자동차 탐지만 한다고 간소화시켜 보겠습니다. 따라서, C1, C2 C3 를 제거하고, 이 라인이 19 x 19 의 각각 즉 361, 19제곱이니까요 361 포지션의 각각에 다음과 같은 아웃풋 예측 값을 얻게 됩니다. 이는 객체가 있을 확률과 바운딩박스 입니다. 객체가 하나만 있다면, C1, C2, C3 예측은 없습니다. 여러 개의 객체에서 어떤 일이 일어나는지에 대한 세부사항은 프로그래밍 예제연습에 남겨두도록 하겠습니다. 이번 주말에 하게 될 부분일 테니까요. 이제, non-max 억제와 친숙해지기 위해 여러분이 할 일은, 모든 상자를 버리고 Pc가 특정 임계 값보다 작거나 같은 바운딩박스의 모든 예측을 무시하는 것입니다. 객체가 있을 확률이 0.6만큼 된다고 생각되지 않는다면. 그것을 그냥 버려버리십시오. 이로 인해 모든 낮은 확률 아웃풋 상자가 발생했습니다. 이것에 대해 생각하는 방법은 각각의 361 위치에서 바운딩박스를 아웃풋하는 것입니다. 좋은 확률을 가진 바운딩박스와 함께 말이죠. 따라서 우리는 낮은 확률로 배정 된 모든 경계 상자를 버릴 것입니다 다음으로는, 다음으로 아직 버려지거나 처리되지 않은 나머지 바운딩박스가 있는 동안 가장 높은 확률을 가지고 있고, 가장 높은 Pc를 가지고 있는 상자를 반복적으로 골라서 예측으로 아웃풋 하십시오. 이것은 이전 슬라이드에서 바운딩박스 중 하나를 가져 와서 색상을 더 밝게 만드는 과정입니다. 그래서 거기에 차가 있다는 예측을 아웃풋하기로 합시다. 그런 다음 나머지 상자를 버립니다. 예측으로 아웃풋하지 않았거나. 이전에 버려지지 않은 상자를 버리는 겁니다. 따라서 많이 겹쳐지고 높은 IoU를 가졌으며 높은 IoU를 가지고 있으며, 이전 단계에서 아웃풋한 박스를 가진 남아있는 상자를 버리십시오. while loop 있는 이 두 번째 단계는 이전 슬라이드에서 본 것처럼 남아있는 바운딩 박스를 어둡게 만드는 것입니다. 이것은 더 밝게 만들고 강조했던 바운딩 박스와 많이 겹침 부위를 가지고 있습니다. 그래서, 아직 처리되지 않는 남아있는 박스들이 여전히 있다면 박스 각각을 취해서, 예측 값으로 이것을 아웃풋시키던지 혹은 너무 높은 겹침이나 IoU 때문에 버리게 될 때까지는 여러분은 이것을 계속 진행하십시오. 이 IoU는 탐지된 물체 중 하나의 예측된 자리 때문에 방금 아웃풋했던 상자들 중 하나를 가지고 있습니다. 이 슬라이드에서 단 하나의 객체 만 사용하여 알고리즘을 설명했습니다. 보행자, 자동차, 오토바이 등 3 가지 물체를 실제로 탐지하려고 하면 아웃풋벡터에 3 가지 추가 구성 요소가 생깁니다. 해야 할 일은 각각 non-max억제를 독립적으로 3회 수행하는 것입니다. 아웃풋 클래스 당 하나씩입니다 그러나 그것의 세부 사항은 여러분이 직접 구현할 수 있는 이번 주의 프로그램 예제로 넘기도록 하죠 그 예제들을 통해 다수의 객체 클래스 상에서 non-max 억제를 직접 구현할 수 있습니다. 여기까지 non-max 억제였습니다 우리가 설명한 객체 탐지 알고리즘을 실행한다면 여러분은 꽤 괜찮은 결과를 얻게 됩니다. 그러나 YOLO 알고리즘에 대한 토론을 끝내기 전에 제가 공유하고 싶은 마지막 아이디어가 하나 있습니다 이 아이디어는 알고리즘이 훨씬 잘 작동하도록 만들어 주고 앵커 박스를 사용하는 것입니다. 다음 강의로 넘어가보겠습니다. 다음 동영상으로 넘어 갑시다.