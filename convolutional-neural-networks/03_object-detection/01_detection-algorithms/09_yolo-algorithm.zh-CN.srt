1
00:00:00,000 --> 00:00:03,900
你已经认识了目标检测的大部分要素

2
00:00:03,900 --> 00:00:06,690
在这个视频中 让我们综合所有的要素

3
00:00:06,690 --> 00:00:10,850
来组成YOLO目标检测算法

4
00:00:10,850 --> 00:00:14,130
首先 让我们来看看你该如何构建你的训练集

5
00:00:14,130 --> 00:00:16,380
假设你想训练一个算法

6
00:00:16,380 --> 00:00:19,425
来检测三个目标 行人 汽车 摩托车

7
00:00:19,425 --> 00:00:23,262
并且你不需要特别地为背景分配第四个类标签

8
00:00:23,262 --> 00:00:25,390
所以就总共只有3个类标签

9
00:00:25,390 --> 00:00:28,305
如果你使用两个锚框(anchor boxes)

10
00:00:28,305 --> 00:00:33,495
那么输出y会是3x3 因为你使用了3x3的网格

11
00:00:33,495 --> 00:00:36,225
乘2 因为这是锚(anchor)的数量

12
00:00:36,225 --> 00:00:39,880
乘8 因为这是这个的维度

13
00:00:39,880 --> 00:00:45,650
8其实是5加上类别的数量

14
00:00:45,650 --> 00:00:49,533
所以5是因为你有PC和边界框

15
00:00:49,533 --> 00:00:53,505
这是5 然后C1 C2 C3

16
00:00:53,505 --> 00:00:56,340
这个维度等于类的数量

17
00:00:56,340 --> 00:00:59,535
并且你也可以将它看成3x3x2x8

18
00:00:59,535 --> 00:01:03,310
或者3x3x16

19
00:01:03,310 --> 00:01:05,415
为了构造训练集

20
00:01:05,415 --> 00:01:11,160
你遍历这九个网格然后构造合适的目标向量y

21
00:01:11,160 --> 00:01:13,050
以这第一个网格为例

22
00:01:13,050 --> 00:01:16,470
在这个网格中没什么值得检测的

23
00:01:16,470 --> 00:01:19,410
三个类别 行人 汽车 摩托车

24
00:01:19,410 --> 00:01:22,680
没有一个出现在左上角的网格

25
00:01:22,680 --> 00:01:27,870
因此 对应这个网格的目标y等于这个

26
00:01:27,870 --> 00:01:31,276
第一个锚框的Pc是0

27
00:01:31,276 --> 00:01:34,215
因为没有相关目标在第一个锚框

28
00:01:34,215 --> 00:01:37,830
并且第二个锚框(的Pc)也是0

29
00:01:37,830 --> 00:01:42,355
所以所有其他的值都不重要

30
00:01:42,355 --> 00:01:45,227
现在 绝大部分的网格中没有任何目标

31
00:01:45,227 --> 00:01:47,790
但对于这一个框

32
00:01:47,790 --> 00:01:53,550
你会用这个目标向量y

33
00:01:53,550 --> 00:01:58,680
所以假设你的训练集有一个这样的包含汽车的边界框

34
00:01:58,680 --> 00:02:01,560
宽度比高度多一点

35
00:02:01,560 --> 00:02:04,005
所以如果你的锚框是

36
00:02:04,005 --> 00:02:05,475
这是锚框一号

37
00:02:05,475 --> 00:02:07,191
这是锚框二号

38
00:02:07,191 --> 00:02:12,475
这样红色框和锚框二号的IoU稍微高一点

39
00:02:12,475 --> 00:02:17,320
所以汽车可以和这个向量低一点的部分联系起来

40
00:02:17,320 --> 00:02:22,435
注意这样锚框一号的Pc就是0

41
00:02:22,435 --> 00:02:24,965
这样你不用关心所有这些元素

42
00:02:24,965 --> 00:02:28,005
然后这个Pc等于1

43
00:02:28,005 --> 00:02:33,390
这样你应该用这些来具体表示红色边界框的位置

44
00:02:33,390 --> 00:02:38,820
然后具体表示正确的目标是类别二

45
00:02:38,820 --> 00:02:41,865
是一辆汽车

46
00:02:41,865 --> 00:02:44,010
所以你遍历这些 

47
00:02:44,010 --> 00:02:47,485
并且对于九个网格位置的每一个位置

48
00:02:47,485 --> 00:02:50,085
你都会得到一个这样的向量

49
00:02:50,085 --> 00:02:52,299
一个16维的向量

50
00:02:52,299 --> 00:02:59,375
这就是为什么最终输出的大小会是3x3x16

51
00:02:59,375 --> 00:03:04,530
哦并且通常为了简洁 在幻灯片中我使用3x3的网格

52
00:03:04,530 --> 00:03:09,540
实际上它更通常是19x19x16

53
00:03:09,540 --> 00:03:12,265
或者事实上如果你使用更多的锚框

54
00:03:12,265 --> 00:03:17,363
也许是19x19x(5x8) 因为5x8=40

55
00:03:17,363 --> 00:03:20,405
所以它会是19x19x40

56
00:03:20,405 --> 00:03:23,475
这是如果你使用5个锚框

57
00:03:23,475 --> 00:03:30,080
所以这是训练 并且你训练卷积神经网络(ConvNet)输入一个图片

58
00:03:30,080 --> 00:03:32,395
也许是100x100x3

59
00:03:32,395 --> 00:03:39,565
并且你的ConvNet会最终输出这个输出大小 如同我们的例子

60
00:03:39,565 --> 00:03:43,204
3x3x16或者3x3x2x8

61
00:03:43,204 --> 00:03:47,505
接下来 让我们看看你的算法如何进行预测

62
00:03:47,505 --> 00:03:53,445
输入一张图片 你的神经网络会输出这个3x3x2x8大小

63
00:03:53,445 --> 00:03:57,690
对于九个网格中的每一个 你会得到一个这样的向量

64
00:03:57,690 --> 00:04:00,795
所以对于左上角的这个网格

65
00:04:00,795 --> 00:04:02,925
如果这里没有目标

66
00:04:02,925 --> 00:04:06,150
希望你的神经网络会在这里输出0

67
00:04:06,150 --> 00:04:08,990
这里也是0 然后他会输出一些其他的值

68
00:04:08,990 --> 00:04:11,080
你的神经网络不能输出一个问号

69
00:04:11,080 --> 00:04:12,540
不能输出一个“无所谓“

70
00:04:12,540 --> 00:04:15,205
所以我会给剩下(位置)的一些数字

71
00:04:15,205 --> 00:04:17,400
但是这些数字基本上都被无视

72
00:04:17,400 --> 00:04:20,580
因为神经网络告诉你 这里没有目标

73
00:04:20,580 --> 00:04:23,910
所以输出是一个边界框还是这里有一辆车都不重要

74
00:04:23,910 --> 00:04:28,170
基本上就是一些数字集 或多或少的噪点

75
00:04:28,170 --> 00:04:32,370
相反 对于这个框

76
00:04:32,370 --> 00:04:37,308
希望那个左下角框的y值

77
00:04:37,308 --> 00:04:40,850
会是比如说0 对于锚框1

78
00:04:40,850 --> 00:04:43,650
然后就输出一些数字 只是噪点

79
00:04:43,650 --> 00:04:47,880
希望 你也会输出一些数字

80
00:04:47,880 --> 00:04:52,980
能与一个非常准确的车的边界框

81
00:04:52,980 --> 00:04:56,970
所以这就是神经网络如何做预测

82
00:04:56,970 --> 00:05:00,675
最终 你会运行非最大值抑制(non-max suppression)

83
00:05:00,675 --> 00:05:02,240
让这个变得好玩些

84
00:05:02,240 --> 00:05:04,740
我们来看看一个新的测试图片

85
00:05:04,740 --> 00:05:08,280
这就是你如何运行非最大值抑制

86
00:05:08,280 --> 00:05:10,680
如果你使用两个锚框(anchor boxes)

87
00:05:10,680 --> 00:05:12,690
对于九个网格中的每一个

88
00:05:12,690 --> 00:05:15,445
你会得到两个预测的锚框

89
00:05:15,445 --> 00:05:17,835
他们中的某些会有很小的概率

90
00:05:17,835 --> 00:05:20,760
非常低的Pc

91
00:05:20,760 --> 00:05:24,235
但是你还是会从九个网格中的每一个得到两个预测的锚框

92
00:05:24,235 --> 00:05:27,540
比如说 这是你得到的锚框

93
00:05:27,540 --> 00:05:30,060
并且注意有一些锚框

94
00:05:30,060 --> 00:05:34,645
会超过原始网格的高和宽度

95
00:05:34,645 --> 00:05:38,725
然后 你去掉所有低概率的预测

96
00:05:38,725 --> 00:05:41,635
所以去掉那些甚至神经网络都说

97
00:05:41,635 --> 00:05:44,025
这个目标也许不在这的边界框

98
00:05:44,025 --> 00:05:45,855
就是去掉这些

99
00:05:45,855 --> 00:05:49,868
然后最终如果你有3个试图检测的类别

100
00:05:49,868 --> 00:05:53,665
行人 汽车 和摩托车

101
00:05:53,665 --> 00:05:56,655
你该做的是 对于三个类别的每一个

102
00:05:56,655 --> 00:05:59,760
单独对被预测的类别

103
00:05:59,760 --> 00:06:03,010
执行非最大值抑制

104
00:06:03,010 --> 00:06:07,620
对行人的预测使用非最大值抑制

105
00:06:07,620 --> 00:06:10,080
对汽车使用非最大值抑制

106
00:06:10,080 --> 00:06:13,100
对摩托车使用非最大值抑制

107
00:06:13,100 --> 00:06:17,865
运行三次来产生最终的预测

108
00:06:17,865 --> 00:06:20,970
所以希望这个的输出

109
00:06:20,970 --> 00:06:25,465
能检测出这个图片上所有的汽车和所有的行人

110
00:06:25,465 --> 00:06:29,170
所以这就是YOLO目标检测算法

111
00:06:29,170 --> 00:06:33,170
所有最有效的目标检测算法之一

112
00:06:33,170 --> 00:06:36,560
也包含了许多

113
00:06:36,560 --> 00:06:41,275
整个计算机视觉与目标检测相关的最好的想法

114
00:06:41,275 --> 00:06:46,056
并且你有机会在这周的题目练习中 

115
00:06:46,056 --> 00:06:47,840
练习亲自实现它很多的部分

116
00:06:47,840 --> 00:06:51,520
所以我希望你享受这周的题目练习

117
00:06:51,520 --> 00:06:54,120
在这之后紧接着还有一个可选学习的视频

118
00:06:54,120 --> 00:06:57,010
你可以根据你的意愿选择看或者不看

119
00:06:57,010 --> 00:07:01,000
但是不管如何 我非常期待在下周见到你