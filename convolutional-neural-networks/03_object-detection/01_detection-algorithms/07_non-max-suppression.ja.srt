1
00:00:00,000 --> 00:00:03,990
これまでに学んできた物体検出の 問題点の１つは

2
00:00:03,990 --> 00:00:09,025
同じ物体を 複数回 検出するかもしれないことだ

3
00:00:09,025 --> 00:00:11,490
物体を１度だけ検出するのではなく

4
00:00:11,490 --> 00:00:13,940
何回も検出してしまう

5
00:00:13,940 --> 00:00:16,470
"Non-Max Suppression" は 物体検出を

6
00:00:16,470 --> 00:00:19,865
一度だけ 行うようにする方法だ

7
00:00:19,865 --> 00:00:21,220
例を見よう

8
00:00:21,220 --> 00:00:23,610
この画像の中で 検出したいものを

9
00:00:23,610 --> 00:00:26,070
歩行者 車 そして バイク だとする

10
00:00:26,070 --> 00:00:29,040
これに 格子を被せる

11
00:00:29,040 --> 00:00:33,375
これは 19 x 19 格子だ

12
00:00:33,375 --> 00:00:36,500
正確には この車は たった１つの中心点を持つ

13
00:00:36,500 --> 00:00:39,105
よって これは 単一の格子セルに 紐付けられる

14
00:00:39,105 --> 00:00:43,035
左の車も １つだけ中心点を持つので

15
00:00:43,035 --> 00:00:48,745
正しくは 格子の中の１セルだけが 車があることを予測すべきだ

16
00:00:48,745 --> 00:00:50,355
実際には

17
00:00:50,355 --> 00:00:56,006
物体分類と位置決めアルゴリズムを これらの各セルに対し 実行すると

18
00:00:56,006 --> 00:00:57,510
ありがちなことだが

19
00:00:57,510 --> 00:01:01,140
このセルで 車の中心があることになり

20
00:01:01,140 --> 00:01:02,578
ここでも そうなり ここでも そうなる

21
00:01:02,578 --> 00:01:05,130
左の車についても 同じだ

22
00:01:05,130 --> 00:01:07,520
この箱だけでなく

23
00:01:07,520 --> 00:01:09,957
これが 前に見たテスト画像なら

24
00:01:09,957 --> 00:01:14,070
車の中心を決めるのは この箱だけでなく

25
00:01:14,070 --> 00:01:16,665
この箱や この箱や 他のでも

26
00:01:16,665 --> 00:01:19,730
同様に 車があることになるかもしれない

27
00:01:19,730 --> 00:01:24,865
"Non-Max Suppression" が どのように動くのか 順を追って見ていこう

28
00:01:24,865 --> 00:01:26,550
全てのセルで

29
00:01:26,550 --> 00:01:31,710
画像の 分類と位置決めアルゴリズムを 動かすので

30
00:01:31,710 --> 00:01:34,635
361 個の格子セルでね

31
00:01:34,635 --> 00:01:38,670
それらの多くが 手を上げて こう言うかもしれない

32
00:01:38,670 --> 00:01:43,845
"私のPc 私の所に物体がある確率が 大きいよ"

33
00:01:43,845 --> 00:01:47,120
19 の２乗 361個のセルの中で

34
00:01:47,120 --> 00:01:51,330
２つだけが 物体検出するのではなくね

35
00:01:51,330 --> 00:01:52,905
つまり アルゴリズムを走らせると

36
00:01:52,905 --> 00:01:58,015
物体毎に 複数個の検出が出るかもしれない

37
00:01:58,015 --> 00:01:59,910
そこで "Non-Max Suppression" は

38
00:01:59,910 --> 00:02:02,645
これらの検出を整理する

39
00:02:02,645 --> 00:02:06,660
車あたり１つだけの検出にする

40
00:02:06,660 --> 00:02:09,910
複数の検出をしないようにする

41
00:02:09,910 --> 00:02:12,000
具体的には こうする

42
00:02:12,000 --> 00:02:16,645
最初は これらの検出のそれぞれの確率を見て

43
00:02:16,645 --> 00:02:18,630
Pc のようなもののことだ ただし

44
00:02:18,630 --> 00:02:21,010
今週のプログラミング演習で 詳細は学ぶけど

45
00:02:21,010 --> 00:02:23,548
それは 実際には

46
00:02:23,548 --> 00:02:24,879
Pc かける C1 や C2 や C3 だ

47
00:02:24,879 --> 00:02:29,685
でも 今は 検出の確率を Pc としておく

48
00:02:29,685 --> 00:02:32,190
そして 最初に 一番大きなものを取り出す

49
00:02:32,190 --> 00:02:35,070
この場合は 0.9 だ

50
00:02:35,070 --> 00:02:37,909
これが 最も自信ある検出だ

51
00:02:37,909 --> 00:02:41,615
じゃ これをハイライトして "ここに車がある" と言えばいい

52
00:02:41,615 --> 00:02:45,630
それが終わったら "Non-Max Suppresion" は

53
00:02:45,630 --> 00:02:49,590
残りの全ての四角から

54
00:02:49,590 --> 00:02:51,225
重なりが大きいもの全て

55
00:02:51,225 --> 00:02:54,625
今 出力した これに対して 高い IoU を持つものは 出さない

56
00:02:54,625 --> 00:02:58,385
つまり この 0.6 と 0.7 の四角は出力しない

57
00:02:58,385 --> 00:03:02,048
この ライトブルーの四角と重なりが大きいのは どちらも出力しない

58
00:03:02,048 --> 00:03:03,555
これらは 抑制されるので

59
00:03:03,555 --> 00:03:07,105
暗くして 抑制されたことを示そう

60
00:03:07,105 --> 00:03:09,405
次に 残りの四角を処理する

61
00:03:09,405 --> 00:03:11,760
最も高い確率を持つものを

62
00:03:11,760 --> 00:03:15,180
最も高い Pc のものを探す 今度は 0.8 の これになる

63
00:03:15,180 --> 00:03:17,025
だから それを信じて こう言えばいい

64
00:03:17,025 --> 00:03:18,480
"おー ここに車を見つけた"

65
00:03:18,480 --> 00:03:21,030
それから "Non-Max Suppression" は

66
00:03:21,030 --> 00:03:25,785
高い IoU を持つ他のものを取り除く

67
00:03:25,785 --> 00:03:30,315
これで 全ての四角が ハイライト もしくは 暗くされた

68
00:03:30,315 --> 00:03:33,295
そして 暗くした四角を取り除けば

69
00:03:33,295 --> 00:03:35,670
ハイライトしたものだけが残る

70
00:03:35,670 --> 00:03:39,325
これらが ２つの最終予測だ

71
00:03:39,325 --> 00:03:41,445
これが "Non-Max Suppression" だ

72
00:03:41,445 --> 00:03:44,530
"Non-Max" が意味するは

73
00:03:44,530 --> 00:03:48,215
分類の最大確率のものを 出力するが

74
00:03:48,215 --> 00:03:52,006
近傍にある最大でないものを除く ということだ

75
00:03:52,006 --> 00:03:55,684
だから 名前が ”Non-Max Suppresion"(非-最大 抑制) 

76
00:03:55,684 --> 00:03:58,185
では アルゴリズムの詳細に行こう

77
00:03:58,185 --> 00:04:00,590
最初に 19 x 19 格子で

78
00:04:00,590 --> 00:04:07,925
19 x 19 x 8 出力ボリュームを得る

79
00:04:07,925 --> 00:04:09,945
ただし この例では

80
00:04:09,945 --> 00:04:13,794
簡単のため 車の検出だけを行う

81
00:04:13,794 --> 00:04:16,080
つまり C1 C2 C3 を取り除く

82
00:04:16,080 --> 00:04:18,480
そして このスライドでは

83
00:04:18,480 --> 00:04:21,578
各 19 x 19 それぞれに対する 出力は

84
00:04:21,578 --> 00:04:23,910
つまり 361 個のそれぞれに対する出力は

85
00:04:23,910 --> 00:04:25,350
それは 19の２乗だけど

86
00:04:25,350 --> 00:04:26,835
361 個の位置 それぞれの出力は

87
00:04:26,835 --> 00:04:29,185
次のようなものになる

88
00:04:29,185 --> 00:04:31,443
これは 物体の存在確率で

89
00:04:31,443 --> 00:04:32,725
それから 境界箱だ

90
00:04:32,725 --> 00:04:34,135
たった１種類の物体なので

91
00:04:34,135 --> 00:04:38,245
C1 C2 C3 予測は無い

92
00:04:38,245 --> 00:04:40,140
複数の種類の物体がある場合

93
00:04:40,140 --> 00:04:41,875
何が起きるか 詳細は

94
00:04:41,875 --> 00:04:43,870
プログラミング演習に残すよ

95
00:04:43,870 --> 00:04:47,980
今週の終わりに やることになっているから

96
00:04:47,980 --> 00:04:50,795
さて "Non-Max Suppresion" を実装するのに

97
00:04:50,795 --> 00:04:54,405
最初にできるのは 全ての この箱を捨てることだ

98
00:04:54,405 --> 00:04:57,295
全ての この境界箱の予測を捨てる

99
00:04:57,295 --> 00:05:01,243
Pc が ある閾値 例えば 0.6 とか より 小さいものをだ

100
00:05:01,243 --> 00:05:04,140
つまり こう言おう 少なくとも 物体の存在確率が

101
00:05:04,140 --> 00:05:08,165
0.6 無いと思うなら 取り除こう と

102
00:05:08,165 --> 00:05:13,590
こうして 低確率の箱を 全て 捨てる

103
00:05:13,590 --> 00:05:19,695
それを この 361個の位置それぞれで 考える

104
00:05:19,695 --> 00:05:23,625
境界箱を

105
00:05:23,625 --> 00:05:28,140
存在確率と一緒に出力して

106
00:05:28,140 --> 00:05:29,415
低確率の境界箱全てを

107
00:05:29,415 --> 00:05:33,945
単に捨てる

108
00:05:33,945 --> 00:05:35,730
次に 

109
00:05:35,730 --> 00:05:41,130
捨てずに残った境界箱があるなら

110
00:05:41,130 --> 00:05:45,910
一番高い存在確率の箱を選ぶことを繰り返す

111
00:05:45,910 --> 00:05:47,835
一番高い Pc のをだ

112
00:05:47,835 --> 00:05:50,380
それから それを予測として出力する

113
00:05:50,380 --> 00:05:54,720
これは 前のスライドで見た処理で 境界箱から１つを取り出す

114
00:05:54,720 --> 00:05:56,725
そして 明るい色にする

115
00:05:56,725 --> 00:06:02,195
そして そこに車があるという予測を 確固として出力する

116
00:06:02,195 --> 00:06:05,803
次に 残りの箱を捨て去る

117
00:06:05,803 --> 00:06:08,905
予測として出力しなかった箱だ

118
00:06:08,905 --> 00:06:10,955
それは 前の処理では 捨てられていなかった

119
00:06:10,955 --> 00:06:14,490
前のステップで出力した箱と

120
00:06:14,490 --> 00:06:15,945
高い重なり度を持った残りの箱

121
00:06:15,945 --> 00:06:20,305
高い IoU の箱を捨てる

122
00:06:20,305 --> 00:06:25,425
この while ループの２番目は 前のスライドで

123
00:06:25,425 --> 00:06:28,680
ハイライトさせて 明るくした境界箱と

124
00:06:28,680 --> 00:06:32,310
重なりが大きい境界箱を

125
00:06:32,310 --> 00:06:34,115
暗くした時の処理だ

126
00:06:34,115 --> 00:06:36,835
そして この処理を続ける

127
00:06:36,835 --> 00:06:40,000
未処理の境界箱がある限り続ける

128
00:06:40,000 --> 00:06:45,225
各箱を予測として出力するか

129
00:06:45,225 --> 00:06:48,990
捨てるかするまで続ける
捨てるのは 重なりが大きすぎる

130
00:06:48,990 --> 00:06:50,580
IoU が高すぎる のものであり

131
00:06:50,580 --> 00:06:53,550
その IoU は 物体の位置予測に使った

132
00:06:53,550 --> 00:06:58,610
箱に対してのものだ

133
00:07:00,000 --> 00:07:06,640
このスライドでは 単一物体を使ったアルゴリズムを説明した

134
00:07:06,640 --> 00:07:10,940
もし 実際には ３物体の検出をするのなら

135
00:07:10,940 --> 00:07:16,215
歩行者 車 そして バイク の検出をするなら 出力ベクトルには ３つの要素が追加される

136
00:07:16,215 --> 00:07:18,860
そして 分かると思うが やるべきことは

137
00:07:18,860 --> 00:07:22,745
独立して "Non-Max Suppression" を ３度行うことだ

138
00:07:22,745 --> 00:07:26,635
出力クラスそれぞれに対してだ

139
00:07:26,635 --> 00:07:29,475
でも その詳細は

140
00:07:29,475 --> 00:07:33,132
あなた自身で実装することになる 今週のプログラミング演習に残しておく

141
00:07:33,132 --> 00:07:38,912
そこでは 複数種類の物体についての "Non-Max Suppression" を あなた自分で実装することになる

142
00:07:38,912 --> 00:07:41,210
以上が "Non-Max Suppresion" だ

143
00:07:41,210 --> 00:07:45,090
今まで説明してきた 物体検出アルゴリズムを実装すれば

144
00:07:45,090 --> 00:07:48,175
とても良い結果を得る

145
00:07:48,175 --> 00:07:51,876
だけど YOLO アルゴリズムの議論をまとめる前に

146
00:07:51,876 --> 00:07:54,810
共有しておきたいアイデアが１つある

147
00:07:54,810 --> 00:07:57,295
それによって アルゴリズムは とても良くなる

148
00:07:57,295 --> 00:08:00,235
それは アンカーボックスを使うというアイデアだ

149
00:08:00,235 --> 00:08:02,000
次のビデオに進みましょう