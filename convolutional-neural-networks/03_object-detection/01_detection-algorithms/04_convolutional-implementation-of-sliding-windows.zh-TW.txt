在上一段影片中 你學到了利用 ConvNet 的滑動視窗 (Sliding windows) 物件偵測演算法，
不過我們發現這太慢了 在這部影片，你會學到怎麼用「卷積化」的方式實作這演算法 我們來看這是什麼意思 想要建造出卷積化的滑動視窗運算，先來看要如何 把網路的全連結層 (fully connected layers) 轉換成卷積層 我們先在這張投影片解釋，然後到了下一張投影片 我們會用這張投影片的概念來教你卷積化的作法 假設你的物件偵測演算法接受 14乘14乘3 的圖片 — 這很小沒錯，不過方便我們舉例 然後假設用 5乘5 的過濾器 用了 16 個過濾器，所以把圖片從 14乘14乘3 轉成 10乘10乘16 然後用了 2乘2 的最大池化層 (max pooling) 縮減到 5乘5乘16 然後接 400 個單元的全連結層 然後另一層全連結層，最後用 softmax 輸出 y 為了解釋等會兒的演變 我把這張圖改一下下 把 y 看成是四個數字 對照到四個類別的機率 也就是 softmax 分類出來的 這四個類別可以是行人、 汽車、機車、和背景之類的。 現在，我要展示給你看 這些層要如何轉換成卷積層 那麼 ConvNet 前面幾層還是一樣 而對於下一層， 其中一種實作這個全連結層的方式，是利用 5乘5 的過濾器，而且我們用 400 個過濾器。 如果你拿 5乘5乘16 的圖片和 5乘5 的過濾器做卷積 請記得一個 5乘5 的過濾器其實是 5乘5乘16，因為我們的過濾器會看過所有 16 個通道 所以這邊的 16 和這邊的 16 要一樣，而輸出是 1乘1 那如果你有 400 個這種 5乘5乘16 的過濾器 那輸出的維度就會是 1乘1乘400。 所以我們不再把這 400 個只看成一堆單元 我們把他看成一個 1乘1乘400 的容積。 數學上，這和全連結層一模一樣 因為這 400 個點，每個點都有個 5乘5乘16 的過濾器 所以那 400 個值的每一個值 都是前一層的 5乘5乘16 的啟動值的某種線性函數。 接下來，要做出下一個卷積層 我們要做 1乘1 的卷積 如果你有 400 個 1乘1 的過濾器 下一層就也會是 1乘1乘400 所以這就是這邊後面的全連結層 最後呢，我們又需要 1乘1 的過濾器 後面再接個 softmax 所以這邊會輸出 1乘1乘4 的容積 也就是對應到這個網路輸出的這四個數字。 所以這就是怎麼把這些全連結層 用卷積層來實作之 這邊這堆單元現在改用 1乘1乘400 和 1乘1乘4 的容積來取代之。 學會了這種轉換後，讓我們看看 要怎麼用卷積化的方法實作滑動視窗物件偵測 這張投影片是基於 "OverFeat" 這篇論文 參考文獻在底下，是由 Pierre Sermanet David Eigen, Xiang Zhang Michael Mathieu, Rob Fergus 和 Yann LeCun 所作 假設你的滑動視窗 ConvNet 吃的是 14乘14乘3 的圖片 同樣的我這邊用很小的 14乘14 只是為了舉例，簡化數字和圖示 那麼像之前提的，你有個這樣的神經網路 最終會輸出 1乘1乘4 的容積 也就是 softmax 的結果 然後為了簡化圖示起見 14乘14乘3 其實是個容積、10乘10乘16 也是一個容積 不過為了簡化圖示 我只會畫容積的正面 所以並不會畫出 1乘1乘400 的容積 對於這些我只畫出 1乘1 的部份 只會在這張投影片把 3D 的部份拿掉。 那麼假設，你的 ConvNet 輸入為 14乘14 的圖片 其實是 14乘14乘3，然後測試集的圖片是 16乘16乘3 所以我在圖片邊邊加了黃色的這條 在原版的滑動視窗法 你會把藍色的區域餵給 ConvNet 跑過一次，產生分類 0 或 1，然後往下滑一點 讓我們用 2 個像素(pixel)的跨步，然後你可能往右滑 2 個像素，把這個 綠色的區域輸入到 ConvNet 重跑一遍整個 ConvNet，得到另一個分類 0 或 1 然後你會輸入 這個橘色的區域，餵給 ConvNet，再跑一次，得到另個分類 第四次也是最後一次，是這個右下的紫色區域。 為了在 16乘16乘3 的圖片上跑滑動視窗，雖然圖很小 你需要跑這個 ConvNet 四遍，才能拿到四個分類 不過其實呢，這四次 ConvNet 做的運算有很多都是重複的， 而卷積化的滑動視窗法能夠讓 這四次 ConvNet 的正向傳播共用很多運算。 具體來說是這樣做的 你用這個 ConvNet，用同樣的參數來跑 用同樣的那個 5乘5 過濾器 同樣那 16 個 5乘5 的過濾器來跑這圖片 這樣的話你就有了 12乘12乘16 的容積 然後和之前一樣做最大池化 得到 6乘6乘16 跑過同樣那400個 5乘5 的過濾器，得到 2乘2乘400 的容積 所以和上面的 1乘1乘400 容積不同 我們現在有的是 2乘2乘400 的容積 再拿他跑過 1乘1 的過濾器 會給你另一個 2乘2乘400 — 而非 1乘1乘400 再做一次以後，最後輸出是一個 2乘2乘4 的容積，而不是 1乘1乘4。 其實這一部份藍色的 1乘1乘4 會是左上部份的 14乘14 圖片所跑出來的結果 這個右上的 1乘1乘4 容積代表右上的結果 左下這個的結果 是這左下 14乘14 區域通過 ConvNet 的結果 而右下 1乘1乘4 的容積結果 是右下角 14乘14 區域跑過 ConvNet 的輸出。 如果我們檢查所有運算的步驟 我們來看看綠色的這個例子 如果你只把這塊區域切出來 讓他通過上面那個 ConvNet 那麼第一層的啟動值剛剛好會是這塊區域 接下來過最大池化層後的啟動值 正會是這個區域。然後下一層、 再下一層都是類似情況 所以這整個過程、 這卷積化的計算做的是 與其於各自把影像的四個區域 各自獨立、做了四次正向傳播，還不如 把這四個整合成一次的正向傳播 分享這四塊圖片的共同區域的計算 也就是這邊四塊 14乘14 的區域 那現在，讓我們看一個比較大的例子 假設你想在 28乘28乘3 的圖片上跑滑動視窗 當你用同樣的方式 跑正向傳播，你最後會得到 8乘8乘4 的輸出 這相當於對這 14乘14 的區域跑滑動視窗... 對這區域跑滑動視窗 會對應到這邊左上角的這顆輸出 然後用兩步的跨步移動這視窗 移過去一次、移過去一次... 最後有了八個位置 所以這給了你第一列。然後你把影像往下滑 最終會給你所有 8乘8乘4 的輸出 因為這邊是 2 的最大池化層，所以相對應地 在原本的圖片上，這網路跑的是兩步的跨步 總結一下 要實作滑動視窗法 之前作法是，你會去切一塊區域 假設這是 14乘14 然後跑過 ConvNet，然後再做下一個區域 再做下一個 14乘14 的區域 然後下一個、再下一個、 下一個... 依此類推 直到希望有某一塊能辨認出汽車。 不過現在呢，我們並不依序進行； 如果用前面投影片介紹的卷積化手法 你可以把一整張圖片 例如 28乘28，用卷積的方式同時預測全部 只要用一次大的 ConvNet 正向傳播 最後希望能找到汽車的位置。 那麼，這就是怎麼利用卷積化 來實作滑動視窗，讓整件事變非常有效率 不過呢，這演算法仍然有個弱點： 邊界框的位置並不會太準確 在下一個影片中 我們來看看要怎麼解決這個問題