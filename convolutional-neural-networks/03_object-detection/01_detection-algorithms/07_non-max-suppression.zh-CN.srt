1
00:00:00,000 --> 00:00:03,990
目前所学到的目标检测
的问题之一是

2
00:00:03,990 --> 00:00:09,025
你的算法或许会对同一目标
有多次检测.

3
00:00:09,025 --> 00:00:11,490
所以与其只检测到目标一次

4
00:00:11,490 --> 00:00:13,940
或许会被检测到很多次

5
00:00:13,940 --> 00:00:16,470
非极大值抑制是一种让你确保

6
00:00:16,470 --> 00:00:19,865
你的算法只对每个对象
得到一个检测的方法.

7
00:00:19,865 --> 00:00:21,220
我们来举一个例子。

8
00:00:21,220 --> 00:00:23,610
假设你想在这张图片中检测行人

9
00:00:23,610 --> 00:00:26,070
车,和摩托车.

10
00:00:26,070 --> 00:00:29,040
你会在图片上放置一个网格,

11
00:00:29,040 --> 00:00:33,375
这是一个19乘19的网格.

12
00:00:33,375 --> 00:00:36,500
现在, 从技术上来说
这个车只有一个中间点,

13
00:00:36,500 --> 00:00:39,105
那么它应该被分配到一个网格单元中.

14
00:00:39,105 --> 00:00:43,035
同样,左边的车
也应该只有一个中间点,

15
00:00:43,035 --> 00:00:48,745
所以技术上来说
只有一个单元格预测出有一辆车.

16
00:00:48,745 --> 00:00:50,355
实际中,对每一个网格,你都进行

17
00:00:50,355 --> 00:00:56,006
目标分类和定位算法.

18
00:00:56,006 --> 00:00:57,510
那么很有可能

19
00:00:57,510 --> 00:01:01,140
这个网格被认为是车的中心点,

20
00:01:01,140 --> 00:01:02,578
而这个网格可能也是,

21
00:01:02,578 --> 00:01:05,130
还有这个, 对左边的车也是一样的.

22
00:01:05,130 --> 00:01:07,520
可能不仅仅是这个网格,

23
00:01:07,520 --> 00:01:09,957
如果这是你之前看过的测试图片,

24
00:01:09,957 --> 00:01:14,070
不仅仅是那个网格
决定了这是一辆车,

25
00:01:14,070 --> 00:01:16,665
这个网格,和这个网格, 也许其他的

26
00:01:16,665 --> 00:01:19,730
也会认为这是辆车.

27
00:01:19,730 --> 00:01:24,865
让我们通过一个例子一步步看一下,
非极大值抑制是如何工作的.

28
00:01:24,865 --> 00:01:26,550
因为你对每个网格

29
00:01:26,550 --> 00:01:31,710
运行图像分类和定位的算法.

30
00:01:31,710 --> 00:01:34,635
在这361个网格上,

31
00:01:34,635 --> 00:01:38,670
有可能许多网格会举手说，

32
00:01:38,670 --> 00:01:43,845
"我的Pc值很大, 即有个目标
极有可能在我的网格中."

33
00:01:43,845 --> 00:01:47,120
而不是有二个网格

34
00:01:47,120 --> 00:01:51,330
在这19平方，361个网格中
认为他们检测到了目标.

35
00:01:51,330 --> 00:01:52,905
所以，当你运行算法时,

36
00:01:52,905 --> 00:01:58,015
对每个目标
你也许会得到多个检测结果.

37
00:01:58,015 --> 00:01:59,910
所以, 非极大值抑制要做的是

38
00:01:59,910 --> 00:02:02,645
清理这些检测.

39
00:02:02,645 --> 00:02:06,660
这样每辆车只会得到一个检测结果,

40
00:02:06,660 --> 00:02:09,910
而不是多个结果.

41
00:02:09,910 --> 00:02:12,000
因此具体来说, 它要做的

42
00:02:12,000 --> 00:02:16,645
首先
是看一看每个检测结果的相关概率.

43
00:02:16,645 --> 00:02:18,630
说到候选者PC，尽管

44
00:02:18,630 --> 00:02:21,010
在这周的作业练习中你学到一些细节

45
00:02:21,010 --> 00:02:23,548
是Pc乘以C1,

46
00:02:23,548 --> 00:02:24,879
或者C2, C3.

47
00:02:24,879 --> 00:02:29,685
但现在,
我们认为Pc为一个检测到的概率.

48
00:02:29,685 --> 00:02:32,190
首先它取其中最大那个,

49
00:02:32,190 --> 00:02:35,070
在这个例子中是0.9, 意味着

50
00:02:35,070 --> 00:02:37,909
"这是我最自信的检测结果了,

51
00:02:37,909 --> 00:02:41,615
那么让我们标明它,
认为我在这里找到一辆车."

52
00:02:41,615 --> 00:02:45,630
做完这一步, 非极大值抑制再看

53
00:02:45,630 --> 00:02:49,590
所有的剩下的方框
以及所有和你刚输入的那个结果

54
00:02:49,590 --> 00:02:51,225
有着着多重叠的,
有着高IOU值的方形区域

55
00:02:51,225 --> 00:02:54,625
你得到的产出值将被抑制.

56
00:02:54,625 --> 00:02:58,385
就是那二个概率为0,6和0.7的方框.

57
00:02:58,385 --> 00:03:02,048
这二个和亮蓝色的方框重叠最多.

58
00:03:02,048 --> 00:03:03,555
所以这些你将要做抑制

59
00:03:03,555 --> 00:03:07,105
通过调暗他们来表明他们被抑制了.

60
00:03:07,105 --> 00:03:09,405
接下来,你将要计算所有剩余的方框

61
00:03:09,405 --> 00:03:11,760
来找出有着最大概率的那个,

62
00:03:11,760 --> 00:03:15,180
即最高Pc值, 在这个例子里是0.8这个.

63
00:03:15,180 --> 00:03:17,025
因此让我们确定了它, 认为

64
00:03:17,025 --> 00:03:18,480
"哦,我在这里找到一辆车."

65
00:03:18,480 --> 00:03:21,030
接着,非极大值抑制部分

66
00:03:21,030 --> 00:03:25,785
将去掉任何有着高IOU值的.

67
00:03:25,785 --> 00:03:30,315
那么现在,
每个方框不是被高亮就是被调暗.

68
00:03:30,315 --> 00:03:33,295
如果你只是去掉那些调暗的方框,

69
00:03:33,295 --> 00:03:35,670
剩下的就是那些标记的,

70
00:03:35,670 --> 00:03:39,325
这是你的二个最终预测.

71
00:03:39,325 --> 00:03:41,445
所以这就是非极大值抑制.

72
00:03:41,445 --> 00:03:44,530
非极大值意思是你将要输出

73
00:03:44,530 --> 00:03:48,215
有着最大可能性的分类判断

74
00:03:48,215 --> 00:03:52,006
而抑制那些
非最大可能性的邻近的方框.

75
00:03:52,006 --> 00:03:55,684
因此叫做非极大值抑制.

76
00:03:55,684 --> 00:03:58,185
现在我们来过一下这个算法的细节.

77
00:03:58,185 --> 00:04:00,590
首先,在这个19乘19的网格中,

78
00:04:00,590 --> 00:04:07,925
你将会得到一个19乘19乘8输出量.

79
00:04:07,925 --> 00:04:09,945
在这个例子中,

80
00:04:09,945 --> 00:04:13,794
我将简化问题为你只是做汽车检测.

81
00:04:13,794 --> 00:04:16,080
让我们去掉C1,C2,

82
00:04:16,080 --> 00:04:18,480
C3, 而且现在假设

83
00:04:18,480 --> 00:04:21,578
每一个19乘19网格的输出,

84
00:04:21,578 --> 00:04:23,910
即361个网格的输出,

85
00:04:23,910 --> 00:04:25,350
19的平方,

86
00:04:25,350 --> 00:04:26,835
对这361个位置,

87
00:04:26,835 --> 00:04:29,185
你获得一个如下的输出预测,

88
00:04:29,185 --> 00:04:31,443
即包括了是否有目标的几率,

89
00:04:31,443 --> 00:04:32,725
和边界框.

90
00:04:32,725 --> 00:04:34,135
而如果你只有一个目标,

91
00:04:34,135 --> 00:04:38,245
就没有C1, C2,C3预测.

92
00:04:38,245 --> 00:04:40,140
如果有多个目标会怎样呢，

93
00:04:40,140 --> 00:04:41,875
其中细节

94
00:04:41,875 --> 00:04:43,870
我会放到编程练习中,

95
00:04:43,870 --> 00:04:47,980
本周结束你就会涉及到.

96
00:04:47,980 --> 00:04:50,795
那么, 为了运用非极大值抑制,

97
00:04:50,795 --> 00:04:54,405
首先要做的是丢掉所有的方框,

98
00:04:54,405 --> 00:04:57,295
丢掉所有预测值Pc小于或等于

99
00:04:57,295 --> 00:05:01,243
某个门限的边界框, 例如0.6.

100
00:05:01,243 --> 00:05:04,140
所以除非你认为至少有一个

101
00:05:04,140 --> 00:05:08,165
概率为0.6机会认为目标在那里,
所以我们选择直接去掉它.

102
00:05:08,165 --> 00:05:13,590
这样就作用于所有的低概率输出框.

103
00:05:13,590 --> 00:05:19,695
我们这么想，
对这361位置的任意一个,

104
00:05:19,695 --> 00:05:23,625
你输出了一个边界框和

105
00:05:23,625 --> 00:05:28,140
它含有目标的概率.

106
00:05:28,140 --> 00:05:29,415
所以,我们将去掉

107
00:05:29,415 --> 00:05:33,945
所有有着低概率的边界框.

108
00:05:33,945 --> 00:05:35,730
接下来, 如果还有剩下的边界框

109
00:05:35,730 --> 00:05:41,130
还没有被去掉或处理的,

110
00:05:41,130 --> 00:05:45,910
你将重复地选出有着最大概率

111
00:05:45,910 --> 00:05:47,835
最大Pc值的边界框,

112
00:05:47,835 --> 00:05:50,380
将它作为一个预测结果.

113
00:05:50,380 --> 00:05:54,720
所以这就是前面一页讲到的过程,

114
00:05:54,720 --> 00:05:56,725
选出一个边界框并用高光笔标记它.

115
00:05:56,725 --> 00:06:02,195
这里
你一定可以得到有一辆车的预测

116
00:06:02,195 --> 00:06:05,803
接下来, 你要丢掉其他剩余边界框,

117
00:06:05,803 --> 00:06:08,905
即那些不被认为是预测结果的,

118
00:06:08,905 --> 00:06:10,955
并且之前也没有被去掉的框.

119
00:06:10,955 --> 00:06:14,490
因此丢弃任何剩余的，
 同上一步的计算有着着多重叠的,

120
00:06:14,490 --> 00:06:15,945
高IOU值

121
00:06:15,945 --> 00:06:20,305
的边框

122
00:06:20,305 --> 00:06:25,425
所以,这第二步的while循环
就是在前面幻灯片中

123
00:06:25,425 --> 00:06:28,680
我们调暗那些剩余的边框

124
00:06:28,680 --> 00:06:32,310
那些和之前高亮的边界框
有着大量重叠的

125
00:06:32,310 --> 00:06:34,115
我们刚刚标记的

126
00:06:34,115 --> 00:06:36,835
所以只要还有未被处理的边界框,

127
00:06:36,835 --> 00:06:40,000
你需要重复这个过程,

128
00:06:40,000 --> 00:06:45,225
直到每个边界框
不是被输出为预测结果,

129
00:06:45,225 --> 00:06:48,990
就是被丢弃掉,
由于它们有着很大的重复

130
00:06:48,990 --> 00:06:50,580
或很高的IOU值.

131
00:06:50,580 --> 00:06:53,550
和你刚刚检测输出的目标检测

132
00:06:53,550 --> 00:06:58,610
来作为你检测到的目标相比。

133
00:07:00,000 --> 00:07:06,640
在这页幻灯片中
我用单个目标来描述这个算法.

134
00:07:06,640 --> 00:07:10,940
如果你实际上试着检测三种目标,
 例如行人,

135
00:07:10,940 --> 00:07:16,215
车辆, 和摩托车, 
那么输出向量将会有额外三部分.

136
00:07:16,215 --> 00:07:18,860
而事实证明, 正确的做法是

137
00:07:18,860 --> 00:07:22,745
运行三次独立的非极大值抑制算法,

138
00:07:22,745 --> 00:07:26,635
每次针对一种输出分类.

139
00:07:26,635 --> 00:07:29,475
但是细节我会留到

140
00:07:29,475 --> 00:07:33,132
本周的编程练习中, 练习中你将自己

141
00:07:33,132 --> 00:07:38,912
实现多个目标检测的非极大值抑制算法.

142
00:07:38,912 --> 00:07:41,210
那么这就是非极大值抑制,

143
00:07:41,210 --> 00:07:45,090
如果你实现我们所叙述的目标检测算法,

144
00:07:45,090 --> 00:07:48,175
你将会得到相当不错的结果.

145
00:07:48,175 --> 00:07:51,876
但是在结束YOLO算法讨论之前,

146
00:07:51,876 --> 00:07:54,810
我还要分享最后一件事,

147
00:07:54,810 --> 00:07:57,295
将会使算法更好的工作,

148
00:07:57,295 --> 00:08:00,235
就是使用锚盒.

149
00:08:00,235 --> 00:08:02,000
我们下一节再见