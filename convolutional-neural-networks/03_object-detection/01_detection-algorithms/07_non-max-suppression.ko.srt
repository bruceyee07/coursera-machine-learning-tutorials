1
00:00:00,000 --> 00:00:03,990
지금까지 이것에 대해 배웠던 객체 탐지의 문제점 중 하나는

2
00:00:03,990 --> 00:00:09,025
알고리즘이 동일한 객체에 대해 다수의 탐지 체를 찾을 수 있다는 것입니다.

3
00:00:09,025 --> 00:00:11,490
객체를 한 번만 탐지하는 게 아니라,

4
00:00:11,490 --> 00:00:13,940
여러 번 탐지 할 수 있습니다.

5
00:00:13,940 --> 00:00:16,470
non-max 억제는 알고리즘이 각 객체를 한 번만 탐지하는지

6
00:00:16,470 --> 00:00:19,865
확인하는 방법입니다. 예를 들어 봅시다.

7
00:00:19,865 --> 00:00:21,220
예제를 하나 풀어보죠.

8
00:00:21,220 --> 00:00:23,610
이 이미지에서 보행자,

9
00:00:23,610 --> 00:00:26,070
자동차 및 오토바이를 탐지하고 싶다고 가정 해 보겠습니다.

10
00:00:26,070 --> 00:00:29,040
이 위에 그리드를 배치 할 수 있습니다.

11
00:00:29,040 --> 00:00:33,375
이것은 19 x 19그리드 입니다.

12
00:00:33,375 --> 00:00:36,500
자, 기술적으로 이 차는 단지 하나의 중간 지점을 가지고 있기 때문에,

13
00:00:36,500 --> 00:00:39,105
단지 하나의 그리드 셀에 할당되어야 합니다.

14
00:00:39,105 --> 00:00:43,035
그리고 왼쪽의 차에는 중간 지점이 하나뿐이므로

15
00:00:43,035 --> 00:00:48,745
기술적으로 그리드 셀 중 하나만이 차가 있다는 것을 예측할 것입니다.

16
00:00:48,745 --> 00:00:50,355
실제적으로,

17
00:00:50,355 --> 00:00:56,006
이 분할 셀들 각각에 대해 객체 분류와 위치 파악 알고리즘을 실행하고 있습니다.

18
00:00:56,006 --> 00:00:57,510
따라서 이 분할 셀은

19
00:00:57,510 --> 00:01:01,140
자동차의 중심이 그 안에 있다고 생각할 수도 있고

20
00:01:01,140 --> 00:01:02,578
이렇게 할 수도 있고,

21
00:01:02,578 --> 00:01:05,130
이렇게 할 수도 있고, 왼쪽의 자동차도 마찬가지 일 수 있습니다

22
00:01:05,130 --> 00:01:07,520
아마도 이 상자뿐만 아니라

23
00:01:07,520 --> 00:01:09,957
이전에 보았던 테스트 이미지 일 경우

24
00:01:09,957 --> 00:01:14,070
그 상자가 자동차 에있는 것,

25
00:01:14,070 --> 00:01:16,665
아마도 이 상자, 이 상자 및 아마도 다른 사람들도 또한

26
00:01:16,665 --> 00:01:19,730
자동차를 찾은 것으로 생각할 것입니다

27
00:01:19,730 --> 00:01:24,865
non max 억제가 어떻게 작동하는지 예제를 통해 살펴 보겠습니다.

28
00:01:24,865 --> 00:01:26,550
361 개의 그리드 셀에 있는 모든 그리드 셀에서

29
00:01:26,550 --> 00:01:31,710
이미지 분류 및 로컬라이제이션 알고리즘을

30
00:01:31,710 --> 00:01:34,635
실행하고 있기 때문에

31
00:01:34,635 --> 00:01:38,670
많은 사람들이 손을 들고

32
00:01:38,670 --> 00:01:43,845
"내 Pc, 여기에 객체가 있다"라고 생각할 확률이 크죠.

33
00:01:43,845 --> 00:01:47,120
19의 제곱, 즉 361 개 중에서 두 개의 그리드 셀을 가진 것이 아니라

34
00:01:47,120 --> 00:01:51,330
그들은 객체를 탐지했다고 생각하는 것이죠.

35
00:01:51,330 --> 00:01:52,905
따라서 알고리즘을 실행할 때

36
00:01:52,905 --> 00:01:58,015
각 객체에 대해 여러 탐지가 이루어질 수 있습니다.

37
00:01:58,015 --> 00:01:59,910
따라서, non-max 억제가 하는 일은

38
00:01:59,910 --> 00:02:02,645
이러한 탐지를 깨끗하게 정리하는 것입니다.

39
00:02:02,645 --> 00:02:06,660
자동차 당 하나의 탐지만 하게 되는 것이죠.

40
00:02:06,660 --> 00:02:09,910
자동차 당 여러 개의 탐지를 하는 것이 아닙니다.

41
00:02:09,910 --> 00:02:12,000
자세히 말하자면, 이게 하는 일은

42
00:02:12,000 --> 00:02:16,645
먼저 각각의 탐지와 관련된 확률을 조사하는 것 입니다.

43
00:02:16,645 --> 00:02:18,630
Pc , 이것은 이번 주 문제 연습에서

44
00:02:18,630 --> 00:02:21,010
배울 세부 사항인데요

45
00:02:21,010 --> 00:02:23,548
실제로 Pc 에 C1 ,

46
00:02:23,548 --> 00:02:24,879
C2 또는 C3 를 곱하는 것을 가리킵니다.

47
00:02:24,879 --> 00:02:29,685
그러나 지금은 단지 Pc가 탐지 될 가능성을 말하고 있습니다.

48
00:02:29,685 --> 00:02:32,190
그리고 이것은 우선 가장 큰 것을 취합니다.

49
00:02:32,190 --> 00:02:35,070
이 경우 0.9입니다. "

50
00:02:35,070 --> 00:02:37,909
‘그건 내 가장 자신있는 탐지입니다.’

51
00:02:37,909 --> 00:02:41,615
그러니 이걸 밝아지게 하고, '여기에서 자동차를 발견했다' 고 말하십시오.

52
00:02:41,615 --> 00:02:45,630
그렇게 하고 나면, non-max 억제 파트는

53
00:02:45,630 --> 00:02:49,590
남아있는 모든 직사각형을 보게 됩니다. 많이 겹쳐있고

54
00:02:49,590 --> 00:02:51,225
높은 IoU를 가지고 있으며,

55
00:02:51,225 --> 00:02:54,625
막 아웃풋한 것을 가지고 있는 모든 것들은 억제되어질 것입니다.

56
00:02:54,625 --> 00:02:58,385
0.6과 0.7의 이 두 직사각형은

57
00:02:58,385 --> 00:03:02,048
이 둘 모두 밝은 파란색 직사각형 모양으로 많이 겹쳐집니다.

58
00:03:02,048 --> 00:03:03,555
따라서, 여러분은 이 둘을 억제시켜서

59
00:03:03,555 --> 00:03:07,105
그것들이 지금 억제되고 있는 중이라는 걸 보여주기 위해 어둡게 만들 것입니다.

60
00:03:07,105 --> 00:03:09,405
다음으로는, 남아있는 직사각형을 살펴보고

61
00:03:09,405 --> 00:03:11,760
가장 높은 확률과 가장 높은 Pc를 가진 것을 찾아내십시오.

62
00:03:11,760 --> 00:03:15,180
이 경우에 이것은 0.8 입니다.

63
00:03:15,180 --> 00:03:17,025
자 그럼 이 방법대로 하고,

64
00:03:17,025 --> 00:03:18,480
‘여기에서 자동차를 탐지해냈어요’ 라고 말하기로 합시다.

65
00:03:18,480 --> 00:03:21,030
그리고 나서, non-max 억제파트는

66
00:03:21,030 --> 00:03:25,785
높은 IoU를 가진 다른 것들은 지워버릴 것입니다.

67
00:03:25,785 --> 00:03:30,315
그럼 이제, 모든 직사각형은 밝아지거나 어두워졌습니다.

68
00:03:30,315 --> 00:03:33,295
어두워진 직사각형들을 없애고 싶다면

69
00:03:33,295 --> 00:03:35,670
밝아진 것들만 남기고,

70
00:03:35,670 --> 00:03:39,325
그러면 이것들이 여러분의 두 개의 최종 예측이 됩니다.

71
00:03:39,325 --> 00:03:41,445
이것은 non-max 억제입니다.

72
00:03:41,445 --> 00:03:44,530
non-max는 최대의 확률 분류를 아웃풋하지만

73
00:03:44,530 --> 00:03:48,215
최대치가 아닌 근접한 것을 억제 할 것임을

74
00:03:48,215 --> 00:03:52,006
의미합니다.

75
00:03:52,006 --> 00:03:55,684
따라서 이름이 non-max 억제인 것이죠.

76
00:03:55,684 --> 00:03:58,185
알고리즘의 세부 사항을 살펴 보겠습니다.

77
00:03:58,185 --> 00:04:00,590
먼저, 19 x 19 크기의 그리드에서

78
00:04:00,590 --> 00:04:07,925
19 x 19 x 8 아웃풋 볼륨을 얻습니다.

79
00:04:07,925 --> 00:04:09,945
이 예시에서는

80
00:04:09,945 --> 00:04:13,794
여러분이 자동차 탐지만 한다고 간소화시켜 보겠습니다.

81
00:04:13,794 --> 00:04:16,080
따라서, C1, C2

82
00:04:16,080 --> 00:04:18,480
C3 를 제거하고, 이 라인이

83
00:04:18,480 --> 00:04:21,578
19 x 19 의 각각

84
00:04:21,578 --> 00:04:23,910
즉 361,

85
00:04:23,910 --> 00:04:25,350
19제곱이니까요

86
00:04:25,350 --> 00:04:26,835
361 포지션의 각각에

87
00:04:26,835 --> 00:04:29,185
다음과 같은 아웃풋 예측 값을 얻게 됩니다.

88
00:04:29,185 --> 00:04:31,443
이는 객체가 있을 확률과

89
00:04:31,443 --> 00:04:32,725
바운딩박스 입니다.

90
00:04:32,725 --> 00:04:34,135
객체가 하나만 있다면,

91
00:04:34,135 --> 00:04:38,245
C1, C2, C3 예측은 없습니다.

92
00:04:38,245 --> 00:04:40,140
여러 개의 객체에서 어떤 일이 일어나는지에 대한

93
00:04:40,140 --> 00:04:41,875
세부사항은

94
00:04:41,875 --> 00:04:43,870
프로그래밍 예제연습에 남겨두도록 하겠습니다.

95
00:04:43,870 --> 00:04:47,980
이번 주말에 하게 될 부분일 테니까요.

96
00:04:47,980 --> 00:04:50,795
이제, non-max 억제와 친숙해지기 위해

97
00:04:50,795 --> 00:04:54,405
여러분이 할 일은, 모든 상자를 버리고

98
00:04:54,405 --> 00:04:57,295
Pc가 특정 임계 값보다 작거나 같은

99
00:04:57,295 --> 00:05:01,243
바운딩박스의 모든 예측을 무시하는 것입니다.

100
00:05:01,243 --> 00:05:04,140
객체가 있을 확률이 0.6만큼 된다고 생각되지 않는다면.

101
00:05:04,140 --> 00:05:08,165
그것을 그냥 버려버리십시오.

102
00:05:08,165 --> 00:05:13,590
이로 인해 모든 낮은 확률 아웃풋 상자가 발생했습니다.

103
00:05:13,590 --> 00:05:19,695
이것에 대해 생각하는 방법은 각각의 361 위치에서

104
00:05:19,695 --> 00:05:23,625
바운딩박스를 아웃풋하는 것입니다.

105
00:05:23,625 --> 00:05:28,140
좋은 확률을 가진 바운딩박스와 함께 말이죠.

106
00:05:28,140 --> 00:05:29,415
따라서 우리는 낮은 확률로 배정 된

107
00:05:29,415 --> 00:05:33,945
모든 경계 상자를 버릴 것입니다

108
00:05:33,945 --> 00:05:35,730
다음으로는,

109
00:05:35,730 --> 00:05:41,130
다음으로 아직 버려지거나 처리되지 않은 나머지 바운딩박스가 있는 동안

110
00:05:41,130 --> 00:05:45,910
가장 높은 확률을 가지고 있고,

111
00:05:45,910 --> 00:05:47,835
가장 높은 Pc를 가지고 있는 상자를 반복적으로 골라서

112
00:05:47,835 --> 00:05:50,380
예측으로 아웃풋 하십시오.

113
00:05:50,380 --> 00:05:54,720
이것은 이전 슬라이드에서 바운딩박스 중 하나를 가져 와서

114
00:05:54,720 --> 00:05:56,725
색상을 더 밝게 만드는 과정입니다.

115
00:05:56,725 --> 00:06:02,195
그래서 거기에 차가 있다는 예측을 아웃풋하기로 합시다.

116
00:06:02,195 --> 00:06:05,803
그런 다음 나머지 상자를 버립니다.

117
00:06:05,803 --> 00:06:08,905
예측으로 아웃풋하지 않았거나.

118
00:06:08,905 --> 00:06:10,955
이전에 버려지지 않은 상자를 버리는 겁니다.

119
00:06:10,955 --> 00:06:14,490
따라서 많이 겹쳐지고 높은 IoU를 가졌으며

120
00:06:14,490 --> 00:06:15,945
높은 IoU를 가지고 있으며,

121
00:06:15,945 --> 00:06:20,305
이전 단계에서 아웃풋한 박스를 가진 남아있는 상자를 버리십시오.

122
00:06:20,305 --> 00:06:25,425
while loop 있는 이 두 번째 단계는

123
00:06:25,425 --> 00:06:28,680
이전 슬라이드에서 본 것처럼 남아있는 바운딩 박스를 어둡게 만드는 것입니다.

124
00:06:28,680 --> 00:06:32,310
이것은 더 밝게 만들고 강조했던 바운딩 박스와

125
00:06:32,310 --> 00:06:34,115
많이 겹침 부위를 가지고 있습니다.

126
00:06:34,115 --> 00:06:36,835
그래서, 아직 처리되지 않는 남아있는 박스들이 여전히 있다면

127
00:06:36,835 --> 00:06:40,000
박스 각각을 취해서, 예측 값으로 이것을 아웃풋시키던지

128
00:06:40,000 --> 00:06:45,225
혹은 너무 높은 겹침이나 IoU 때문에

129
00:06:45,225 --> 00:06:48,990
버리게 될 때까지는

130
00:06:48,990 --> 00:06:50,580
여러분은 이것을 계속 진행하십시오.

131
00:06:50,580 --> 00:06:53,550
이 IoU는 탐지된 물체 중 하나의 예측된 자리 때문에

132
00:06:53,550 --> 00:06:58,610
방금 아웃풋했던 상자들 중 하나를 가지고 있습니다.

133
00:07:00,000 --> 00:07:06,640
이 슬라이드에서 단 하나의 객체 만 사용하여 알고리즘을 설명했습니다.

134
00:07:06,640 --> 00:07:10,940
보행자, 자동차, 오토바이 등 3 가지 물체를 실제로 탐지하려고 하면

135
00:07:10,940 --> 00:07:16,215
아웃풋벡터에 3 가지 추가 구성 요소가 생깁니다.

136
00:07:16,215 --> 00:07:18,860
해야 할 일은 각각 non-max억제를

137
00:07:18,860 --> 00:07:22,745
독립적으로 3회 수행하는 것입니다.

138
00:07:22,745 --> 00:07:26,635
아웃풋 클래스 당 하나씩입니다

139
00:07:26,635 --> 00:07:29,475
그러나 그것의 세부 사항은

140
00:07:29,475 --> 00:07:33,132
여러분이 직접 구현할 수 있는 이번 주의 프로그램 예제로 넘기도록 하죠

141
00:07:33,132 --> 00:07:38,912
그 예제들을 통해 다수의 객체 클래스 상에서 non-max 억제를 직접 구현할 수 있습니다.

142
00:07:38,912 --> 00:07:41,210
여기까지 non-max 억제였습니다

143
00:07:41,210 --> 00:07:45,090
우리가 설명한 객체 탐지 알고리즘을 실행한다면

144
00:07:45,090 --> 00:07:48,175
여러분은 꽤 괜찮은 결과를 얻게 됩니다.

145
00:07:48,175 --> 00:07:51,876
그러나 YOLO 알고리즘에 대한 토론을 끝내기 전에

146
00:07:51,876 --> 00:07:54,810
제가 공유하고 싶은 마지막 아이디어가 하나 있습니다

147
00:07:54,810 --> 00:07:57,295
이 아이디어는 알고리즘이 훨씬 잘 작동하도록 만들어 주고

148
00:07:57,295 --> 00:08:00,235
앵커 박스를 사용하는 것입니다. 다음 강의로 넘어가보겠습니다.

149
00:08:00,235 --> 00:08:02,000
다음 동영상으로 넘어 갑시다.