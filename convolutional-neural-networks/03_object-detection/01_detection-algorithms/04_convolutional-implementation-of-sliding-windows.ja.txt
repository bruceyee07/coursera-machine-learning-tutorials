前回のビデオで ConvNet を使った スライディング ウィンドウ 物体検出アルゴリズムについて学んだ
しかし それは とても遅かった このビデオでは そのアルゴリズムを 畳み込む実装方法を学ぶ それが意味するところを見てみましょう スライディング ウィンドウの畳み込み実装を構築するために 最初に見せよう どのように ニューラルネットワークの全結合層を 畳み込み層に 変えることができるのか を 最初は このスライドで それを見せて 次のスライドで このスライドから得たアイデアを使って 畳み込み実装を見せよう では 物体検出アルゴリズムの入力が 14 x 14 x 3 だとする これは とても小さいけど 絵に描くためだ それから  5 x 5 フィルターを使うとしよう そして それを 16個使うものとすると 14 x 14 x 3 は 10 x 10 x 16 に変換される それから 2 x 2 最大プーリングを行い 5 x 5 x 16 に縮める それから 全結合層で 400 ユニットと結合する それから 別の全結合層 そして 最後は ソフトマックス ユニットで y を出力する 次の変化で 必要となるので この絵を少し変更して y を４つの数にする それらは クラスの確率に対応している ソフトマックス ユニットが分類する全クラスの確率だ 全クラスとは 歩行者 車 バイク 背景 もしくは 他の何か 等になるだろう さて 私が見せたいのは どのようにして これらの層を 畳み込み層に 変えられるか だ ConvNet を 最初の数層は 前と同じに描いて そして 今度は この次の層を実装する１つの方法は この全結合層を 5 x 5 フィルターで実装する 400 個の 5 x 5 フィルターを使う つまり もし 5 x 5 x 16 画像を 1つの 5 x 5 フィルターで畳み込むなら 5 x 5 フィルターは 5 x 5 x 16 として実装される なぜなら この１つのフィルターは 16 チャンネル全てに跨がるからね だから この 16 と この 16 が合い 出力は 1 x 1 だ そして もし 400 個の 5 x 5 x 16 フィルターがあるなら 出力次元は 1 x 1 x 400 になる この 400 を 単なるノードの集合として見ずに 1 x 1 x 400 ボリュームとして見ている 数学的には これは 全結合層と同じだ なぜなら この 400 ノードのそれぞれは 5 x 5 x 16 次元のフィルターを持つからだ この 400 個の値の一つ一つが 前の層から 5 x 5 x 16 の線形関数で 活性化されたものだ 次は 次の畳み込み層を実装する 1 x 1 畳み込みを実装する もし 400 個の 1 x 1 フィルターがあるなら 次の層は 400 個のフィルターで また 1 x 1 x 400 だ これが 次の全結合層になる それから 最後は 別の 1 x 1 フィルターだ その後に ソフトマックス活性が続く つまり 1 x 1 x 4 ボリュームにすれば ネットワークが出力する この４つの数になる これが どうやって 全結合層を 畳み込み層で実装するかだ これらの ユニットの集合は 今は 1 x 1 x 400 と 1 x 1 x 4 ボリュームで実装されている この変換の後は スライディング ウィンドウ 物体検出 の 畳み込み実装方法を見よう このスライドのプレゼンは OverFeat 論文が基礎になっている 参照先は 下部の Pierre Sermanet, David Eigen, Xiang Zhang Michael Mathieu, Rob Fergus, そして Yann LeCun スライディング ウィンドウ ConvNet の入力を 14 x 14 x 3 画像だとする 再び この 14 x 14 画像のような小さな数を使う このスライドでは 数や絵を 簡単にしておく 前と同様に 次のようなニューラルネットワークにして だんだんと 出力は 1 x 1 x 4 ボリュームになる これは ソフトマックスの出力だ ここでは 絵を簡単にするため 14 x 14 x 3 は 本当はボリュームだ
5 x 5 も 10 x 10 x 16 も 本当はボリュームだ でも このスライドでは 絵を簡単にするため ボリュームの前の面だけを描く 1 x 1 x 400 ボリュームを描く代わりに その中の 1 x 1 を描く このスライドでは これらの 3D 要素は削除する よって ConvNet の入力は 14 x 14 画像 もしくは 14 x 14 x 3 画像で
テスト画像は 16 x 16 x 3 画像としよう この画像の端に 黄色い帯が加わった オリジナルのスライディング ウインドウ アルゴリズムでは ConvNet には 青い領域を 入力して 実行して クラス 0 か 1 か を出したい
それから 少し下にずらして ２ピクセルのストライドを使う それから 右に２ピクセル スライドし この緑の 四角を ConvNet に入力して ConvNet を走らせて 別のラベル 0 か 1 を得る それから このオレンジの領域を ConvNet に入力して もう一度走らせて 別のラベルを得る それから ４番目 最後に この右下の 紫の四角で それを行う この 16 x 16 x 3 のとても小さい画像に スライディング ウィンドウをかけるには この ConvNet を４回走らせて ４つのラベルを得ればよい しかし この４つの ConvNet で行う 計算の多くは かなり重複している スライディング ウィンドウの畳み込み実装は ConvNet の この４つの準伝播に 計算の多くを共有させる 具体的には こうやってできる ConvNet を同じパラメータで動かす 同じ 5 x 5 フィルターで 同じ16個の 5 x 5 フィルターを使い 動かす そうすると 12 x 12 x 16 出力ボリュームを得る それから 最大プーリングを 前と同じに行う 今度は 6 x 6 x 16 になる 同じ 400個の 5 x 5 フィルターに通すと 今度は 40個の 2 x 2 ボリュームになる 今度は 1 x 1 x 400 ボリュームの代わりに 2 x 2 x 400 ボリュームを得る 1 x 1 フィルターを通すと 1 x 1 x 400 の代わりに 別の 2 x 2 x 400 を得る それを もう一度行って 1 x 1 x 4 の代わりに 2 x 2 x 4 の出力ボリュームを得る この青い 1 x 1 x 4 の一部は 左上角の 14 x 14 画像をかけた結果だ この 1 x 1 x 4 ボリュームの右上 は 右上の結果だ 左下は 左下の 14 x 14 域を ConvNet にかけた結果だ そして 1 x 1 x 4 ボリュームの右下は 右下の 14 x 14 域を ConvNet にかけた結果だ そして もし 計算の全てのステップを行うなら 緑の例を見て もし この領域だけを切り抜き ConvNet の先頭に渡したら 最初の層の活性は この領域ピッタリになる 次の層の活性 最大プーリングの後は ピッタリこの領域で それから 次の層は 次の層は こんな風に続いていく このプロセスが行うのは この 畳み込み実装が行うのは ４つの伝播を走らせる代わりに 入力画像の４つの部分を 別々に処理する代わりに ４つ全てを一つの計算にまとめて 共通する領域の沢山の計算を共有することだ ここにある 14 x 14 の４つの断片全てをね では もっと大きな例に行こう 今度は 28 x 28 x 3 画像に スライディング ウィンドウを走らせたいとする もし 同じ方法で ４つの切り抜きを 走らせたら 8 x 8 x 4 の出力になる これは この 14 x 14 域のスライディング ウィンドウを実行したことに対応している 最初のこの領域での スライディング ウィンドウの実行に対しては 出力の 左上角が対応する それから ウィンドウを ストライド２でずらすと １つのウィンドウ １つのウィンドウ 以下同じで ８つの位置 それで 最初の行が得られ それから 画像を下にも動かす それを全てやると 8 x 8 x 4 の出力を得る なぜなら ２の最大プーリングを使っていて それは 元の画像を ２のストライドを持つ ニューラルネットワークで動かすのに対応しているからだ
(訳注: ここで言う"ニューラルネットワーク"は 畳み込みのことを指していると思われる) まとめると スライディング ウィンドウを実装するには 前のやり方では 領域を切り抜き それが 14 x 14 だとしよう そして ConvNet にかけて 次の領域にもそれを行う それから 次の 14 x 14 域にも行う それから 次 それから 次 それから 次 それから 次 以下同様 うまくいけば これが車を認識する しかし 今度は それを次々と行う代わりに 前のスライドで見た この畳み込み実装を使い 画像全体を実行できる 全て(それは 28 x 28 かもしれない)の予測を 畳み込みで 同時に作成できる この大きな ConvNet への 一度の準伝播で そして うまく行けば 車の位置を認識する これが スライディング ウィンドウの畳み込み実装の方法だ これで 全てが とても効率良くなる ただし このアルゴリズムには １つ欠点がある それは 境界箱の位置が それ程 正確にはならないということだ 次のビデオでは この問題の修正方法を見よう