지금까지 보았듯이 개체 감지 문제 중 하나는 각 그리드 셀이 하나의 개체 만 감지 할 수 있다는 것입니다. 각 그리드 셀이 하나의 개체 만 감지 할 수 있다는 것입니다. 여기 당신이 할 수 있는 것이 있습니다. 앵커 박스의 아이디어를 사용할 수 있습니다. 예를 들어 시작해 보겠습니다 우선 예제를 봅시다. 이런 이미지가 있다고 가정 해 봅시다. 이 예제에서는 3 x 3 그리드를 계속 사용하려고 합니다. 보행자의 중간 점과 차량의 중간 점이 거의 같은 위치에 있고 둘 다 동일한 그리드 셀에 속한다는 점에 유의하십시오 그리드 셀의 경우, Y가 세 가지 클래스, 보행자, 자동차 및 오토바이를 감지 할 때 이 벡터를 아웃풋한다면, 두 가지 감지를 아웃풋할 수 없습니다 그래서 아웃풋 할 두 탐지 중 하나를 선택해야 합니다. anchor box (앵커 박스)에 대한 아이디어를 가지고, 여러분이 해야 할 일은 앵커 박스 또는 앵커 박스모양이라는 두 가지 모양을 미리 정의하는 것입니다. 그리고 여러분이 하려는 일은 두 개의 앵커박스를 가진 두 개의 예측과 연관시킬 수 있는가 입니다. 그리고 일반적으로, 5 개 또는 그 이상의 앵커 박스를 사용할 수 있습니다 그러나 이 강의에서는 설명을 쉽게 하기 위해 앵커 상자 두 개를 사용하려고 합니다. 왼쪽에 있는 이 벡터 대신에 교차 라벨을 어떤 것인지 정의를 내리십시오. 기본적으로 두 번 반복 하는 것입니다. 여러분은 Pc, Px, Py, Ph, Pw, C1, C2, C3를 가질 것이며, 이것들은 앵커 박스 1과 관련된 8 개의 아웃풋입니다. 그리고 나서 여러분은 Pc, Px 그리고 아래로 C1, C2, C3 및 그리고 앵커 박스 2와 관련된 다른 8 개의 아웃풋이 있습니다. 보행자의 모양이 앵커 박스 1 및 앵커 박스 2의 모양과 더 유사하기 때문에 이 8 개의 숫자를 사용하여 Pc= 1로 인코딩 할 수 있습니다. 네, 보행자가 있습니다. 이것을 사용하여 보행자 주변의 바운딩박스를 인코딩 한 다음 이 객체를 사용하여 해당 객체가 보행자임을 인코딩합니다 그리고 자동차 주변의 상자가 앵커 박스 1보다 앵커 박스 2의 모양과 더 유사하기 때문에 이것을 사용하면 이 두 번째 객체가 자동차라는 것을 인코딩 할 수 있습니다. 그리고 바운딩박스가 탐지 된 자동차와 관련된 모든 파라미터가 되도록 해야합니다. 요약하면, 이전에 앵커 박스를 사용하기 전에 다음과 같은 것을 수행했습니다 이것은 트레이닝 세트와 트레이닝 세트 이미지를 위한 것인데요, 객체는 그것의 중간 지점에 해당하는 그리드셀에 할당되는 것이었죠. 그래서 아웃풋 Y는 3 x 3 그리드이기 때문에 3 x 3 x 8입니다. 그리고 각 그리드 위치에서, 우리는 Pc, 바운딩 박스, C1, C2, C3 의 아웃풋 벡터를 앵커박스와 함께 가지고 있었습니다. 여러분은 이제 다음의 것을 하면 됩니다. 이제 각 객체는 이전과 같은 그리드 셀에 할당되고 객체의 중간 점을 포함하는 그리드 셀에 할당되지만 이것은 객체 모양과 함께 가장 높은 IoU를 갖는 그리드 셀을 가진 앵커 상자에 할당됩니다. 따라서 두 개의 앵커 박스가 있습니다. 객체를 가져 와서 보게 됩니다. 그래서 여러분이 이 모양을 가진 객체를 가지고 있다면 두 앵커 박스를 취하세요 어쩌면 하나의 앵커 상자는 앵커 상자 1 인이 모양입니다. 어쩌면 앵커박스 2는 이 모양이고, 두 개중 어느 앵커박스가 더 높은 IoU를 가지고 있는지 알게 되어서 바운딩박스를 통해 그려질 것입니다. 그게 어느 것이든, 그 객체는 그리드 셀이 아니라, 한 쌍으로 할당됩니다 이것은 (그리드 셀, 앵커박스 페어)로 할당됩니다. 이것이 대상 레이블에서 해당 개체가 인코딩되는 방법입니다. 그리고 이제 아웃풋 Y는 3 x 3 x 16이 될 것입니다. 이전 슬라이드에서 보았듯이 Y는 이제 16 차원입니다. 아니면 원하시면, 이것을 3 x 3 x 2 x 8로 볼 수도 있습니다. 2 개의 앵커 상자가 있고 Y는 8 차원이기 때문입니다. Y가 8차원이 되는 것은 세 개의 객체 클래스가 있기 때문입니다. 더 많은 객체들이 있다면, Y 차수는 훨씬 높아질 것입니다. 이제 완전한 예를 들어 봅시다. 이 그리드 셀을 위해 Y를 지정해 봅시다. 보행자는 앵커 박스 1의 모양과 더 유사합니다. 보행자의 경우 이 벡터의 위쪽 절반에 이것을 할당 할 것입니다. 네, 여기 객체가 하나 있습니다 여기에 보행자와 연결된 객체들이 있을 겁니다. 그리고 보행자가 클래스 1 이라면, 우리는 1에는 1, 그 다음에 0, 0 이 됩니다. 자동차의 모양은 앵커 박스 2와 더 유사합니다 그러면 이 벡터의 나머지 부분이 1이 되고 자동차와 연결된 바운딩박스가 있고, 자동차가 C2인 것입니다. 그래서 0, 1, 0 이 됩니다. 이게 바로 이 화살표가 가리키고 있는 가운데 아래 쪽 그리드 셀에 대한 레이블 Y입니다. 자, 이 그리드 셀에 자동차만 있고, 보행자가 없으면 어떻게 될까요? 단지 자동차만 있다면, 자동차 주변에 바운딩박스 모양이 앵커박스 2 와 여전히 더 많이 유사하다고 생각되는데요. 그러면 타겟레이블 Y는 여기 자동차만 있고 보행자는 없다고 생각해보면 앵커박스 2 의 구성요소들과 여전히 똑같을 것입니다. 이 부분이 앵커박스 2 에 상응하는 벡터 부분이라는 것을 기억하십시오. 앵커박스 1에 대한 벡터부분으로 여러분이 할 수 있는 것은 여기엔 객체가 없다고 생각하는 것이죠. 따라서 Pc 는 0이고, 이 나머지 부분은 신경 쓰지 않아도 되는 부분이 됩니다. 몇 가지 덧붙일 세부적인 것들이 있는데요, 만약 앵커박스는 두 개인데, 같은 그리드 셀 안에 세 개의 객체가 있다면 어떻게 될까요? 이게 바로 이 알고리즘이 잘 처리하지 못하는 경우입니다. 이런 일은 생기지 않기를 바랍니다. 이렇게 되면, 이 알고리즘은 이걸 처리하는 좋은 방법이 없습니다. 이 경우를 위해서 디폴트 브레이커 효과를 줘보겠습니다. 똑같은 그리드 셀과 연결된 객체가 두 개가 있고, 그 둘이다 똑같은 앵커박스 모양을 가지고 있다면 어떻게 될까요? 또 다시, 이 알고리즘이 제대로 처리하지 못하는 또 다른 경우입니다. 그러한 일이 생기면, 타이브레이크의 디폴트로 효과를 주십시오. 여러분의 데이터세트에서는 이런 일이 생기지 않길 바랍니다. 이게 그리 많이 생기는 일도 아니고, 이것이 또한 수행력에도 그다지 영향을 미치지 않습니다. 이렇게 해서, 앵커박스에 대한 내용을 다루어 보았습니다. 두 개의 객체가 동일한 그리드 셀에 나타났을 때 처리하는 방법에 대해 앵커 박스에 동기를 부여했지만, 실제에서는, 거의 일어나는 일이 아닙니다. 특히 3 x 3 그리드가 아닌 19 x 19 크기의 그리드를 사용하는 경우에 말이죠. 361개 셀을 가진 두 개의 객체가 같은 중간 점을 가질 확률은, 일어날 수는 있는 일이지만, 그리 흔하지는 않습니다. 앵커박스가 제공하는 훨씬 좋은 동기부여 혹은 훨씬 나은 결과들은 여러분의 알고리즘 학습이 더 전문화되도록 해 줄 것입니다. 특히나, 여러분의 데이터세트가 보행자들처럼 키가 크고 마른 객체이고 자동차같이 약간 하얀 객체들이라면 알고리즘 학습을 전문화 시켜서 몇몇 아웃풋들이 자동차처럼 하얗고, 뚱뚱한 객체들을 인식하는 것을 전문화시켜 줄 것입니다. 몇몇 아웃풋 유닛이 보행자처럼 키 크고 마른 객체들을 인식하는 것을 전문화시켜 줄 것입니다. 마지막으로 앵커 박스는 어떻게 선택하면 되죠? 사람들은 손으로 그것들을 선택하기도 했었고 감지하려고 하는 유형들을 커버할 것으로 보이는 다양한 모양의 앵커박스 모양을 다섯개나 열 개 선택하기도 했었습니다. 훨씬 많이 발전된 버전에 따르면, 그리고, 기계 학습에 대해 다른 지식을 가진 사람들에게는 흔한 발전에 따르면, YOLO 연구 보고서의 하나에서 하고 있는 방법은 K-평균 알고리즘을 사용하는 것입니다. 이렇게 하면, 얻고자 하는 두 개 유형의 객체 모양끼리 그룹화를 수 있죠. 또한, 여러분이 감지하고자 하는 몇 개의, 어쩌면 몇 십개의, 객체클래스의 전형적인 대표원(representative) 즉, 앵커박스 세트를 고르는데에 사용할 수 있습니다. 이것이 앵커박스를 자동적으로 고를 수 있는 훨씬 발전된 방식입니다. 만약 여러분이 다양한 모양들을 손으로 선택한다면, 객체 모양세트를 합리적으로 확장하게 되고, 여러분은 몇 개의 키가 크고 마른 것, 몇 개의 뚱뚱하고 하얀 것을 감지하길 원할 것입니다. 그런 방식 또한 이것들과도 잘 맞을 겁니다. 이것이 바로 앵커박스입니다. 다음 강의에서는, 다음 비디오에서는 그 동안 공부한 것을 모아서, YOLO 알고리즘에서 다 같이 묶어서 보도록 하겠습니다.