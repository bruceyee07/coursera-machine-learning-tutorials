これまでに学んできた物体検出の 問題点の１つは 同じ物体を 複数回 検出するかもしれないことだ 物体を１度だけ検出するのではなく 何回も検出してしまう "Non-Max Suppression" は 物体検出を 一度だけ 行うようにする方法だ 例を見よう この画像の中で 検出したいものを 歩行者 車 そして バイク だとする これに 格子を被せる これは 19 x 19 格子だ 正確には この車は たった１つの中心点を持つ よって これは 単一の格子セルに 紐付けられる 左の車も １つだけ中心点を持つので 正しくは 格子の中の１セルだけが 車があることを予測すべきだ 実際には 物体分類と位置決めアルゴリズムを これらの各セルに対し 実行すると ありがちなことだが このセルで 車の中心があることになり ここでも そうなり ここでも そうなる 左の車についても 同じだ この箱だけでなく これが 前に見たテスト画像なら 車の中心を決めるのは この箱だけでなく この箱や この箱や 他のでも 同様に 車があることになるかもしれない "Non-Max Suppression" が どのように動くのか 順を追って見ていこう 全てのセルで 画像の 分類と位置決めアルゴリズムを 動かすので 361 個の格子セルでね それらの多くが 手を上げて こう言うかもしれない "私のPc 私の所に物体がある確率が 大きいよ" 19 の２乗 361個のセルの中で ２つだけが 物体検出するのではなくね つまり アルゴリズムを走らせると 物体毎に 複数個の検出が出るかもしれない そこで "Non-Max Suppression" は これらの検出を整理する 車あたり１つだけの検出にする 複数の検出をしないようにする 具体的には こうする 最初は これらの検出のそれぞれの確率を見て Pc のようなもののことだ ただし 今週のプログラミング演習で 詳細は学ぶけど それは 実際には Pc かける C1 や C2 や C3 だ でも 今は 検出の確率を Pc としておく そして 最初に 一番大きなものを取り出す この場合は 0.9 だ これが 最も自信ある検出だ じゃ これをハイライトして "ここに車がある" と言えばいい それが終わったら "Non-Max Suppresion" は 残りの全ての四角から 重なりが大きいもの全て 今 出力した これに対して 高い IoU を持つものは 出さない つまり この 0.6 と 0.7 の四角は出力しない この ライトブルーの四角と重なりが大きいのは どちらも出力しない これらは 抑制されるので 暗くして 抑制されたことを示そう 次に 残りの四角を処理する 最も高い確率を持つものを 最も高い Pc のものを探す 今度は 0.8 の これになる だから それを信じて こう言えばいい "おー ここに車を見つけた" それから "Non-Max Suppression" は 高い IoU を持つ他のものを取り除く これで 全ての四角が ハイライト もしくは 暗くされた そして 暗くした四角を取り除けば ハイライトしたものだけが残る これらが ２つの最終予測だ これが "Non-Max Suppression" だ "Non-Max" が意味するは 分類の最大確率のものを 出力するが 近傍にある最大でないものを除く ということだ だから 名前が ”Non-Max Suppresion"(非-最大 抑制) では アルゴリズムの詳細に行こう 最初に 19 x 19 格子で 19 x 19 x 8 出力ボリュームを得る ただし この例では 簡単のため 車の検出だけを行う つまり C1 C2 C3 を取り除く そして このスライドでは 各 19 x 19 それぞれに対する 出力は つまり 361 個のそれぞれに対する出力は それは 19の２乗だけど 361 個の位置 それぞれの出力は 次のようなものになる これは 物体の存在確率で それから 境界箱だ たった１種類の物体なので C1 C2 C3 予測は無い 複数の種類の物体がある場合 何が起きるか 詳細は プログラミング演習に残すよ 今週の終わりに やることになっているから さて "Non-Max Suppresion" を実装するのに 最初にできるのは 全ての この箱を捨てることだ 全ての この境界箱の予測を捨てる Pc が ある閾値 例えば 0.6 とか より 小さいものをだ つまり こう言おう 少なくとも 物体の存在確率が 0.6 無いと思うなら 取り除こう と こうして 低確率の箱を 全て 捨てる それを この 361個の位置それぞれで 考える 境界箱を 存在確率と一緒に出力して 低確率の境界箱全てを 単に捨てる 次に 捨てずに残った境界箱があるなら 一番高い存在確率の箱を選ぶことを繰り返す 一番高い Pc のをだ それから それを予測として出力する これは 前のスライドで見た処理で 境界箱から１つを取り出す そして 明るい色にする そして そこに車があるという予測を 確固として出力する 次に 残りの箱を捨て去る 予測として出力しなかった箱だ それは 前の処理では 捨てられていなかった 前のステップで出力した箱と 高い重なり度を持った残りの箱 高い IoU の箱を捨てる この while ループの２番目は 前のスライドで ハイライトさせて 明るくした境界箱と 重なりが大きい境界箱を 暗くした時の処理だ そして この処理を続ける 未処理の境界箱がある限り続ける 各箱を予測として出力するか 捨てるかするまで続ける
捨てるのは 重なりが大きすぎる IoU が高すぎる のものであり その IoU は 物体の位置予測に使った 箱に対してのものだ このスライドでは 単一物体を使ったアルゴリズムを説明した もし 実際には ３物体の検出をするのなら 歩行者 車 そして バイク の検出をするなら 出力ベクトルには ３つの要素が追加される そして 分かると思うが やるべきことは 独立して "Non-Max Suppression" を ３度行うことだ 出力クラスそれぞれに対してだ でも その詳細は あなた自身で実装することになる 今週のプログラミング演習に残しておく そこでは 複数種類の物体についての "Non-Max Suppression" を あなた自分で実装することになる 以上が "Non-Max Suppresion" だ 今まで説明してきた 物体検出アルゴリズムを実装すれば とても良い結果を得る だけど YOLO アルゴリズムの議論をまとめる前に 共有しておきたいアイデアが１つある それによって アルゴリズムは とても良くなる それは アンカーボックスを使うというアイデアだ 次のビデオに進みましょう