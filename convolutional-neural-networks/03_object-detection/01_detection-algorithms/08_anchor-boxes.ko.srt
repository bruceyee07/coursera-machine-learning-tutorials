1
00:00:00,000 --> 00:00:04,790
지금까지 보았듯이 개체 감지 문제 중 하나는

2
00:00:04,790 --> 00:00:08,870
각 그리드 셀이 하나의 개체 만 감지 할 수 있다는 것입니다.

3
00:00:08,870 --> 00:00:12,500
각 그리드 셀이 하나의 개체 만 감지 할 수 있다는 것입니다.

4
00:00:12,500 --> 00:00:14,050
여기 당신이 할 수 있는 것이 있습니다.

5
00:00:14,050 --> 00:00:16,700
앵커 박스의 아이디어를 사용할 수 있습니다. 예를 들어 시작해 보겠습니다

6
00:00:16,700 --> 00:00:17,920
우선 예제를 봅시다.

7
00:00:17,920 --> 00:00:20,990
이런 이미지가 있다고 가정 해 봅시다.

8
00:00:20,990 --> 00:00:22,460
이 예제에서는

9
00:00:22,460 --> 00:00:26,160
3 x 3 그리드를 계속 사용하려고 합니다.

10
00:00:26,160 --> 00:00:31,190
보행자의 중간 점과 차량의 중간 점이 거의 같은 위치에 있고

11
00:00:31,190 --> 00:00:37,340
둘 다 동일한 그리드 셀에 속한다는 점에 유의하십시오

12
00:00:37,340 --> 00:00:38,590
그리드 셀의 경우,

13
00:00:38,590 --> 00:00:44,559
Y가 세 가지 클래스, 보행자, 자동차 및 오토바이를 감지 할 때

14
00:00:44,559 --> 00:00:48,105
이 벡터를 아웃풋한다면,

15
00:00:48,105 --> 00:00:51,530
두 가지 감지를 아웃풋할 수 없습니다

16
00:00:51,530 --> 00:00:55,545
그래서 아웃풋 할 두 탐지 중 하나를 선택해야 합니다.

17
00:00:55,545 --> 00:00:57,297
anchor box (앵커 박스)에 대한 아이디어를 가지고,

18
00:00:57,297 --> 00:00:59,170
여러분이 해야 할 일은

19
00:00:59,170 --> 00:01:03,129
앵커 박스 또는 앵커 박스모양이라는 두 가지 모양을 미리 정의하는 것입니다.

20
00:01:03,129 --> 00:01:08,015
그리고 여러분이 하려는 일은

21
00:01:08,015 --> 00:01:13,085
두 개의 앵커박스를 가진 두 개의 예측과 연관시킬 수 있는가 입니다.

22
00:01:13,085 --> 00:01:15,585
그리고 일반적으로, 5 개 또는 그 이상의

23
00:01:15,585 --> 00:01:17,660
앵커 박스를 사용할 수 있습니다

24
00:01:17,660 --> 00:01:20,060
그러나 이 강의에서는 설명을 쉽게 하기 위해

25
00:01:20,060 --> 00:01:23,660
앵커 상자 두 개를 사용하려고 합니다.

26
00:01:23,660 --> 00:01:27,680
왼쪽에 있는 이 벡터 대신에

27
00:01:27,680 --> 00:01:30,190
교차 라벨을 어떤 것인지 정의를 내리십시오.

28
00:01:30,190 --> 00:01:33,170
기본적으로 두 번 반복 하는 것입니다.

29
00:01:33,170 --> 00:01:35,120
여러분은 Pc, Px, Py,

30
00:01:35,120 --> 00:01:39,610
Ph, Pw, C1, C2, C3를 가질 것이며,

31
00:01:39,610 --> 00:01:46,047
이것들은 앵커 박스 1과 관련된 8 개의 아웃풋입니다.

32
00:01:46,047 --> 00:01:50,355
그리고 나서 여러분은 Pc, Px

33
00:01:50,355 --> 00:01:51,905
그리고 아래로 C1, C2, C3 및

34
00:01:51,905 --> 00:01:59,490
그리고 앵커 박스 2와 관련된 다른 8 개의 아웃풋이 있습니다.

35
00:01:59,490 --> 00:02:01,820
보행자의 모양이

36
00:02:01,820 --> 00:02:06,012
앵커 박스 1 및 앵커 박스 2의 모양과 더 유사하기 때문에

37
00:02:06,012 --> 00:02:13,730
이 8 개의 숫자를 사용하여 Pc= 1로 인코딩 할 수 있습니다.

38
00:02:13,730 --> 00:02:15,020
네, 보행자가 있습니다.

39
00:02:15,020 --> 00:02:20,739
이것을 사용하여 보행자 주변의 바운딩박스를 인코딩 한 다음

40
00:02:20,739 --> 00:02:26,300
이 객체를 사용하여 해당 객체가 보행자임을 인코딩합니다

41
00:02:26,300 --> 00:02:29,240
그리고 자동차 주변의 상자가

42
00:02:29,240 --> 00:02:32,516
앵커 박스 1보다 앵커 박스 2의 모양과 더 유사하기 때문에

43
00:02:32,516 --> 00:02:40,021
이것을 사용하면 이 두 번째 객체가 자동차라는 것을 인코딩 할 수 있습니다.

44
00:02:40,021 --> 00:02:42,830
그리고 바운딩박스가 탐지 된 자동차와 관련된

45
00:02:42,830 --> 00:02:45,984
모든 파라미터가 되도록 해야합니다.

46
00:02:45,984 --> 00:02:50,459
요약하면, 이전에

47
00:02:50,459 --> 00:02:51,693
앵커 박스를 사용하기 전에

48
00:02:51,693 --> 00:02:53,505
다음과 같은 것을 수행했습니다

49
00:02:53,505 --> 00:02:57,665
이것은 트레이닝 세트와 트레이닝 세트 이미지를 위한 것인데요,

50
00:02:57,665 --> 00:03:03,580
객체는 그것의 중간 지점에 해당하는 그리드셀에 할당되는 것이었죠.

51
00:03:03,580 --> 00:03:11,298
그래서 아웃풋 Y는 3 x 3 그리드이기 때문에 3 x 3 x 8입니다.

52
00:03:11,298 --> 00:03:13,400
그리고 각 그리드 위치에서,

53
00:03:13,400 --> 00:03:17,080
우리는 Pc, 바운딩 박스, C1, C2, C3 의 아웃풋 벡터를

54
00:03:17,080 --> 00:03:18,892
앵커박스와 함께 가지고 있었습니다.

55
00:03:18,892 --> 00:03:21,877
여러분은 이제 다음의 것을 하면 됩니다.

56
00:03:21,877 --> 00:03:27,553
이제 각 객체는 이전과 같은 그리드 셀에 할당되고

57
00:03:27,553 --> 00:03:29,860
객체의 중간 점을 포함하는 그리드 셀에 할당되지만

58
00:03:29,860 --> 00:03:33,488
이것은 객체 모양과 함께 가장 높은 IoU를 갖는

59
00:03:33,488 --> 00:03:41,020
그리드 셀을 가진 앵커 상자에 할당됩니다.

60
00:03:41,020 --> 00:03:43,070
따라서 두 개의 앵커 박스가 있습니다.

61
00:03:43,070 --> 00:03:45,845
객체를 가져 와서 보게 됩니다.

62
00:03:45,845 --> 00:03:50,060
그래서 여러분이 이 모양을 가진 객체를 가지고 있다면

63
00:03:50,060 --> 00:03:53,270
두 앵커 박스를 취하세요

64
00:03:53,270 --> 00:03:55,286
어쩌면 하나의 앵커 상자는 앵커 상자 1 인이 모양입니다.

65
00:03:55,286 --> 00:03:58,325
어쩌면 앵커박스 2는 이 모양이고,

66
00:03:58,325 --> 00:04:01,940
두 개중 어느 앵커박스가 더 높은 IoU를 가지고 있는지 알게 되어서

67
00:04:01,940 --> 00:04:04,500
바운딩박스를 통해 그려질 것입니다.

68
00:04:04,500 --> 00:04:05,810
그게 어느 것이든,

69
00:04:05,810 --> 00:04:11,055
그 객체는 그리드 셀이 아니라, 한 쌍으로 할당됩니다

70
00:04:11,055 --> 00:04:18,905
이것은 (그리드 셀, 앵커박스 페어)로 할당됩니다.

71
00:04:18,905 --> 00:04:22,985
이것이 대상 레이블에서 해당 개체가 인코딩되는 방법입니다.

72
00:04:22,985 --> 00:04:31,505
그리고 이제 아웃풋 Y는 3 x 3 x 16이 될 것입니다.

73
00:04:31,505 --> 00:04:34,120
이전 슬라이드에서 보았듯이

74
00:04:34,120 --> 00:04:36,610
Y는 이제 16 차원입니다.

75
00:04:36,610 --> 00:04:37,788
아니면 원하시면,

76
00:04:37,788 --> 00:04:42,565
이것을 3 x 3 x 2 x 8로 볼 수도 있습니다.

77
00:04:42,565 --> 00:04:48,675
2 개의 앵커 상자가 있고 Y는 8 차원이기 때문입니다.

78
00:04:48,675 --> 00:04:54,516
Y가 8차원이 되는 것은 세 개의 객체 클래스가 있기 때문입니다.

79
00:04:54,516 --> 00:05:01,070
더 많은 객체들이 있다면, Y 차수는 훨씬 높아질 것입니다.

80
00:05:01,070 --> 00:05:04,890
이제 완전한 예를 들어 봅시다.

81
00:05:04,890 --> 00:05:09,040
이 그리드 셀을 위해

82
00:05:09,040 --> 00:05:12,070
Y를 지정해 봅시다.

83
00:05:12,070 --> 00:05:21,075
보행자는 앵커 박스 1의 모양과 더 유사합니다.

84
00:05:21,075 --> 00:05:22,280
보행자의 경우

85
00:05:22,280 --> 00:05:25,620
이 벡터의 위쪽 절반에 이것을 할당 할 것입니다.

86
00:05:25,620 --> 00:05:27,235
네, 여기 객체가 하나 있습니다

87
00:05:27,235 --> 00:05:31,150
여기에 보행자와 연결된 객체들이 있을 겁니다.

88
00:05:31,150 --> 00:05:33,734
그리고 보행자가 클래스 1 이라면,

89
00:05:33,734 --> 00:05:36,665
우리는 1에는 1, 그 다음에 0, 0 이 됩니다.

90
00:05:36,665 --> 00:05:41,420
자동차의 모양은 앵커 박스 2와 더 유사합니다

91
00:05:41,420 --> 00:05:43,430
그러면 이 벡터의 나머지 부분이 1이 되고

92
00:05:43,430 --> 00:05:47,960
자동차와 연결된 바운딩박스가 있고,

93
00:05:47,960 --> 00:05:51,330
자동차가 C2인 것입니다.

94
00:05:51,330 --> 00:05:53,170
그래서 0, 1, 0 이 됩니다.

95
00:05:53,170 --> 00:05:56,715
이게 바로 이 화살표가 가리키고 있는

96
00:05:56,715 --> 00:06:02,685
가운데 아래 쪽 그리드 셀에 대한 레이블 Y입니다.

97
00:06:02,685 --> 00:06:09,760
자, 이 그리드 셀에 자동차만 있고, 보행자가 없으면 어떻게 될까요?

98
00:06:09,760 --> 00:06:11,410
단지 자동차만 있다면,

99
00:06:11,410 --> 00:06:14,300
자동차 주변에 바운딩박스 모양이

100
00:06:14,300 --> 00:06:18,460
앵커박스 2 와 여전히 더 많이 유사하다고 생각되는데요.

101
00:06:18,460 --> 00:06:20,410
그러면 타겟레이블 Y는

102
00:06:20,410 --> 00:06:24,325
여기 자동차만 있고 보행자는 없다고 생각해보면

103
00:06:24,325 --> 00:06:30,271
앵커박스 2 의 구성요소들과 여전히 똑같을 것입니다.

104
00:06:30,271 --> 00:06:37,530
이 부분이 앵커박스 2 에 상응하는 벡터 부분이라는 것을 기억하십시오.

105
00:06:37,530 --> 00:06:42,590
앵커박스 1에 대한 벡터부분으로

106
00:06:42,590 --> 00:06:46,017
여러분이 할 수 있는 것은 여기엔 객체가 없다고 생각하는 것이죠.

107
00:06:46,017 --> 00:06:47,912
따라서 Pc 는 0이고,

108
00:06:47,912 --> 00:06:52,900
이 나머지 부분은 신경 쓰지 않아도 되는 부분이 됩니다.

109
00:06:52,900 --> 00:06:55,155
몇 가지 덧붙일 세부적인 것들이 있는데요,

110
00:06:55,155 --> 00:06:59,730
만약 앵커박스는 두 개인데, 같은 그리드 셀 안에 세 개의 객체가 있다면 어떻게 될까요?

111
00:06:59,730 --> 00:07:04,000
이게 바로 이 알고리즘이 잘 처리하지 못하는 경우입니다.

112
00:07:04,000 --> 00:07:06,705
이런 일은 생기지 않기를 바랍니다.

113
00:07:06,705 --> 00:07:11,440
이렇게 되면, 이 알고리즘은 이걸 처리하는 좋은 방법이 없습니다.

114
00:07:11,440 --> 00:07:15,025
이 경우를 위해서 디폴트 브레이커 효과를 줘보겠습니다.

115
00:07:15,025 --> 00:07:17,160
똑같은 그리드 셀과 연결된 객체가 두 개가 있고,

116
00:07:17,160 --> 00:07:21,316
그 둘이다 똑같은 앵커박스 모양을 가지고 있다면 어떻게 될까요?

117
00:07:21,316 --> 00:07:24,335
또 다시, 이 알고리즘이 제대로 처리하지 못하는 또 다른 경우입니다.

118
00:07:24,335 --> 00:07:28,855
그러한 일이 생기면, 타이브레이크의 디폴트로 효과를 주십시오.

119
00:07:28,855 --> 00:07:31,101
여러분의 데이터세트에서는 이런 일이 생기지 않길 바랍니다.

120
00:07:31,101 --> 00:07:32,740
이게 그리 많이 생기는 일도 아니고,

121
00:07:32,740 --> 00:07:35,834
이것이 또한 수행력에도 그다지 영향을 미치지 않습니다.

122
00:07:35,834 --> 00:07:38,575
이렇게 해서, 앵커박스에 대한 내용을 다루어 보았습니다.

123
00:07:38,575 --> 00:07:42,370
두 개의 객체가 동일한 그리드 셀에 나타났을 때

124
00:07:42,370 --> 00:07:46,880
처리하는 방법에 대해 앵커 박스에 동기를 부여했지만,

125
00:07:46,880 --> 00:07:49,345
실제에서는, 거의 일어나는 일이 아닙니다.

126
00:07:49,345 --> 00:07:54,335
특히 3 x 3 그리드가 아닌 19 x 19 크기의 그리드를 사용하는 경우에 말이죠.

127
00:07:54,335 --> 00:07:59,065
361개 셀을 가진 두 개의 객체가 같은 중간 점을 가질 확률은,

128
00:07:59,065 --> 00:08:02,340
일어날 수는 있는 일이지만, 그리 흔하지는 않습니다.

129
00:08:02,340 --> 00:08:06,810
앵커박스가 제공하는 훨씬 좋은 동기부여 혹은 훨씬 나은 결과들은

130
00:08:06,810 --> 00:08:12,325
여러분의 알고리즘 학습이 더 전문화되도록 해 줄 것입니다.

131
00:08:12,325 --> 00:08:15,400
특히나, 여러분의 데이터세트가

132
00:08:15,400 --> 00:08:17,380
보행자들처럼 키가 크고 마른 객체이고

133
00:08:17,380 --> 00:08:20,245
자동차같이 약간 하얀 객체들이라면

134
00:08:20,245 --> 00:08:23,590
알고리즘 학습을 전문화 시켜서

135
00:08:23,590 --> 00:08:27,115
몇몇 아웃풋들이 자동차처럼 하얗고, 뚱뚱한

136
00:08:27,115 --> 00:08:28,750
객체들을 인식하는 것을 전문화시켜 줄 것입니다.

137
00:08:28,750 --> 00:08:32,243
몇몇 아웃풋 유닛이 보행자처럼 키 크고

138
00:08:32,243 --> 00:08:34,830
마른 객체들을 인식하는 것을 전문화시켜 줄 것입니다.

139
00:08:34,830 --> 00:08:38,005
마지막으로 앵커 박스는 어떻게 선택하면 되죠?

140
00:08:38,005 --> 00:08:43,435
사람들은 손으로 그것들을 선택하기도 했었고

141
00:08:43,435 --> 00:08:46,270
감지하려고 하는 유형들을 커버할 것으로 보이는 다양한 모양의

142
00:08:46,270 --> 00:08:49,510
앵커박스 모양을 다섯개나 열 개 선택하기도 했었습니다.

143
00:08:49,510 --> 00:08:51,505
훨씬 많이 발전된 버전에 따르면,

144
00:08:51,505 --> 00:08:55,890
그리고, 기계 학습에 대해 다른 지식을 가진 사람들에게는 흔한 발전에 따르면,

145
00:08:55,890 --> 00:09:00,385
YOLO 연구 보고서의 하나에서 하고 있는 방법은

146
00:09:00,385 --> 00:09:02,430
K-평균 알고리즘을 사용하는 것입니다.

147
00:09:02,430 --> 00:09:05,795
이렇게 하면, 얻고자 하는 두 개 유형의 객체 모양끼리 그룹화를 수 있죠.

148
00:09:05,795 --> 00:09:09,150
또한, 여러분이 감지하고자 하는

149
00:09:09,150 --> 00:09:13,140
몇 개의, 어쩌면 몇 십개의, 객체클래스의 전형적인 대표원(representative)

150
00:09:13,140 --> 00:09:16,330
즉, 앵커박스 세트를 고르는데에 사용할 수 있습니다.

151
00:09:16,330 --> 00:09:20,915
이것이 앵커박스를 자동적으로 고를 수 있는 훨씬 발전된 방식입니다.

152
00:09:20,915 --> 00:09:24,160
만약 여러분이 다양한 모양들을 손으로 선택한다면,

153
00:09:24,160 --> 00:09:27,580
객체 모양세트를 합리적으로 확장하게 되고,

154
00:09:27,580 --> 00:09:29,260
여러분은 몇 개의 키가 크고 마른 것,

155
00:09:29,260 --> 00:09:31,270
몇 개의 뚱뚱하고 하얀 것을 감지하길 원할 것입니다.

156
00:09:31,270 --> 00:09:33,535
그런 방식 또한 이것들과도 잘 맞을 겁니다.

157
00:09:33,535 --> 00:09:34,760
이것이 바로 앵커박스입니다. 다음 강의에서는,

158
00:09:34,760 --> 00:09:37,120
다음 비디오에서는

159
00:09:37,120 --> 00:09:42,000
그 동안 공부한 것을 모아서, YOLO 알고리즘에서 다 같이 묶어서 보도록 하겠습니다.