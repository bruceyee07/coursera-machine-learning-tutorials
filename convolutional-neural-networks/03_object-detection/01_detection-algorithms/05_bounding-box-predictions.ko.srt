1
00:00:00,000 --> 00:00:01,380
지난 강의에서

2
00:00:01,380 --> 00:00:06,300
마지막 강의에서는 슬라이딩 윈도우의 컨볼루션 구현을 사용하는 방법을 배웠습니다.

3
00:00:06,300 --> 00:00:08,780
계산 상 효율적이지만,

4
00:00:08,780 --> 00:00:14,130
여전히 가장 정확한 바운딩 박스를 아웃풋 하지 못하는 문제가 있습니다.

5
00:00:14,130 --> 00:00:16,710
이 강의에서는 바운딩 박스 예측을

6
00:00:16,710 --> 00:00:19,520
보다 정확 하게하는 방법을 함께 보시죠.

7
00:00:19,520 --> 00:00:21,495
슬라이딩 윈도우로

8
00:00:21,495 --> 00:00:26,190
이 별개의 위치들을 가져 와서, 가로질러 크로스파이어를 실행합니다. 이 경우 10

9
00:00:26,190 --> 00:00:27,825
이 경우

10
00:00:27,825 --> 00:00:32,636
어느 상자도 자동차 위치와 완벽하게 일치하지 않습니다.

11
00:00:32,636 --> 00:00:35,900
어쩌면 이 상자가 가장 잘 어울리는 것일 수도 있습니다.

12
00:00:35,900 --> 00:00:38,465
또한 완벽하게 바운딩 박스가 완전히 정사각형이 아니기 때문에

13
00:00:38,465 --> 00:00:41,585
실제로는 약간 더 넓은 직사각형 또는

14
00:00:41,585 --> 00:00:48,750
약간 수평으로 가로 세로 비율이 그려져 있는 것처럼 보입니다.

15
00:00:48,750 --> 00:00:53,975
이 알고리즘이 더 정확한 바운딩 박스를 아웃풋하도록 하는 방법이 있을까요?

16
00:00:53,975 --> 00:00:59,275
이 아웃풋을 더 정확하게 바운딩 박스로 가져 오는 좋은 방법은 YOLO 알고리즘을 사용하는 것입니다.

17
00:00:59,275 --> 00:01:03,225
YOLO는 You Only Look Once의 약자입니다.

18
00:01:03,225 --> 00:01:06,195
그리고 이들 Joseph Redmon, Santosh Divvala, Ross Girshick 및 Ali Farhadi에 의한

19
00:01:06,195 --> 00:01:07,975
의한 알고리즘입니다

20
00:01:07,975 --> 00:01:10,735
여기 당신이 해야 할 일이 있습니다.

21
00:01:10,735 --> 00:01:14,230
인풋 이미지가 100 x 100 인 경우

22
00:01:14,230 --> 00:01:17,175
이 이미지에 그리드를 배치한다고 가정 해 보겠습니다.

23
00:01:17,175 --> 00:01:19,425
설명을 위해

24
00:01:19,425 --> 00:01:21,780
3 x 3 그리드를 사용하려고 합니다

25
00:01:21,780 --> 00:01:23,640
실제 구현에서는

26
00:01:23,640 --> 00:01:24,840
19 x 19 그리드와 같이

27
00:01:24,840 --> 00:01:27,880
더 미세한 그리드를 사용합니다.

28
00:01:27,880 --> 00:01:30,660
그리고 기본 아이디어는

29
00:01:30,660 --> 00:01:36,345
몇몇 강의에서 보셨던 이미지 분류 및 위치 측정 알고리즘을 사용하여

30
00:01:36,345 --> 00:01:40,165
9 개의 각 그리드에 적용하는 것입니다.

31
00:01:40,165 --> 00:01:47,910
기본 아이디어는 이번 주 첫 강의에서 보셨던

32
00:01:47,910 --> 00:01:52,170
이미지 분류 및 위치 측정 알고리즘을 가지고

33
00:01:52,170 --> 00:01:58,440
9 개의 각 그리드에 적용하는 것입니다.

34
00:01:58,440 --> 00:01:59,851
좀 더 구체적으로,

35
00:01:59,851 --> 00:02:05,171
여기에 훈련용으로 사용하는 레이블을 정의하는 방법이 있습니다.

36
00:02:05,171 --> 00:02:08,070
따라서 9 개의 그리드 셀 각각에 대해, 레이블 Y를 지정합니다

37
00:02:08,070 --> 00:02:14,561
여기서 레이블 Y는 이전에 본 것처럼

38
00:02:14,561 --> 00:02:16,470
8 차원 벡터입니다.

39
00:02:16,470 --> 00:02:19,610
해당 그리드 셀에 이미지가 있는지 여부에 따라 PC 01을 아웃풋한 다음

40
00:02:19,610 --> 00:02:24,170
bx, by, bh, bw을 사용해서

41
00:02:24,170 --> 00:02:30,800
이미지가 있고, 그리드 셀에 연관된 객체가 있으면

42
00:02:30,800 --> 00:02:33,348
바운딩박스를 구체화시킵니다.

43
00:02:33,348 --> 00:02:36,320
그런 다음 C1, C2, C3,

44
00:02:36,320 --> 00:02:40,935
배경 클래스를 세지 않고, 세 클래스를 시도하고 인식하십시오.

45
00:02:40,935 --> 00:02:43,120
그래서 당신은 보행자 클래스,

46
00:02:43,120 --> 00:02:45,110
오토바이 및 백그라운드 클래스를 인식하려고 합니다.

47
00:02:45,110 --> 00:02:47,720
C1 C2 C3 는 보행자,

48
00:02:47,720 --> 00:02:50,570
자동차 그리고 오토바이 클래스를 말합니다.

49
00:02:50,570 --> 00:02:52,505
이 이미지에서

50
00:02:52,505 --> 00:02:53,870
우리는 9 개의 그리드 셀을 가지므로

51
00:02:53,870 --> 00:02:59,105
각 그리드 셀에 대해 이와 같은 벡터를 가집니다.

52
00:02:59,105 --> 00:03:02,316
그러면 왼쪽 상단 그리드 셀부터 시작해 봅시다.

53
00:03:02,316 --> 00:03:03,955
이 위쪽에 있는 것은

54
00:03:03,955 --> 00:03:06,115
여기엔 객체가 없죠.

55
00:03:06,115 --> 00:03:11,960
왼쪽 위의 그리드 셀에 대한 레이블 벡터 Y는 0이 될 것이고

56
00:03:11,960 --> 00:03:16,655
나머지는 고려하지 않을 것입니다.

57
00:03:16,655 --> 00:03:20,707
아웃풋 레이블 Y는 이 그리드 셀과 이 그리드 셀,

58
00:03:20,707 --> 00:03:24,640
그리고 아무 것도 없는 모든 그리드 셀에 대해 같을 것입니다.

59
00:03:24,640 --> 00:03:27,845
모두 흥미로운 객체는 없습니다

60
00:03:27,845 --> 00:03:32,435
자, 이 그리드 셀은 어떻습니까?

61
00:03:32,435 --> 00:03:34,385
좀 더 자세히 설명하기 위해

62
00:03:34,385 --> 00:03:36,355
이 이미지에는 두 개의 객체가 있습니다.

63
00:03:36,355 --> 00:03:40,270
YOLO 알고리즘이 수행하는 작업은 두 객체의 도달 중간 점을 취한 다음,

64
00:03:40,270 --> 00:03:45,690
중간 점을 포함하는 그리드 셀에 이 객체를 할당하는 것입니다.

65
00:03:45,690 --> 00:03:49,900
따라서 왼쪽 자동차는 이 그리드 셀에 지정되고,

66
00:03:49,900 --> 00:03:51,445
이 오른쪽 차는,

67
00:03:51,445 --> 00:03:53,140
이 중간 점이,

68
00:03:53,140 --> 00:03:57,265
이 그리드 셀에 지정됩니다.

69
00:03:57,265 --> 00:04:02,510
중앙 그리드 셀에는 두 자동차의 일부가 있지만

70
00:04:02,510 --> 00:04:06,175
중앙 그리드 셀은 흥미로운 객체가 없다고 생각해서

71
00:04:06,175 --> 00:04:11,560
중앙 그리드 셀인 레이블 Y 클래스는 객체가 없는 이 벡터처럼 보이게 됩니다.

72
00:04:11,560 --> 00:04:13,450
따라서 첫 번째 구성 요소는 PC가 되고,

73
00:04:13,450 --> 00:04:15,000
나머지는 상관없음이 됩니다.

74
00:04:15,000 --> 00:04:17,091
반면에 이 셀에는,

75
00:04:17,091 --> 00:04:21,005
왼쪽에 초록색으로 동그라미 해 놓은 이 셀,

76
00:04:21,005 --> 00:04:23,765
타겟 레이블 Y는 다음과 같습니다.

77
00:04:23,765 --> 00:04:25,085
객체가 없고

78
00:04:25,085 --> 00:04:26,770
바운딩 박스의 위치를 구체화시키기 위해

79
00:04:26,770 --> 00:04:32,830
bx, by, bh, bw를 씁니다.

80
00:04:32,830 --> 00:04:34,870
그럼 한 번 봅시다.

81
00:04:34,870 --> 00:04:38,680
클래스 1이 보행자라면, 그것은 0입니다.

82
00:04:38,680 --> 00:04:40,420
클래스 2는 자동차 입니다.

83
00:04:40,420 --> 00:04:43,960
클래스 3은 오토바이였는데, 0 이죠.

84
00:04:43,960 --> 00:04:45,900
그리고 비슷하게, 오른쪽에 있는 그리드 셀은

85
00:04:45,900 --> 00:04:48,415
그 안에 객체가 있기 때문에

86
00:04:48,415 --> 00:04:52,690
오른쪽에 있는 그리드 셀에 해당하는 대상 레이블과

87
00:04:52,690 --> 00:04:58,325
같은 벡터를 갖게 됩니다

88
00:04:58,325 --> 00:05:00,715
따라서 이러한 9 개의 그리드 셀 각각에 대해

89
00:05:00,715 --> 00:05:04,815
결국 8 차원 아웃풋 벡터를 가지게 됩니다.

90
00:05:04,815 --> 00:05:08,415
그리고 당신은 3 x 3 그리드 셀을 가지고 있기 때문에,

91
00:05:08,415 --> 00:05:09,863
9 개의 그리드 셀을 가지게 됩니다.

92
00:05:09,863 --> 00:05:17,435
아웃풋의 전체 볼륨은 3 x 3이 될 것입니다.

93
00:05:17,435 --> 00:05:24,760
그래서 3x3 그리드 셀을 가지고 있기 때문에 목표 아웃풋은 3 x 3 x 8 이 될 것입니다.

94
00:05:24,760 --> 00:05:28,045
각각의 3 x 3 그리드 셀에서

95
00:05:28,045 --> 00:05:32,790
8 차원 벡터 Y를 가지고 있습니다.

96
00:05:32,790 --> 00:05:36,250
따라서 목표 아웃풋 볼륨은 3 x 3 x 8이고,

97
00:05:36,250 --> 00:05:41,245
예를 들어, 이 왼쪽 상단에서 1 x 1 x 8볼륨

98
00:05:41,245 --> 00:05:42,970
9개 그리드 셀의 왼쪽 상단에 있는

99
00:05:42,970 --> 00:05:47,770
목표 아웃풋에 일치합니다.

100
00:05:47,770 --> 00:05:50,710
그리고 3 x 3 위치 각각에 대해,

101
00:05:50,710 --> 00:05:52,345
각 9개 그리드 셀에서

102
00:05:52,345 --> 00:05:58,180
이것은 각각에 대해 아웃풋하고자 하는 8 차원 목표 벡터 Y에 해당합니다.

103
00:05:58,180 --> 00:05:59,610
거기에 객체가 없다면

104
00:05:59,610 --> 00:06:01,010
이는 '상관없음' 벡터를 가질 것입니다.

105
00:06:01,010 --> 00:06:03,360
이런 이유로 총 목표 아웃풋,

106
00:06:03,360 --> 00:06:08,635
이 이미지에 대한 아웃풋 레이블인 이 자체로 3 x 3 x 8 볼륨입니다.

107
00:06:08,635 --> 00:06:11,245
이제 신경망을 훈련시키기 위해

108
00:06:11,245 --> 00:06:17,475
인풋은 100 by 100 by 3이고

109
00:06:17,475 --> 00:06:19,015
이것은 인풋 이미지입니다.

110
00:06:19,015 --> 00:06:22,795
그리고 컨볼 레이어, 맥스풀 레이어 등등을 가진

111
00:06:22,795 --> 00:06:27,690
일반적인 컨볼네트가 있습니다.

112
00:06:27,690 --> 00:06:28,870
마지막으로

113
00:06:28,870 --> 00:06:34,440
이걸 가지고, 컨볼레이어와 맥스풀 레이어 등을 선택해서 사용하면

114
00:06:34,440 --> 00:06:42,320
마침내 3 x 3 x 8 아웃풋 볼륨으로 매핑됩니다.

115
00:06:42,320 --> 00:06:46,470
이제 여러분이 할 일은, 이렇게 생긴 인풋 이미지 X를 만들고

116
00:06:46,470 --> 00:06:50,125
3 x 3 x 8 인 이러한 목표 라벨 Y를 만들 후

117
00:06:50,125 --> 00:06:54,160
신경망 훈련을 위해 후 방향 전파 를 사용하여

118
00:06:54,160 --> 00:06:58,565
인풋 X에서 아웃풋 볼륨 Y 매핑합니다

119
00:06:58,565 --> 00:07:01,360
따라서 이 알고리즘의 장점은

120
00:07:01,360 --> 00:07:07,228
신경망이 다음과 같이 정확한 바운딩 박스를 아웃풋한다는 것입니다.

121
00:07:07,228 --> 00:07:08,320
테스트 시간에,

122
00:07:08,320 --> 00:07:10,930
당신이 해야 하는 일은 인풋 이미지 X를 제공하고,

123
00:07:10,930 --> 00:07:14,255
이 아웃풋 Y를 얻을 때까지 앞으로 프롭을 실행하는 것입니다.

124
00:07:14,255 --> 00:07:16,735
그런 아웃풋의 3 x 3 위치 각각에 대한

125
00:07:16,735 --> 00:07:19,480
9 개의 아웃풋 각각에 대해

126
00:07:19,480 --> 00:07:22,810
1과 0을 읽어낼 수 있게 됩니다.

127
00:07:22,810 --> 00:07:27,153
9 개 위치 중 하나와 관련된 객체가 있습니까?

128
00:07:27,153 --> 00:07:29,590
그리고 객체가 있고, 무슨 객체인가요,

129
00:07:29,590 --> 00:07:36,065
그 그리드 셀의 객체에 대한 바운딩 박스는 어디에 있습니까?

130
00:07:36,065 --> 00:07:39,118
그리고 각 그리드 셀에 하나 이상의 객체가 없으면

131
00:07:39,118 --> 00:07:41,810
이 알고리즘은 잘 작동합니다.

132
00:07:41,810 --> 00:07:43,900
그리드 셀 내에 여러 객체를 갖는 문제는

133
00:07:43,900 --> 00:07:46,600
나중에 다룰 내용입니다.

134
00:07:46,600 --> 00:07:51,985
상대적으로 작은 3 x 3 그리드를 사용하는 경우를 봅시다.

135
00:07:51,985 --> 00:07:54,470
실제로는 더 미세한,

136
00:07:54,470 --> 00:07:56,160
19 x 19 크기의 그리드를 사용할 수 있습니다.

137
00:07:56,160 --> 00:07:58,900
그럼 19 x 19 x 8 을 얻게 되고

138
00:07:58,900 --> 00:08:02,315
그리고 이것은 그리드를 더욱 미세하게 만듭니다.

139
00:08:02,315 --> 00:08:07,180
이것은 동일한 그리드 셀에 여러 객체가 할당 될 가능성을 줄여줍니다.

140
00:08:07,180 --> 00:08:08,800
다시 말하면, 이는

141
00:08:08,800 --> 00:08:11,590
객체의 중간 점을 보고,

142
00:08:11,590 --> 00:08:14,290
객체의 중간 점을 포함하는 그리드 셀 하나에

143
00:08:14,290 --> 00:08:19,930
해당 객체를 할당하는 방법입니다

144
00:08:19,930 --> 00:08:23,926
따라서 각 객체는, 객체가 여러 그리드 셀을 사용하더라도,

145
00:08:23,926 --> 00:08:27,410
9개 그리드 셀 중의 하나,

146
00:08:27,410 --> 00:08:29,018
아니면 3 x 3

147
00:08:29,018 --> 00:08:31,565
아니면 19 x 19 그리드 셀의 하나,

148
00:08:31,565 --> 00:08:33,584
즉 19 x 19 그리드의 알고리즘에만 할당됩니다.

149
00:08:33,584 --> 00:08:36,715
같은 그리드 안에 객체의 중간 점이 두 개가 될 확률은

150
00:08:36,715 --> 00:08:41,445
좀 더 작아지는 것이죠.

151
00:08:41,445 --> 00:08:44,043
두 가지를 기억하십시오, 첫째,

152
00:08:44,043 --> 00:08:46,930
이것은 이번 주 첫 번째 동영상에서 설명한

153
00:08:46,930 --> 00:08:51,530
이미지 분류 및 위치 측정 알고리즘과 매우 유사합니다.

154
00:08:51,530 --> 00:08:55,380
그리고 바운딩 볼이 명시적으로 좌표를 아웃풋합니다

155
00:08:55,380 --> 00:08:58,235
따라서 네트워크에서 모든 aspect ratio(형상비)의

156
00:08:58,235 --> 00:09:02,440
바운딩 박스를 아웃풋 할 수있을 뿐 아니라

157
00:09:02,440 --> 00:09:05,690
슬라이딩 윈도우 분류기의 스트라이프 크기에 의해 결정되지 않는

158
00:09:05,690 --> 00:09:10,530
훨씬 정확한 좌표를 아웃풋 할 수 있습니다.

159
00:09:10,530 --> 00:09:12,220
두 번째로,

160
00:09:12,220 --> 00:09:17,320
이것은 길쌈 구현이며, 3 x 3 그리드에 아홉 번을 실행하지 않거나

161
00:09:17,320 --> 00:09:25,540
19 x19 알고리즘, 19의 제곱인 361 을 사용하고 있다면

162
00:09:25,540 --> 00:09:31,090
같은 알고리즘을 361번 혹은 19의 제곱 번 만큼 실행하고 있지 않은 것입니다.

163
00:09:31,090 --> 00:09:34,285
대신, 이것은 한 단위의 컨볼루션 구현입니다.

164
00:09:34,285 --> 00:09:39,610
이것은 여러분의 모든 3 x 3 혹은 19 x 19이 필요로 하는 연산 간에 공유된 많은 것을 가지고 있는

165
00:09:39,610 --> 00:09:46,780
하나의 컨볼네트를 사용하는 것입니다.

166
00:09:46,780 --> 00:09:49,135
따라서 이것은 매우 효율적인 알고리즘입니다.

167
00:09:49,135 --> 00:09:52,720
사실 YOLO 알고리즘에 대한 좋은 점은 꾸준한 인기가 있다는 것입니다.

168
00:09:52,720 --> 00:09:57,445
이 알고리즘은 컨볼루션 구현이어서,

169
00:09:57,445 --> 00:09:58,930
실제로는 매우 빠르게 실행됩니다.

170
00:09:58,930 --> 00:10:02,530
그래서 이것은 실시간으로 물체를 탐지하는 경우에도 적용됩니다.

171
00:10:02,530 --> 00:10:03,915
자, 마무리하기 전에

172
00:10:03,915 --> 00:10:06,610
당신과 공유하고 싶은 또 하나의 세부 사항이 있는데요,

173
00:10:06,610 --> 00:10:12,495
이 bounding bx, by, bh, bw를 어떻게 인코딩 해야 할까요?

174
00:10:12,495 --> 00:10:16,135
다음 슬라이드에서 이에 대해 논의 해 보도록 하죠.

175
00:10:16,135 --> 00:10:18,610
이 두 대의 자동차를 보시죠

176
00:10:18,610 --> 00:10:21,465
우리는 3 x 3 그리드를 사용한다는 것을 기억하십시오

177
00:10:21,465 --> 00:10:25,120
자, 오른쪽 차의 예를 들어 봅시다

178
00:10:25,120 --> 00:10:32,220
이 그리드 셀에는 객체가 있으므로, 타겟 레이블 Y는 1이 됩니다.

179
00:10:32,220 --> 00:10:34,270
즉 pc는 1이죠.

180
00:10:34,270 --> 00:10:37,060
그리고 나서 bx, by,

181
00:10:37,060 --> 00:10:40,970
bh, bw와 0, 1, 0입니다.

182
00:10:40,970 --> 00:10:43,790
그럼, 어떻게 바운딩 박스를 지정할까요?

183
00:10:43,790 --> 00:10:48,310
YOLO 알고리즘에서, 이 네모와 관련하여,

184
00:10:48,310 --> 00:10:51,545
여기 왼쪽 위의 점은 (0, 0)이고

185
00:10:51,545 --> 00:10:56,180
이 오른쪽 아래의 점이 (1, 1) 인 컨벤션을 취할 때,

186
00:10:56,180 --> 00:10:59,155
그 중간 점의 위치를 지정하기 위해,

187
00:10:59,155 --> 00:11:02,715
그 주황색 점, bx는,

188
00:11:02,715 --> 00:11:05,980
x가 약 0.4 인 것처럼 보입니다

189
00:11:05,980 --> 00:11:09,760
어쩌면 그들의 오른쪽으로 약 0.4 로 보입니다.

190
00:11:09,760 --> 00:11:15,945
그리고 나서 y는 아마 0.3 일 것 같습니다.

191
00:11:15,945 --> 00:11:19,380
그리고 바운딩 박스의 높이는 192

192
00:11:19,380 --> 00:11:24,090
이 상자의 전체 너비의 비율로 지정됩니다.

193
00:11:24,090 --> 00:11:30,931
그래서, 이 빨간 상자의 너비는 아마 그 파란색 선의 90 %입니다.

194
00:11:30,931 --> 00:11:35,030
그래서 bh는 0.9이고

195
00:11:35,030 --> 00:11:42,075
높이는 그리드 셀의 전체 높이의 절반 일 수 있습니다.

196
00:11:42,075 --> 00:11:46,670
그래서 이 경우 bw는 0.5라고합시다.

197
00:11:46,670 --> 00:11:49,455
다시 말해, 이 bx, by, bh, bw는

198
00:11:49,455 --> 00:11:53,690
그리드 셀과 관련하여 지정됩니다

199
00:11:53,690 --> 00:11:55,505
그래서 bx와 by는

200
00:11:55,505 --> 00:11:58,455
0과 1 사이여야 합니다. 그렇죠?

201
00:11:58,455 --> 00:12:01,055
이는 정의에 따라 보자면,

202
00:12:01,055 --> 00:12:04,340
그 주황색 점이 그 할당된 그리드 셀의 범위 내에 있기 때문에

203
00:12:04,340 --> 00:12:08,509
0과 1 사이가 아닌 경우는 상자 밖에 있게 되고,

204
00:12:08,509 --> 00:12:11,680
다른 그리드 셀에 할당될 것입니다.

205
00:12:11,680 --> 00:12:14,495
그러나 이것들은 1보다 더 클 수 있습니다.

206
00:12:14,495 --> 00:12:18,785
특히 바운딩 박스가 이렇게 있는 자동차를 가지고 있다면

207
00:12:18,785 --> 00:12:21,045
바운딩 박스의 높이와 너비는

208
00:12:21,045 --> 00:12:23,440
1보다 커질 수 있습니다.

209
00:12:23,440 --> 00:12:27,007
따라서 바운딩 박스를 지정하는 방법은 여러 가지가 있지만

210
00:12:27,007 --> 00:12:30,710
이것이야말로 매우 합리적인 방법 중 하나입니다.

211
00:12:30,710 --> 00:12:33,710
비록 YOLO 연구 논문을 읽는다면,

212
00:12:33,710 --> 00:12:35,970
YOLO 연구 라인을 보면,

213
00:12:35,970 --> 00:12:39,040
훨씬 더 잘 작동할 수 있는 파라미터화 된 것들이 있습니다.

214
00:12:39,040 --> 00:12:44,925
이것이 한 가지 합리적인 환경을 제공하여 잘 작동할 수 있게 되기를 바랍니다.

215
00:12:44,925 --> 00:12:47,690
비록 이것이 0과 1 사이에 있는지 확인하기 위한 시그모이드 함수와 관련된

216
00:12:47,690 --> 00:12:51,980
좀 더 복잡한 파라미터화가 있긴 하지만 말이죠.

217
00:12:51,980 --> 00:12:57,185
그리고 설명 파라미터화를 사용하여 이것들이 음수가 아니라는 것을 확인하십시오.

218
00:12:57,185 --> 00:13:01,245
0.9, 0.5 이니까요. 이것은 0보다 크거나 같아야만 합니다.

219
00:13:01,245 --> 00:13:03,915
조금 더 나은 작업을 하는

220
00:13:03,915 --> 00:13:05,457
다른 고급 파라미터가 있지만

221
00:13:05,457 --> 00:13:09,635
여기에서 본 것도 잘 작동할 것입니다.

222
00:13:09,635 --> 00:13:14,775
이것이 바로 YOLO 또는 You Only Look Once 알고리즘입니다.

223
00:13:14,775 --> 00:13:17,115
그리고 다음 몇 개의 강의에서는

224
00:13:17,115 --> 00:13:21,470
이 알고리즘을 더 잘 만드는 데 도움이 되는 몇 가지 다른 아이디어를 보여 드리겠습니다.

225
00:13:21,470 --> 00:13:23,170
그 동안, 원하시면

226
00:13:23,170 --> 00:13:24,445
제가 사용한 지난 몇 장의 슬라이드 하단에 있는

227
00:13:24,445 --> 00:13:29,667
YOLO 논문 참고 자료를 살펴보시면 좋을 것 같습니다.

228
00:13:29,667 --> 00:13:31,325
다만 조심하셔야 할 것은

229
00:13:31,325 --> 00:13:33,530
YOLO 논문은

230
00:13:33,530 --> 00:13:37,425
어려운 논문 중에 하나라는 점입니다.

231
00:13:37,425 --> 00:13:40,265
처음으로 이 논문을 읽었을 때,

232
00:13:40,265 --> 00:13:43,325
무슨 말을 하고 있는지 이해하기 어려웠던 것이 기억나는군요.

233
00:13:43,325 --> 00:13:46,356
그리고 저는 친구들 몇 명과

234
00:13:46,356 --> 00:13:48,950
아주 훌륭한 연구원들에게 이해할 수 있게 도와달라고 했었습니다.

235
00:13:48,950 --> 00:13:53,125
심지어 그들도 논문의 세부 사항을 이해하는 데 어려움을 겪었습니다.

236
00:13:53,125 --> 00:13:54,845
그래서 논문을 보실 때,

237
00:13:54,845 --> 00:13:58,195
이해하기 어려울지라도 괜찮습니다

238
00:13:58,195 --> 00:14:00,885
나는 그것이 드문 일 이었으면 좋겠지만

239
00:14:00,885 --> 00:14:02,795
슬프게도 드물지 않은 일인데요,

240
00:14:02,795 --> 00:14:05,130
그것은 바로 고위 연구원들조차도

241
00:14:05,130 --> 00:14:08,840
연구 논문을 검토하고 세부 사항을 파악하기가 어렵다는 것입니다.

242
00:14:08,840 --> 00:14:10,895
따라서 오픈 소스 코드를 보거나

243
00:14:10,895 --> 00:14:12,005
작성자 또는 다른 사람에게 연락하여

244
00:14:12,005 --> 00:14:15,610
이러한 결과의 세부 사항을 파악해야 합니다.

245
00:14:15,610 --> 00:14:19,715
그러나 원한다면 여러분이 읽어보는 걸 제가 막을 순 없죠.

246
00:14:19,715 --> 00:14:21,700
그 치만 이것은 어려운 것 중의 하나라는 겁니다.

247
00:14:21,700 --> 00:14:25,975
자, 이렇게 하시면, 이제 YOLO 알고리즘의 기본 사항을 이해할 수 있습니다.

248
00:14:25,975 --> 00:14:31,000
이 알고리즘이 더 잘 작동하도록 하는 몇 가지 추가 사항들로 넘어 갑시다.