1
00:00:00,000 --> 00:00:01,440
在上一段影片中

2
00:00:01,440 --> 00:00:03,705
你學到了利用 ConvNet 的滑動視窗

3
00:00:03,705 --> 00:00:08,170
(Sliding windows) 物件偵測演算法，
不過我們發現這太慢了

4
00:00:08,170 --> 00:00:13,090
在這部影片，你會學到怎麼用「卷積化」的方式實作這演算法

5
00:00:13,090 --> 00:00:14,640
我們來看這是什麼意思

6
00:00:14,640 --> 00:00:20,040
想要建造出卷積化的滑動視窗運算，先來看要如何

7
00:00:20,040 --> 00:00:25,590
把網路的全連結層 (fully connected layers) 轉換成卷積層

8
00:00:25,590 --> 00:00:28,620
我們先在這張投影片解釋，然後到了下一張投影片

9
00:00:28,620 --> 00:00:33,600
我們會用這張投影片的概念來教你卷積化的作法

10
00:00:33,600 --> 00:00:39,560
假設你的物件偵測演算法接受 14乘14乘3 的圖片

11
00:00:39,560 --> 00:00:42,240
— 這很小沒錯，不過方便我們舉例

12
00:00:42,240 --> 00:00:45,650
然後假設用 5乘5 的過濾器

13
00:00:45,650 --> 00:00:52,155
用了 16 個過濾器，所以把圖片從 14乘14乘3 轉成 10乘10乘16

14
00:00:52,155 --> 00:00:56,970
然後用了 2乘2 的最大池化層 (max pooling) 縮減到 5乘5乘16

15
00:00:56,970 --> 00:01:01,700
然後接 400 個單元的全連結層

16
00:01:01,700 --> 00:01:07,425
然後另一層全連結層，最後用 softmax 輸出 y

17
00:01:07,425 --> 00:01:11,220
為了解釋等會兒的演變

18
00:01:11,220 --> 00:01:14,100
我把這張圖改一下下

19
00:01:14,100 --> 00:01:18,105
把 y 看成是四個數字

20
00:01:18,105 --> 00:01:21,035
對照到四個類別的機率

21
00:01:21,035 --> 00:01:26,050
也就是 softmax 分類出來的

22
00:01:26,050 --> 00:01:31,405
這四個類別可以是行人、

23
00:01:31,405 --> 00:01:35,609
汽車、機車、和背景之類的。

24
00:01:35,609 --> 00:01:38,530
現在，我要展示給你看

25
00:01:38,530 --> 00:01:43,030
這些層要如何轉換成卷積層

26
00:01:43,030 --> 00:01:47,710
那麼 ConvNet 前面幾層還是一樣

27
00:01:47,710 --> 00:01:51,010
而對於下一層，

28
00:01:51,010 --> 00:01:55,030
其中一種實作這個全連結層的方式，是利用

29
00:01:55,030 --> 00:02:02,625
5乘5 的過濾器，而且我們用 400 個過濾器。

30
00:02:02,625 --> 00:02:08,950
如果你拿 5乘5乘16 的圖片和 5乘5 的過濾器做卷積

31
00:02:08,950 --> 00:02:13,450
請記得一個 5乘5 的過濾器其實是

32
00:02:13,450 --> 00:02:19,240
5乘5乘16，因為我們的過濾器會看過所有 16 個通道

33
00:02:19,240 --> 00:02:25,375
所以這邊的 16 和這邊的 16 要一樣，而輸出是 1乘1

34
00:02:25,375 --> 00:02:30,445
那如果你有 400 個這種 5乘5乘16 的過濾器

35
00:02:30,445 --> 00:02:36,056
那輸出的維度就會是 1乘1乘400。

36
00:02:36,056 --> 00:02:41,016
所以我們不再把這 400 個只看成一堆單元

37
00:02:41,016 --> 00:02:44,602
我們把他看成一個 1乘1乘400 的容積。

38
00:02:44,602 --> 00:02:50,260
數學上，這和全連結層一模一樣

39
00:02:50,260 --> 00:02:57,154
因為這 400 個點，每個點都有個 5乘5乘16 的過濾器

40
00:02:57,154 --> 00:02:59,770
所以那 400 個值的每一個值

41
00:02:59,770 --> 00:03:07,705
都是前一層的 5乘5乘16 的啟動值的某種線性函數。

42
00:03:07,705 --> 00:03:10,654
接下來，要做出下一個卷積層

43
00:03:10,654 --> 00:03:14,230
我們要做 1乘1 的卷積

44
00:03:14,230 --> 00:03:18,500
如果你有 400 個 1乘1 的過濾器

45
00:03:18,500 --> 00:03:24,955
下一層就也會是 1乘1乘400

46
00:03:24,955 --> 00:03:29,030
所以這就是這邊後面的全連結層

47
00:03:29,030 --> 00:03:35,215
最後呢，我們又需要 1乘1 的過濾器

48
00:03:35,215 --> 00:03:37,360
後面再接個 softmax

49
00:03:37,360 --> 00:03:40,140
所以這邊會輸出 1乘1乘4 的容積

50
00:03:40,140 --> 00:03:46,115
也就是對應到這個網路輸出的這四個數字。

51
00:03:46,115 --> 00:03:50,035
所以這就是怎麼把這些全連結層

52
00:03:50,035 --> 00:03:54,310
用卷積層來實作之

53
00:03:54,310 --> 00:03:57,815
這邊這堆單元現在改用

54
00:03:57,815 --> 00:04:02,680
1乘1乘400 和 1乘1乘4 的容積來取代之。

55
00:04:02,680 --> 00:04:06,580
學會了這種轉換後，讓我們看看

56
00:04:06,580 --> 00:04:11,400
要怎麼用卷積化的方法實作滑動視窗物件偵測

57
00:04:11,400 --> 00:04:16,850
這張投影片是基於 "OverFeat" 這篇論文

58
00:04:16,850 --> 00:04:18,650
參考文獻在底下，是由 Pierre Sermanet

59
00:04:18,650 --> 00:04:21,010
David Eigen, Xiang Zhang

60
00:04:21,010 --> 00:04:24,290
Michael Mathieu, Rob Fergus 和 Yann LeCun 所作

61
00:04:24,290 --> 00:04:31,385
假設你的滑動視窗 ConvNet 吃的是 14乘14乘3 的圖片

62
00:04:31,385 --> 00:04:35,495
同樣的我這邊用很小的 14乘14

63
00:04:35,495 --> 00:04:40,790
只是為了舉例，簡化數字和圖示

64
00:04:40,790 --> 00:04:44,450
那麼像之前提的，你有個這樣的神經網路

65
00:04:44,450 --> 00:04:49,100
最終會輸出 1乘1乘4 的容積

66
00:04:49,100 --> 00:04:52,465
也就是 softmax 的結果

67
00:04:52,465 --> 00:04:54,815
然後為了簡化圖示起見

68
00:04:54,815 --> 00:05:01,185
14乘14乘3 其實是個容積、10乘10乘16

69
00:05:01,185 --> 00:05:02,530
也是一個容積

70
00:05:02,530 --> 00:05:04,490
不過為了簡化圖示

71
00:05:04,490 --> 00:05:07,620
我只會畫容積的正面

72
00:05:07,620 --> 00:05:10,940
所以並不會畫出 1乘1乘400 的容積

73
00:05:10,940 --> 00:05:14,480
對於這些我只畫出 1乘1 的部份

74
00:05:14,480 --> 00:05:19,368
只會在這張投影片把 3D 的部份拿掉。

75
00:05:19,368 --> 00:05:23,810
那麼假設，你的 ConvNet 輸入為 14乘14 的圖片

76
00:05:23,810 --> 00:05:29,035
其實是 14乘14乘3，然後測試集的圖片是 16乘16乘3

77
00:05:29,035 --> 00:05:33,615
所以我在圖片邊邊加了黃色的這條

78
00:05:33,615 --> 00:05:36,335
在原版的滑動視窗法

79
00:05:36,335 --> 00:05:41,150
你會把藍色的區域餵給 ConvNet

80
00:05:41,150 --> 00:05:46,485
跑過一次，產生分類 0 或 1，然後往下滑一點

81
00:05:46,485 --> 00:05:54,020
讓我們用 2 個像素(pixel)的跨步，然後你可能往右滑

82
00:05:54,020 --> 00:05:56,090
2 個像素，把這個

83
00:05:56,090 --> 00:05:59,130
綠色的區域輸入到 ConvNet

84
00:05:59,130 --> 00:06:02,945
重跑一遍整個 ConvNet，得到另一個分類 0 或 1

85
00:06:02,945 --> 00:06:05,180
然後你會輸入

86
00:06:05,180 --> 00:06:12,595
這個橘色的區域，餵給 ConvNet，再跑一次，得到另個分類

87
00:06:12,595 --> 00:06:21,634
第四次也是最後一次，是這個右下的紫色區域。

88
00:06:21,634 --> 00:06:26,115
為了在 16乘16乘3 的圖片上跑滑動視窗，雖然圖很小

89
00:06:26,115 --> 00:06:32,065
你需要跑這個 ConvNet 四遍，才能拿到四個分類

90
00:06:32,065 --> 00:06:34,685
不過其實呢，這四次 ConvNet

91
00:06:34,685 --> 00:06:38,345
做的運算有很多都是重複的，

92
00:06:38,345 --> 00:06:42,485
而卷積化的滑動視窗法能夠讓

93
00:06:42,485 --> 00:06:48,150
這四次 ConvNet 的正向傳播共用很多運算。

94
00:06:48,150 --> 00:06:49,955
具體來說是這樣做的

95
00:06:49,955 --> 00:06:54,170
你用這個 ConvNet，用同樣的參數來跑

96
00:06:54,170 --> 00:06:56,731
用同樣的那個 5乘5 過濾器

97
00:06:56,731 --> 00:07:00,230
同樣那 16 個 5乘5 的過濾器來跑這圖片

98
00:07:00,230 --> 00:07:04,850
這樣的話你就有了 12乘12乘16 的容積

99
00:07:04,850 --> 00:07:07,280
然後和之前一樣做最大池化

100
00:07:07,280 --> 00:07:09,210
得到 6乘6乘16

101
00:07:09,210 --> 00:07:18,093
跑過同樣那400個 5乘5 的過濾器，得到 2乘2乘400 的容積

102
00:07:18,093 --> 00:07:24,835
所以和上面的 1乘1乘400 容積不同

103
00:07:24,835 --> 00:07:29,105
我們現在有的是 2乘2乘400 的容積

104
00:07:29,105 --> 00:07:32,870
再拿他跑過 1乘1 的過濾器

105
00:07:32,870 --> 00:07:37,260
會給你另一個 2乘2乘400 — 而非 1乘1乘400

106
00:07:37,260 --> 00:07:40,220
再做一次以後，最後輸出是一個

107
00:07:40,220 --> 00:07:44,320
2乘2乘4 的容積，而不是 1乘1乘4。

108
00:07:44,320 --> 00:07:49,250
其實這一部份藍色的 1乘1乘4

109
00:07:49,250 --> 00:07:54,368
會是左上部份的 14乘14 圖片所跑出來的結果

110
00:07:54,368 --> 00:08:01,215
這個右上的 1乘1乘4 容積代表右上的結果

111
00:08:01,215 --> 00:08:04,820
左下這個的結果

112
00:08:04,820 --> 00:08:08,660
是這左下 14乘14 區域通過 ConvNet 的結果

113
00:08:08,660 --> 00:08:13,310
而右下 1乘1乘4 的容積結果

114
00:08:13,310 --> 00:08:18,040
是右下角 14乘14 區域跑過 ConvNet 的輸出。

115
00:08:18,040 --> 00:08:20,990
如果我們檢查所有運算的步驟

116
00:08:20,990 --> 00:08:23,110
我們來看看綠色的這個例子

117
00:08:23,110 --> 00:08:25,850
如果你只把這塊區域切出來

118
00:08:25,850 --> 00:08:29,120
讓他通過上面那個 ConvNet

119
00:08:29,120 --> 00:08:34,105
那麼第一層的啟動值剛剛好會是這塊區域

120
00:08:34,105 --> 00:08:37,037
接下來過最大池化層後的啟動值

121
00:08:37,037 --> 00:08:40,490
正會是這個區域。然後下一層、

122
00:08:40,490 --> 00:08:43,460
再下一層都是類似情況

123
00:08:43,460 --> 00:08:44,805
所以這整個過程、

124
00:08:44,805 --> 00:08:47,216
這卷積化的計算做的是

125
00:08:47,216 --> 00:08:50,345
與其於各自把影像的四個區域

126
00:08:50,345 --> 00:08:54,635
各自獨立、做了四次正向傳播，還不如

127
00:08:54,635 --> 00:08:58,730
把這四個整合成一次的正向傳播

128
00:08:58,730 --> 00:09:02,713
分享這四塊圖片的共同區域的計算

129
00:09:02,713 --> 00:09:07,895
也就是這邊四塊 14乘14 的區域

130
00:09:07,895 --> 00:09:09,935
那現在，讓我們看一個比較大的例子

131
00:09:09,935 --> 00:09:14,845
假設你想在 28乘28乘3 的圖片上跑滑動視窗

132
00:09:14,845 --> 00:09:16,820
當你用同樣的方式

133
00:09:16,820 --> 00:09:21,410
跑正向傳播，你最後會得到 8乘8乘4 的輸出

134
00:09:21,410 --> 00:09:27,735
這相當於對這 14乘14 的區域跑滑動視窗...

135
00:09:27,735 --> 00:09:33,380
對這區域跑滑動視窗

136
00:09:33,380 --> 00:09:36,496
會對應到這邊左上角的這顆輸出

137
00:09:36,496 --> 00:09:39,661
然後用兩步的跨步移動這視窗

138
00:09:39,661 --> 00:09:43,775
移過去一次、移過去一次... 最後有了八個位置

139
00:09:43,775 --> 00:09:48,830
所以這給了你第一列。然後你把影像往下滑

140
00:09:48,830 --> 00:09:53,350
最終會給你所有 8乘8乘4 的輸出

141
00:09:53,350 --> 00:09:58,760
因為這邊是 2 的最大池化層，所以相對應地

142
00:09:58,760 --> 00:10:04,055
在原本的圖片上，這網路跑的是兩步的跨步

143
00:10:04,055 --> 00:10:05,335
總結一下

144
00:10:05,335 --> 00:10:07,853
要實作滑動視窗法

145
00:10:07,853 --> 00:10:11,715
之前作法是，你會去切一塊區域

146
00:10:11,715 --> 00:10:14,750
假設這是 14乘14

147
00:10:14,750 --> 00:10:18,811
然後跑過 ConvNet，然後再做下一個區域

148
00:10:18,811 --> 00:10:21,604
再做下一個 14乘14 的區域

149
00:10:21,604 --> 00:10:23,210
然後下一個、再下一個、

150
00:10:23,210 --> 00:10:25,700
下一個... 依此類推

151
00:10:25,700 --> 00:10:29,070
直到希望有某一塊能辨認出汽車。

152
00:10:29,070 --> 00:10:31,610
不過現在呢，我們並不依序進行；

153
00:10:31,610 --> 00:10:35,540
如果用前面投影片介紹的卷積化手法

154
00:10:35,540 --> 00:10:37,745
你可以把一整張圖片

155
00:10:37,745 --> 00:10:42,890
例如 28乘28，用卷積的方式同時預測全部

156
00:10:42,890 --> 00:10:46,270
只要用一次大的 ConvNet 正向傳播

157
00:10:46,270 --> 00:10:50,357
最後希望能找到汽車的位置。

158
00:10:50,357 --> 00:10:53,490
那麼，這就是怎麼利用卷積化

159
00:10:53,490 --> 00:10:57,700
來實作滑動視窗，讓整件事變非常有效率

160
00:10:57,700 --> 00:10:59,960
不過呢，這演算法仍然有個弱點：

161
00:10:59,960 --> 00:11:04,585
邊界框的位置並不會太準確

162
00:11:04,585 --> 00:11:05,786
在下一個影片中

163
00:11:05,786 --> 00:11:08,030
我們來看看要怎麼解決這個問題