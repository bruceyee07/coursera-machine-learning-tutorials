1
00:00:00,000 --> 00:00:01,440
지난 강의에서

2
00:00:01,440 --> 00:00:03,705
지난 강의에서 컨볼네트를 사용해서 슬라이딩 윈도우 객체 감지 알고리즘에 대해 배웠습니다.

3
00:00:03,705 --> 00:00:08,170
하지만 이게 매우 느리다는 것을 보았었죠

4
00:00:08,170 --> 00:00:13,090
이번 강의에서는 그 알고리즘을 컨볼루셔널하게 어떻게 실행할 수 있는지 배워보겠습니다.

5
00:00:13,090 --> 00:00:14,640
이게 뭘 의미하는지 보시죠.

6
00:00:14,640 --> 00:00:20,040
슬라이딩 윈도우의 컨볼루션 실행을 구축하기 위해서

7
00:00:20,040 --> 00:00:25,590
신경망에서 완전 연결 레이어를 컨볼루션 레이어로 변환시킬 수 있을지 먼저 살펴보시죠

8
00:00:25,590 --> 00:00:28,620
이번 슬라이드에서 먼저 하고 다음 슬라이드에서도 할테지만

9
00:00:28,620 --> 00:00:33,600
컨볼루션 실행을 여러분께 보여드리기 위해 이번 슬라이드에 있는 것들부터 사용해보겠습니다.

10
00:00:33,600 --> 00:00:39,560
객체 감지 알고리즘이 14 x 14 x 3 이미지를 인풋한다고 가정합시다.

11
00:00:39,560 --> 00:00:42,240
이건 꽤 작지만 설명적인 목적을 위한 것이니까요.

12
00:00:42,240 --> 00:00:45,650
그리고 5 x 5필터들를 사용한다고 칩시다.

13
00:00:45,650 --> 00:00:52,155
그리고 14 x 14 x 3에서 10 x 10 x 16 까지 이것을 매핑하기 위해서 그것들 중 16개의 필터만을 사용한다고 합시다.

14
00:00:52,155 --> 00:00:56,970
그러면 2 x 2 맥스풀링을 하면, 5 x 5 x 16으로 줄입니다.

15
00:00:56,970 --> 00:01:01,700
그리고 나서 400 유닛들을 연결하기 위한 완전 연결 레이어가 있죠

16
00:01:01,700 --> 00:01:07,425
그러면 이것들이 완전 연결레이어이고, 최종적으로 softmax 유닛을 사용해서 Y를 아웃풋합니다.

17
00:01:07,425 --> 00:01:11,220
우리가 잠시 후에 필요하게 될 수정사항을 만들기 위해

18
00:01:11,220 --> 00:01:14,100
이 사진을 조금 바꾸겠습니다. 그리고 이 대신에

19
00:01:14,100 --> 00:01:18,105
softmax유닛이 분류되는 네 개 클래스의

20
00:01:18,105 --> 00:01:21,035
class probability (급간확률)에 상응하는

21
00:01:21,035 --> 00:01:26,050
네 개의 숫자를 가지고 Y를 볼 것입니다.

22
00:01:26,050 --> 00:01:31,405
FC는 보행자,

23
00:01:31,405 --> 00:01:35,609
자동차, 오토바이, 그리고 배경 혹은 다른 것들이 되겠죠.

24
00:01:35,609 --> 00:01:38,530
이제 여러분에게 보여드리고 싶은 것은

25
00:01:38,530 --> 00:01:43,030
어떻게 이 레이어들이 컨볼루션 레이어로 전환될지 입니다.

26
00:01:43,030 --> 00:01:47,710
컨볼네트는 예전처럼 처음 몇 단계의 레이어들을 그릴 것이고,

27
00:01:47,710 --> 00:01:51,010
그리고 이제, 이 다음 레이어를 실행하는 한 가지 방법은

28
00:01:51,010 --> 00:01:55,030
이 완전 연결 레이어가 이것을 실행하는 것입니다.

29
00:01:55,030 --> 00:02:02,625
5 x 5필터가지고 말이죠. 400개의 5 x 5 필터를 사용해 봅시다.

30
00:02:02,625 --> 00:02:08,950
만약 5 x 5 x 16 이미지를 5 x 5 필터로 컨볼브 시키면

31
00:02:08,950 --> 00:02:13,450
5 x 5 필터는 5 x 5 x 16으로 실행되어 집이다.

32
00:02:13,450 --> 00:02:19,240
왜냐하면 우리 컨벤션이 필터가 16개 채널 모두를 가로지르는 것처럼 보이기 때문이죠.

33
00:02:19,240 --> 00:02:25,375
그래서 이 16과 이 16은 서로 매치가 되어야만 하고, 아웃풋은 1 x 1이 되는 것이죠.

34
00:02:25,375 --> 00:02:30,445
만약 5 x 5 x1 6필터가 400개가 있다면

35
00:02:30,445 --> 00:02:36,056
아웃풋 디이멘션은 1 x 1 x 400 이 될 것입니다.

36
00:02:36,056 --> 00:02:41,016
이 400개를 노드 세트로 보기보다는

37
00:02:41,016 --> 00:02:44,602
1 x 1 x 400볼륨으로 이걸 간주할 것입니다.

38
00:02:44,602 --> 00:02:50,260
수학적으로, 이것은 완전 연결 레이어와 동일합니다. 

39
00:02:50,260 --> 00:02:57,154
왜냐하면 이 400 개의 노드 각각은 5 x 5 x 16의 필터를 가지고 있기 때문입니다.

40
00:02:57,154 --> 00:02:59,770
따라서 각각의 400 값은

41
00:02:59,770 --> 00:03:07,705
이전 레이어의 5 x 5 x 16 액티베이션에 대한 임의의 선형 함수입니다.

42
00:03:07,705 --> 00:03:10,654
다음으로, 다음 컨볼루션 계층을 구현하기 위해

43
00:03:10,654 --> 00:03:14,230
1 x 1 컨볼루션을 구현할 것입니다.

44
00:03:14,230 --> 00:03:18,500
400 개의 1 x 1 필터가 있는 경우

45
00:03:18,500 --> 00:03:24,955
400 개의 필터를 사용하면 다음 레이어가 400 x 1 x 1이됩니다.

46
00:03:24,955 --> 00:03:29,030
그래서 이것은 이 다음에 있는 완전 연결 레이어를 만들어줍니다.

47
00:03:29,030 --> 00:03:35,215
마지막으로, 또 다른 1 x 1 필터가 있고

48
00:03:35,215 --> 00:03:37,360
그 뒤에 softmax 액티베이션이 옵니다.

49
00:03:37,360 --> 00:03:40,140
네트워크가 연산하는 이 네 개의 숫자를 가지기 위해서는

50
00:03:40,140 --> 00:03:46,115
1 x 1 x 4 볼륨을 만들어주십시오.

51
00:03:46,115 --> 00:03:50,035
이것은 이러한 완전히 연결된 레이어를 취해

52
00:03:50,035 --> 00:03:54,310
컨볼루션 레이어를 사용하여 구현하는 방법을 보여줍니다.

53
00:03:54,310 --> 00:03:57,815
그 결과 이러한 유닛 세트가

54
00:03:57,815 --> 00:04:02,680
1 x 1 x 400 그리고, 1 x 1 x 4 볼륨으로 구현되지는 않습니다.

55
00:04:02,680 --> 00:04:06,580
이러한 변환 후에, 슬라이딩 윈도우 객체 감지의

56
00:04:06,580 --> 00:04:11,400
컨볼루션 실행을 할 수 있는지 살펴봅시다.

57
00:04:11,400 --> 00:04:16,850
이 슬라이드에 있는 것은 OverFeat 논문을 근거로 한 것인데요,

58
00:04:16,850 --> 00:04:18,650
아래쪽에 참조된 대로 Pierre Sermanet,

59
00:04:18,650 --> 00:04:21,010
David Eigen와 Xiang Zhang

60
00:04:21,010 --> 00:04:24,290
,Michael Mathieu, Robert Fergus and Yann Lecun 에 의해 작성된 것입니다.

61
00:04:24,290 --> 00:04:31,385
슬라이딩 윈도우가 14 x 14 이미지를 3 개의 이미지로 변환한다고 가정 해 보겠습니다

62
00:04:31,385 --> 00:04:35,495
이 슬라이드에서 14 x 14 이미지와 같은 작은 숫자를 사용해서

63
00:04:35,495 --> 00:04:40,790
숫자와 그림을 더 간단하게 만듭니다.

64
00:04:40,790 --> 00:04:44,450
따라서 이전과 같이, 다음과 같은 신경망이

65
00:04:44,450 --> 00:04:49,100
이는 마침내 1 x 1 x 4볼륨을 아웃풋합니다.

66
00:04:49,100 --> 00:04:52,465
softmax 아웃풋이죠.

67
00:04:52,465 --> 00:04:54,815
다시 말하지만, 그림을 단순화하자면,

68
00:04:54,815 --> 00:05:01,185
14 x14 x 3은 엄밀히 말하면 5 x 5 혹은 10 x 10 x 16 볼륨입니다.

69
00:05:01,185 --> 00:05:02,530
14 x14 x 3은 엄밀히 말하면 5 x 5 혹은 10 x 10 x 16 볼륨입니다.

70
00:05:02,530 --> 00:05:04,490
이 슬라이드의 그림을 단순화시키기 위해서

71
00:05:04,490 --> 00:05:07,620
저는 이 볼륨의 앞면만 그리겠습니다.

72
00:05:07,620 --> 00:05:10,940
1 x 1 x400 볼륨을 그리는 대신에

73
00:05:10,940 --> 00:05:14,480
이것들의 1 x 1 부분만 그릴 것입니다.

74
00:05:14,480 --> 00:05:19,368
이 그림의 3가지 요소를 삭제했습니다, 이 슬라이드에서만요.

75
00:05:19,368 --> 00:05:23,810
따라서 컨볼네트가 14 x 14 이미지, 즉, 14 x 14 x 3 이미지로 14 개를 입력하고

76
00:05:23,810 --> 00:05:29,035
테스트 된 이미지의 크기가 16 x 16 x 3 이라고 생각해봅시다.

77
00:05:29,035 --> 00:05:33,615
이제 이 이미지의 경계 면에 노란색 줄무늬를 추가했습니다.

78
00:05:33,615 --> 00:05:36,335
원래의 슬라이딩 윈도우 알고리즘에서는

79
00:05:36,335 --> 00:05:41,150
여러분은 파란색 영역을 컨볼네트로 인풋해서

80
00:05:41,150 --> 00:05:46,485
a consecration 01 을 생성하기 위해 한 번 실행 한 다음

81
00:05:46,485 --> 00:05:54,020
약간 아래로 조금씩, 적어도 2 픽셀의 스트라이드를 사용하고,

82
00:05:54,020 --> 00:05:56,090
그것을 다시 2픽셀씩 오른쪽으로 밀면 됩니다.

83
00:05:56,090 --> 00:05:59,130
그럼 이 초록색 직사각형을 컨볼네트로 인풋해서

84
00:05:59,130 --> 00:06:02,945
컨볼네트 전체를 실행하면 또 다른 레이블 01을 얻게 되는 것입니다.

85
00:06:02,945 --> 00:06:05,180
그런 다음이 주황색 영역을 컨볼네트에 입력하고

86
00:06:05,180 --> 00:06:12,595
한 번 더 실행하여 다른 레이블을 얻을 수 있습니다

87
00:06:12,595 --> 00:06:21,634
그리고이 오른쪽 아래의 자주색 사각형으로 네 번째이자 마지막 실행을 하십시오.

88
00:06:21,634 --> 00:06:26,115
이 16 x 3 x 3 이미지에서 슬라이딩 창을 실행하는 것은 매우 작은 이미지입니다.

89
00:06:26,115 --> 00:06:32,065
4 개의 레이블을 얻으려면 이 컨볼네트를 네 번 실행하십시오.

90
00:06:32,065 --> 00:06:34,685
그러나 이 4 가지 컨볼네트에 의해 수행 된 많은 계산은

91
00:06:34,685 --> 00:06:38,345
매우 중복적인 것임이 분명합니다.

92
00:06:38,345 --> 00:06:42,485
따라서 슬라이딩 윈도우의 컨볼루션 실행은

93
00:06:42,485 --> 00:06:48,150
컨볼네트에서 이러한 네 클래스들이 많은 계산을 공유 할 수 있게 합니다.

94
00:06:48,150 --> 00:06:49,955
구체적으로, 다음과 같이 할 수 있습니다.

95
00:06:49,955 --> 00:06:54,170
컨볼네트를 사용하여 동일한 파라미터

96
00:06:54,170 --> 00:06:56,731
동일한 5 x 5 필터, 또한 16개의 5 x 5 필터로

97
00:06:56,731 --> 00:07:00,230
이것을 실행하십시오.

98
00:07:00,230 --> 00:07:04,850
이제 12 x 12 x 16 아웃풋 볼륨을 가질 수 있습니다.

99
00:07:04,850 --> 00:07:07,280
그런 다음 이전과 마찬가지로 맥스풀링을 수행하십시오.

100
00:07:07,280 --> 00:07:09,210
이제 6 x 6 x 16 가 있고

101
00:07:09,210 --> 00:07:18,093
동일한 400 개의 5 x 5 필터로 실행해서 2 x 2 x 40 볼륨을 얻습니다.

102
00:07:18,093 --> 00:07:24,835
이제 1 x 1 x 400 볼륨 대신

103
00:07:24,835 --> 00:07:29,105
2 x 2 x 400 볼륨이 됩니다.

104
00:07:29,105 --> 00:07:32,870
1 x 1 필터를 통해 실행하면

105
00:07:32,870 --> 00:07:37,260
또 다른 1 x 1 x 400 이 아니라 2 x 2 x 400 을 얻게 됩니다.

106
00:07:37,260 --> 00:07:40,220
한 번 더 해보면 이제는

107
00:07:40,220 --> 00:07:44,320
1 x 1 x 4 대신 2 x 2 x 4 아웃풋 볼륨을 가지게 됩니다.

108
00:07:44,320 --> 00:07:49,250
이 파란색 1 x 1 x 4 부분 집합은

109
00:07:49,250 --> 00:07:54,368
왼쪽 상단 구석 14 x 14 이미지로 실행 한 결과를 제공합니다.

110
00:07:54,368 --> 00:08:01,215
이 오른쪽 상단의 1 x 1 x 4 볼륨은 오른쪽 상단 결과를 제공합니다.

111
00:08:01,215 --> 00:08:04,820
왼쪽 하단은

112
00:08:04,820 --> 00:08:08,660
14 x 14 영역 왼쪽 아래에 컨볼네트를 구현한 결과입니다.

113
00:08:08,660 --> 00:08:13,310
그리고 오른쪽 하단의 1 x 1 x 4 볼륨은

114
00:08:13,310 --> 00:08:18,040
14 x 14 치수로 컨볼네트를 실행하는 것과 같은 결과를 제공합니다.

115
00:08:18,040 --> 00:08:20,990
계산의 모든 단계를 거치면

116
00:08:20,990 --> 00:08:23,110
녹색 예제를 보도록 하겠습니다.

117
00:08:23,110 --> 00:08:25,850
이 영역을 잘라내어 컨볼네트를 통과 시키면

118
00:08:25,850 --> 00:08:29,120
이 위쪽에 컨볼네트죠,

119
00:08:29,120 --> 00:08:34,105
그러면 이 첫 레이어의 액티베이션이 정확하게 이 영역이 됩니다.

120
00:08:34,105 --> 00:08:37,037
맥스풀링 후 다음 레이어의 액티베이션은

121
00:08:37,037 --> 00:08:40,490
정확하게 이 영역이었고, 그리고 나서 다음 레이어

122
00:08:40,490 --> 00:08:43,460
또 다음 레이어는 다음과 같이 되었습니다.

123
00:08:43,460 --> 00:08:44,805
이 과정이 하는 일은

124
00:08:44,805 --> 00:08:47,216
이 컨볼레이션 실행이 하는 일은,

125
00:08:47,216 --> 00:08:50,345
여러분이 독립적으로 인풋이미지의 네 부분집합상에 있는

126
00:08:50,345 --> 00:08:54,635
네 개의 전파를 실행하도록 강요하기 보다는

127
00:08:54,635 --> 00:08:58,730
네 개 모두를 하나의 계산형식으로 결합하고

128
00:08:58,730 --> 00:09:02,713
공통 이미지 영역에 있는 많은 계산을 공유하는 것입니다.

129
00:09:02,713 --> 00:09:07,895
우리가 여기에서 보았던 14 x 14의 패치 중의 네 개 전부 그렇습니다.

130
00:09:07,895 --> 00:09:09,935
이제 더 큰 예제를 살펴 보겠습니다.

131
00:09:09,935 --> 00:09:14,845
28 x 28 x 3 이미지에 대해 슬라이딩 윈도우를 실행한다고 가정해봅시다.

132
00:09:14,845 --> 00:09:16,820
같은 방식으로 네 개를 다 실행하면

133
00:09:16,820 --> 00:09:21,410
8 x 8 x 4 아웃풋을 가지게 됩니다.

134
00:09:21,410 --> 00:09:27,735
그리고 작아져서 14 x 14영역의 것으로 슬라이딩 윈도우가 남게 됩니다.

135
00:09:27,735 --> 00:09:33,380
그것은 그 영역에 대해 처음으로 슬라이딩 윈도우를 실행하는 것에 상응하는 것이죠.

136
00:09:33,380 --> 00:09:36,496
따라서 왼쪽 상단 모서리 부분에 상응하는 아웃풋을 제공하고

137
00:09:36,496 --> 00:09:39,661
창문 하나를 옆으로 밀고

138
00:09:39,661 --> 00:09:43,775
또 하나 옆으로, 또 하나 옆으로, 이런 식으로 여덟 개의 위치에 대해 수행합니다.

139
00:09:43,775 --> 00:09:48,830
그러면 이 첫 번째 행처럼 되고, 이미지 아래쪽으로 갈 수록

140
00:09:48,830 --> 00:09:53,350
이 모두 8 x 8 x 4 아웃풋이 됩니다.

141
00:09:53,350 --> 00:09:58,760
이는 2의 맥스풀링 때문인데요, 이는 원본 이미지에 대해

142
00:09:58,760 --> 00:10:04,055
스트라이드 2 로 신경망을 실행하는 것과 일치합니다.

143
00:10:04,055 --> 00:10:05,335
요약하자면,

144
00:10:05,335 --> 00:10:07,853
슬라이딩 윈도우를 실행하기 위해서는

145
00:10:07,853 --> 00:10:11,715
사전에 그 영역을 잘라내는 것입니다.

146
00:10:11,715 --> 00:10:14,750
14 x 14 라고 하면,

147
00:10:14,750 --> 00:10:18,811
컨볼네트를 이용해 실행하고, 다음 영역에 대해서도 수행합니다.

148
00:10:18,811 --> 00:10:21,604
그리고 나서 다음 14 x 14영역에 대해서 수행을 합니다.

149
00:10:21,604 --> 00:10:23,210
그리고 그 옆, 또 그 옆,

150
00:10:23,210 --> 00:10:25,700
그 옆, 또 그 옆, 그런 식으로

151
00:10:25,700 --> 00:10:29,070
자동차를 인식할 때 까지 진행합니다.

152
00:10:29,070 --> 00:10:31,610
하지만 이제, 끊임없이 이렇기 하는 대신에

153
00:10:31,610 --> 00:10:35,540
이전 슬라이드에서 본 대로 이 컨볼루션 구현을 하면

154
00:10:35,540 --> 00:10:37,745
이 전체 이미지를 실행할 수 습니다.

155
00:10:37,745 --> 00:10:42,890
모두 아마 28 x 28 이겠죠. 그리고 동시에 이 큰 컨볼네트를 한 칸씩 지나가면서

156
00:10:42,890 --> 00:10:46,270
컨볼루션적으로 예측하게 하면 됩니다.

157
00:10:46,270 --> 00:10:50,357
그리고 마침내 이것이 자동차의 위치를 인식하도록 하는 것이죠.

158
00:10:50,357 --> 00:10:53,490
자, 컨볼루셔널하게 슬라이딩 윈도우를 실행하는 방법과

159
00:10:53,490 --> 00:10:57,700
그것이 훨씬 효과적으로 모든 것을 만들어 내는 것을 보았습니다.

160
00:10:57,700 --> 00:10:59,960
자, 그런데 여기엔 큰 단점이 하나 있습니다.

161
00:10:59,960 --> 00:11:04,585
바운딩박스의 위치가 그리 정확하지 않다는 것입니다. 다음 강의에서는,

162
00:11:04,585 --> 00:11:05,786
다음 비디오에서는

163
00:11:05,786 --> 00:11:08,030
그 문제점을 해결하는 법을 알아보도록 하겠습니다.