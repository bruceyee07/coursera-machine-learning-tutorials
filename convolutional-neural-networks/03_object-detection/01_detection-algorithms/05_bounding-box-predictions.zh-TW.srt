1
00:00:00,000 --> 00:00:01,380
在上一段影片中

2
00:00:01,380 --> 00:00:06,300
你學到了用卷積化來實作滑動視窗

3
00:00:06,300 --> 00:00:08,780
這樣計算的確更有效率

4
00:00:08,780 --> 00:00:14,130
不過仍然有個問題：輸出的邊界框不會非常準確

5
00:00:14,130 --> 00:00:16,710
在這部影片，讓我們看看

6
00:00:16,710 --> 00:00:19,520
要怎麼讓邊界框預測更準。

7
00:00:19,520 --> 00:00:21,495
用滑動視窗法時，你拿這些

8
00:00:21,495 --> 00:00:26,190
預先設定好的位置，拿來跑過分類器

9
00:00:26,190 --> 00:00:27,825
以這例子而言

10
00:00:27,825 --> 00:00:32,636
所有的邊界框都無法剛剛好指出汽車的位置

11
00:00:32,636 --> 00:00:35,900
可能這個框已經最符合了

12
00:00:35,900 --> 00:00:38,465
還有，看起來這邊的正確解答

13
00:00:38,465 --> 00:00:41,585
最符合的邊界框甚至不是正方形

14
00:00:41,585 --> 00:00:48,750
實際上是寬一些的長方形，水平方向比較長

15
00:00:48,750 --> 00:00:53,975
那麼，有沒有任何演算法能夠輸出更精準的邊界框呢？

16
00:00:53,975 --> 00:00:59,275
有一個能給你更準確的邊界框的方法，叫 YOLO 演算法

17
00:00:59,275 --> 00:01:03,225
YOLO 意思是 "You Only Look Once" (你只看一遍)

18
00:01:03,225 --> 00:01:06,195
這演算法是由 Joseph Redmon, Santosh Divvala,

19
00:01:06,195 --> 00:01:07,975
Ross Girshick, Ali Farhadi 所發明

20
00:01:07,975 --> 00:01:10,735
是這樣子的

21
00:01:10,735 --> 00:01:14,230
假設你有個輸入的圖片，大小100乘100

22
00:01:14,230 --> 00:01:17,175
你會在這圖片上放格子

23
00:01:17,175 --> 00:01:19,425
為了舉例方便

24
00:01:19,425 --> 00:01:21,780
我這邊用 3乘3 的格子

25
00:01:21,780 --> 00:01:23,640
雖然實際的作法

26
00:01:23,640 --> 00:01:24,840
會用比較密的格子

27
00:01:24,840 --> 00:01:27,880
例如 19乘19 的格子

28
00:01:27,880 --> 00:01:30,660
基本概念是，你要拿之前

29
00:01:30,660 --> 00:01:36,345
在前面影片學到的「分類且定位」演算法

30
00:01:36,345 --> 00:01:40,165
套用到九個格子的每一個

31
00:01:40,165 --> 00:01:47,910
基本概念是，你要拿這禮拜第一堂課

32
00:01:47,910 --> 00:01:52,170
學到的圖片「分類且定位」演算法

33
00:01:52,170 --> 00:01:58,440
把他套用到這圖片上 9 格中的每一格

34
00:01:58,440 --> 00:01:59,851
更具體地說

35
00:01:59,851 --> 00:02:05,171
你可以這樣定義訓練用的標籤：

36
00:02:05,171 --> 00:02:08,070
對九格的每一格，你這樣定義標籤 y

37
00:02:08,070 --> 00:02:14,561
y 會是 8 維的向量

38
00:02:14,561 --> 00:02:16,470
和之前介紹的一樣

39
00:02:16,470 --> 00:02:19,610
你先輸出 p_c, 0或1，代表在那格子中

40
00:02:19,610 --> 00:02:24,170
有沒有想要的影像。然後

41
00:02:24,170 --> 00:02:30,800
b_x, b_y, b_h, b_w 表示這個邊界框 — 如果有影像的話

42
00:02:30,800 --> 00:02:33,348
如果有物件屬於這格子的話

43
00:02:33,348 --> 00:02:36,320
接下來是 c_1, c_2, c_3 —

44
00:02:36,320 --> 00:02:40,935
如果你想要辨認三種類別 — 不包括「背景」類別

45
00:02:40,935 --> 00:02:43,120
你想要辨認路人、

46
00:02:43,120 --> 00:02:45,110
機車和背景（譯註 口誤）

47
00:02:45,110 --> 00:02:47,720
那麼 c_1, c_2, c_3 可代表路人

48
00:02:47,720 --> 00:02:50,570
汽車和機車的分類。

49
00:02:50,570 --> 00:02:52,505
那麼在這張圖片中

50
00:02:52,505 --> 00:02:53,870
我們有九個格子

51
00:02:53,870 --> 00:02:59,105
所以對於每個格子，你都有像這樣的向量

52
00:02:59,105 --> 00:03:02,316
讓我們從左上角開始

53
00:03:02,316 --> 00:03:03,955
這一個格子

54
00:03:03,955 --> 00:03:06,115
這個格子沒有物件

55
00:03:06,115 --> 00:03:11,960
所以左上角格子的向量會是 0

56
00:03:11,960 --> 00:03:16,655
然後其他都是「無關」 (don't care)

57
00:03:16,655 --> 00:03:20,707
這個格子的標籤 Y 也是一樣

58
00:03:20,707 --> 00:03:24,640
這個格子也一樣，所有裡面沒東西的格子都是

59
00:03:24,640 --> 00:03:27,845
裡面沒有我們關注的物件

60
00:03:27,845 --> 00:03:32,435
那麼，這一個格子呢？

61
00:03:32,435 --> 00:03:34,385
更仔細地來說

62
00:03:34,385 --> 00:03:36,355
這張圖片有兩個物件

63
00:03:36,355 --> 00:03:40,270
而 YOLO 演算法會拿兩個物件的

64
00:03:40,270 --> 00:03:45,690
每一個的中間點，把物件分配給包含那個點的格子

65
00:03:45,690 --> 00:03:49,900
所以左邊的車被分配到這個格子

66
00:03:49,900 --> 00:03:51,445
而右邊這台車

67
00:03:51,445 --> 00:03:53,140
中間點在這

68
00:03:53,140 --> 00:03:57,265
於是分配給這一格

69
00:03:57,265 --> 00:04:02,510
所以就算中間格子包含了兩輛車的各一部份

70
00:04:02,510 --> 00:04:06,175
我們會假裝中間的格子並沒有要關注的物件

71
00:04:06,175 --> 00:04:11,560
所以中間格子的標籤 y 也會和沒物件的那種向量一樣

72
00:04:11,560 --> 00:04:13,450
也就是第一個 p_c 是這個

73
00:04:13,450 --> 00:04:15,000
然後其他都是「無關」項。

74
00:04:15,000 --> 00:04:17,091
不過對於這一個格子

75
00:04:17,091 --> 00:04:21,005
左邊我用綠色圈起來的

76
00:04:21,005 --> 00:04:23,765
這個標記 y 會是這樣：

77
00:04:23,765 --> 00:04:25,085
有一個物件、

78
00:04:25,085 --> 00:04:26,770
然後你寫 b_x, b_y

79
00:04:26,770 --> 00:04:32,830
b_h, b_w 來表示邊界框的位置

80
00:04:32,830 --> 00:04:34,870
然後呢

81
00:04:34,870 --> 00:04:38,680
如果第一個類別是路人，那這是 0；

82
00:04:38,680 --> 00:04:40,420
第二個類別是汽車，所以是 1；

83
00:04:40,420 --> 00:04:43,960
類別第三個是機車，這是 0。

84
00:04:43,960 --> 00:04:45,900
同樣道理，右邊的這格

85
00:04:45,900 --> 00:04:48,415
因為裡面有物件

86
00:04:48,415 --> 00:04:52,690
所以也會有這樣子的向量

87
00:04:52,690 --> 00:04:58,325
右邊的格子對應到的標籤會長這樣。

88
00:04:58,325 --> 00:05:00,715
所以對這九格的每一格

89
00:05:00,715 --> 00:05:04,815
你會得到一個 8 維的向量

90
00:05:04,815 --> 00:05:08,415
因為你有 3乘3 個格子

91
00:05:08,415 --> 00:05:09,863
你有 9 個格子

92
00:05:09,863 --> 00:05:17,435
所以輸出的總容積會是 3乘3乘8

93
00:05:17,435 --> 00:05:24,760
輸出會是 3乘3乘8，因為你有 3乘3 個格子

94
00:05:24,760 --> 00:05:28,045
對於其中的每一格

95
00:05:28,045 --> 00:05:32,790
你有一個 8 維的向量 y

96
00:05:32,790 --> 00:05:36,250
所以輸出容積是 3乘3乘8

97
00:05:36,250 --> 00:05:41,245
例如說，這一個在左上角的

98
00:05:41,245 --> 00:05:42,970
1乘1乘8 的容積，是對應到

99
00:05:42,970 --> 00:05:47,770
九格中左上角那格的輸出向量

100
00:05:47,770 --> 00:05:50,710
對這 3乘3 位置的每一個

101
00:05:50,710 --> 00:05:52,345
對於這九格中的每格

102
00:05:52,345 --> 00:05:58,180
每格都對應到你想要輸出的 8 維向量 y

103
00:05:58,180 --> 00:05:59,610
有些向量會是「無關」

104
00:05:59,610 --> 00:06:01,010
— 如果裡面沒物件

105
00:06:01,010 --> 00:06:03,360
這就是為什麼整個輸出、

106
00:06:03,360 --> 00:06:08,635
這圖片輸出的標記會是 3乘3乘8 的容積。

107
00:06:08,635 --> 00:06:11,245
那麼，要訓練這個網路的話

108
00:06:11,245 --> 00:06:17,475
輸入是 100乘100乘3

109
00:06:17,475 --> 00:06:19,015
這是輸入的圖片

110
00:06:19,015 --> 00:06:22,795
然後照慣例你有 ConvNet

111
00:06:22,795 --> 00:06:27,690
卷積層、max pool 層、等等

112
00:06:27,690 --> 00:06:28,870
所以到最後

113
00:06:28,870 --> 00:06:34,440
你要設計這些卷積層和最大池化層

114
00:06:34,440 --> 00:06:42,320
讓他最終對應成 3乘3乘8 的輸出。

115
00:06:42,320 --> 00:06:46,470
所以你要做的是，你有個輸入 X，像這張圖片

116
00:06:46,470 --> 00:06:50,125
你還有目標標籤 y，是 3乘3乘8

117
00:06:50,125 --> 00:06:54,160
然後用反向傳播來訓練神經網路

118
00:06:54,160 --> 00:06:58,565
讓每個輸入 X 能對應到輸出的容積 y。

119
00:06:58,565 --> 00:07:01,360
那麼，這個演算法的優點在於

120
00:07:01,360 --> 00:07:07,228
神經網路可以輸出準確的邊界框，像這邊這樣

121
00:07:07,228 --> 00:07:08,320
那麼在測試的時候，

122
00:07:08,320 --> 00:07:10,930
你要做的是餵一張圖片 X 進去

123
00:07:10,930 --> 00:07:14,255
跑正向傳播，得到輸出 y

124
00:07:14,255 --> 00:07:16,735
然後對於這九個輸出的每一個

125
00:07:16,735 --> 00:07:19,480
— 對於 3乘3 輸出的每一個位置

126
00:07:19,480 --> 00:07:22,810
你可以先看看這個 0 或 1：

127
00:07:22,810 --> 00:07:27,153
這九個位置有沒有相關的物件呢？

128
00:07:27,153 --> 00:07:29,590
如果有物件的話，是哪一種物件？

129
00:07:29,590 --> 00:07:36,065
還有在那一格當中，邊界框在哪裡？

130
00:07:36,065 --> 00:07:39,118
只要每個格子裡面沒有超過一個物件

131
00:07:39,118 --> 00:07:41,810
這個演算法應該 OK

132
00:07:41,810 --> 00:07:43,900
至於一個格子裡有多個物件

133
00:07:43,900 --> 00:07:46,600
這個問題我們之後會提到

134
00:07:46,600 --> 00:07:51,985
不過實務上 — 我這邊用了很少的 3乘3 格子

135
00:07:51,985 --> 00:07:54,470
但實務上，你應該要用比較密的格子

136
00:07:54,470 --> 00:07:56,160
例如 19乘19

137
00:07:56,160 --> 00:07:58,900
所以這邊最後是 19乘19乘8

138
00:07:58,900 --> 00:08:02,315
這樣讓格子變比較密的話

139
00:08:02,315 --> 00:08:07,180
同一個格子裡會有多個物件的機會就變小了。

140
00:08:07,180 --> 00:08:08,800
只是要提醒一下

141
00:08:08,800 --> 00:08:11,590
當把物件交給格子時

142
00:08:11,590 --> 00:08:14,290
是要看物件的中心點

143
00:08:14,290 --> 00:08:19,930
然後看中心點在哪個格子裡，再把物件交給那格

144
00:08:19,930 --> 00:08:23,926
所以就算某個物件橫跨多個格子

145
00:08:23,926 --> 00:08:27,410
也只會把物件交給九格的某一格

146
00:08:27,410 --> 00:08:29,018
3乘3的某一格

147
00:08:29,018 --> 00:08:31,565
或是19乘19的某一格。

148
00:08:31,565 --> 00:08:33,584
如果用 19乘19 格

149
00:08:33,584 --> 00:08:36,715
那麼兩個物件的中心點

150
00:08:36,715 --> 00:08:41,445
恰巧在同一個格子裡面的機會就比較小。

151
00:08:41,445 --> 00:08:44,043
那麼，有兩件事情要注意

152
00:08:44,043 --> 00:08:46,930
第一，這方法就像本周第一部影片

153
00:08:46,930 --> 00:08:51,530
提到的圖片「分類且定位」的問題

154
00:08:51,530 --> 00:08:55,380
他會輸出邊界框的座標

155
00:08:55,380 --> 00:08:58,235
而且你的網路可以輸出

156
00:08:58,235 --> 00:09:02,440
任何長寬比例的邊界框

157
00:09:02,440 --> 00:09:05,690
並且輸出更精準的座標

158
00:09:05,690 --> 00:09:10,530
不會被你滑動視窗的跨步大小所限。

159
00:09:10,530 --> 00:09:12,220
第二件事：

160
00:09:12,220 --> 00:09:17,320
這是卷積化的實作法；你不是把這演算法

161
00:09:17,320 --> 00:09:25,540
在3乘3格子上跑過九遍，或是在19乘19的格子跑過361遍

162
00:09:25,540 --> 00:09:31,090
所以你不會把同樣的方法跑361次。

163
00:09:31,090 --> 00:09:34,285
相反地，這是單一的、卷積化的實作

164
00:09:34,285 --> 00:09:39,610
你用一個 ConvNet，裡面的 3乘3 或 19乘19 格

165
00:09:39,610 --> 00:09:46,780
裡面的運算有很多都可以共享。

166
00:09:46,780 --> 00:09:49,135
所以這演算法非常有效率

167
00:09:49,135 --> 00:09:52,720
實際上，YOLO 演算法的好處

168
00:09:52,720 --> 00:09:57,445
這方法有名的原因，是他卷積化的作法

169
00:09:57,445 --> 00:09:58,930
他跑得飛快

170
00:09:58,930 --> 00:10:02,530
甚至能用在即時的物件偵測。

171
00:10:02,530 --> 00:10:03,915
那麼，在結束之前

172
00:10:03,915 --> 00:10:06,610
我還想告訴你們另一個細節：

173
00:10:06,610 --> 00:10:12,495
要怎麼把邊界框轉成數字 b_x, b_y, b_h, b_w 呢？

174
00:10:12,495 --> 00:10:16,135
讓我們看看下一張投影片

175
00:10:16,135 --> 00:10:18,610
我們有這兩輛車

176
00:10:18,610 --> 00:10:21,465
還有 3乘3 的格子

177
00:10:21,465 --> 00:10:25,120
我們用右邊的車作為例子

178
00:10:25,120 --> 00:10:32,220
在這一個格子，裡面有物件，所以標籤 y 是 1

179
00:10:32,220 --> 00:10:34,270
p_c 等於 1

180
00:10:34,270 --> 00:10:37,060
然後是 b_x, b_y

181
00:10:37,060 --> 00:10:40,970
b_h, b_w，然後 0, 1, 0

182
00:10:40,970 --> 00:10:43,790
所以要怎麼表示這邊界框呢？

183
00:10:43,790 --> 00:10:48,310
在 YOLO 演算法中，相對於這一個正方形

184
00:10:48,310 --> 00:10:51,545
我們的慣例是左上角是 (0, 0)

185
00:10:51,545 --> 00:10:56,180
而右下角是 (1, 1)

186
00:10:56,180 --> 00:10:59,155
所以要表示這個中間點的位置

187
00:10:59,155 --> 00:11:02,715
這個橘色的點， b_x 大概會是

188
00:11:02,715 --> 00:11:05,980
看起來 x 大概是 0.4

189
00:11:05,980 --> 00:11:09,760
因為看起來像是往右 0.4

190
00:11:09,760 --> 00:11:15,945
然後 y... 我猜大概是 0.3

191
00:11:15,945 --> 00:11:19,380
然後邊界框的高，是以

192
00:11:19,380 --> 00:11:24,090
這個框相對於整個寬度的比例而定

193
00:11:24,090 --> 00:11:30,931
所以紅色框的寬度大約是藍色線的 90%

194
00:11:30,931 --> 00:11:35,030
所以 b_h (譯註 應該是 b_w) 是 0.9。

195
00:11:35,030 --> 00:11:42,075
而這個的高大概是整個格子高度的一半

196
00:11:42,075 --> 00:11:46,670
所以這樣 b_w （譯註 應該是 b_h) 會是 0.5。

197
00:11:46,670 --> 00:11:49,455
也就是說，b_x, b_y, b_h, b_w

198
00:11:49,455 --> 00:11:53,690
是相對於這一個格子來表示

199
00:11:53,690 --> 00:11:55,505
所以 b_x 和 b_y

200
00:11:55,505 --> 00:11:58,455
他們一定在 0 到 1 之間，對吧

201
00:11:58,455 --> 00:12:01,055
因為根據定義

202
00:12:01,055 --> 00:12:04,340
這個橘色的點，一定會位於其所在格子的裡面

203
00:12:04,340 --> 00:12:08,509
如果不在 0 到 1 中間，那就會在格子外面

204
00:12:08,509 --> 00:12:11,680
那我們就會把他交給其他的格子。

205
00:12:11,680 --> 00:12:14,495
可是這兩個呢，他們可以比 1 還大

206
00:12:14,495 --> 00:12:18,785
特別是如果有輛車的邊界框長這樣子

207
00:12:18,785 --> 00:12:21,045
那麼這框框的高度和寬度

208
00:12:21,045 --> 00:12:23,440
會比 1 還要大。

209
00:12:23,440 --> 00:12:27,007
其實，要表示邊界框可以有很多方法

210
00:12:27,007 --> 00:12:30,710
不過這個方法還滿合理的

211
00:12:30,710 --> 00:12:33,710
雖然如果你去讀 YOLO 論文的話

212
00:12:33,710 --> 00:12:35,970
在 YOLO 裡面他們

213
00:12:35,970 --> 00:12:39,040
有其他的參數，讓整件事做得更好

214
00:12:39,040 --> 00:12:44,925
不過我希望這個方法還算合理，跑得不錯

215
00:12:44,925 --> 00:12:47,690
雖然他們有更複雜的參數

216
00:12:47,690 --> 00:12:51,980
和S型函數有關，確保這在 0 到 1 中間

217
00:12:51,980 --> 00:12:57,185
還用了指數的參數來確保這不會是負的

218
00:12:57,185 --> 00:13:01,245
因為 0.9 啦 0.5 啦這些一定要大於等於 0

219
00:13:01,245 --> 00:13:03,915
他們還有其他更進階的參數化

220
00:13:03,915 --> 00:13:05,457
讓成效更好一點

221
00:13:05,457 --> 00:13:09,635
不過你看到的這個方法應該也還行

222
00:13:09,635 --> 00:13:14,775
那麼，這就是 YOLO「你只要看一遍」演算法

223
00:13:14,775 --> 00:13:17,115
再接下來的影片，我會介紹

224
00:13:17,115 --> 00:13:21,470
一些其他的概念，讓這個演算法更厲害。

225
00:13:21,470 --> 00:13:23,170
在此同時

226
00:13:23,170 --> 00:13:24,445
你想要的話可以讀讀

227
00:13:24,445 --> 00:13:29,667
投影片下方所標示的 YOLO 論文

228
00:13:29,667 --> 00:13:31,325
不過先警告一下

229
00:13:31,325 --> 00:13:33,530
如果你想讀這些論文

230
00:13:33,530 --> 00:13:37,425
YOLO 的論文其實有點難讀

231
00:13:37,425 --> 00:13:40,265
我還記得我第一次讀的時候

232
00:13:40,265 --> 00:13:43,325
我實在很難了解這在做什麼

233
00:13:43,325 --> 00:13:46,356
我最後是問了好幾個朋友

234
00:13:46,356 --> 00:13:48,950
非常厲害的研究員來幫助我

235
00:13:48,950 --> 00:13:53,125
甚至他們當時也花了不少功夫了解裡面一些細節。

236
00:13:53,125 --> 00:13:54,845
所以你讀了這論文

237
00:13:54,845 --> 00:13:58,195
覺得很辛苦，這也是沒關係的

238
00:13:58,195 --> 00:14:00,885
其實... 我希望不會這樣

239
00:14:00,885 --> 00:14:02,795
但可惜大家通常都會很辛苦

240
00:14:02,795 --> 00:14:05,130
就算是有經驗的研究員

241
00:14:05,130 --> 00:14:08,840
常在讀論文的，要去了解裡面的細節也頗辛苦

242
00:14:08,840 --> 00:14:10,895
他們必須要去追程式碼

243
00:14:10,895 --> 00:14:12,005
或者問作者

244
00:14:12,005 --> 00:14:15,610
或做其他的事來了解這演算法的細節。

245
00:14:15,610 --> 00:14:19,715
不過呢，如果你想讀的話，不要聽了我的話以後就不看了

246
00:14:19,715 --> 00:14:21,700
可是這真的有點難。

247
00:14:21,700 --> 00:14:25,975
總之呢，你現在了解 YOLO 演算法的基本概念了

248
00:14:25,975 --> 00:14:31,000
讓我們繼續看看其他的，能讓這演算法更厲害的東西