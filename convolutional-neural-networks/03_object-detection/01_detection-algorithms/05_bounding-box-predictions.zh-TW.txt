在上一段影片中 你學到了用卷積化來實作滑動視窗 這樣計算的確更有效率 不過仍然有個問題：輸出的邊界框不會非常準確 在這部影片，讓我們看看 要怎麼讓邊界框預測更準。 用滑動視窗法時，你拿這些 預先設定好的位置，拿來跑過分類器 以這例子而言 所有的邊界框都無法剛剛好指出汽車的位置 可能這個框已經最符合了 還有，看起來這邊的正確解答 最符合的邊界框甚至不是正方形 實際上是寬一些的長方形，水平方向比較長 那麼，有沒有任何演算法能夠輸出更精準的邊界框呢？ 有一個能給你更準確的邊界框的方法，叫 YOLO 演算法 YOLO 意思是 "You Only Look Once" (你只看一遍) 這演算法是由 Joseph Redmon, Santosh Divvala, Ross Girshick, Ali Farhadi 所發明 是這樣子的 假設你有個輸入的圖片，大小100乘100 你會在這圖片上放格子 為了舉例方便 我這邊用 3乘3 的格子 雖然實際的作法 會用比較密的格子 例如 19乘19 的格子 基本概念是，你要拿之前 在前面影片學到的「分類且定位」演算法 套用到九個格子的每一個 基本概念是，你要拿這禮拜第一堂課 學到的圖片「分類且定位」演算法 把他套用到這圖片上 9 格中的每一格 更具體地說 你可以這樣定義訓練用的標籤： 對九格的每一格，你這樣定義標籤 y y 會是 8 維的向量 和之前介紹的一樣 你先輸出 p_c, 0或1，代表在那格子中 有沒有想要的影像。然後 b_x, b_y, b_h, b_w 表示這個邊界框 — 如果有影像的話 如果有物件屬於這格子的話 接下來是 c_1, c_2, c_3 — 如果你想要辨認三種類別 — 不包括「背景」類別 你想要辨認路人、 機車和背景（譯註 口誤） 那麼 c_1, c_2, c_3 可代表路人 汽車和機車的分類。 那麼在這張圖片中 我們有九個格子 所以對於每個格子，你都有像這樣的向量 讓我們從左上角開始 這一個格子 這個格子沒有物件 所以左上角格子的向量會是 0 然後其他都是「無關」 (don't care) 這個格子的標籤 Y 也是一樣 這個格子也一樣，所有裡面沒東西的格子都是 裡面沒有我們關注的物件 那麼，這一個格子呢？ 更仔細地來說 這張圖片有兩個物件 而 YOLO 演算法會拿兩個物件的 每一個的中間點，把物件分配給包含那個點的格子 所以左邊的車被分配到這個格子 而右邊這台車 中間點在這 於是分配給這一格 所以就算中間格子包含了兩輛車的各一部份 我們會假裝中間的格子並沒有要關注的物件 所以中間格子的標籤 y 也會和沒物件的那種向量一樣 也就是第一個 p_c 是這個 然後其他都是「無關」項。 不過對於這一個格子 左邊我用綠色圈起來的 這個標記 y 會是這樣： 有一個物件、 然後你寫 b_x, b_y b_h, b_w 來表示邊界框的位置 然後呢 如果第一個類別是路人，那這是 0； 第二個類別是汽車，所以是 1； 類別第三個是機車，這是 0。 同樣道理，右邊的這格 因為裡面有物件 所以也會有這樣子的向量 右邊的格子對應到的標籤會長這樣。 所以對這九格的每一格 你會得到一個 8 維的向量 因為你有 3乘3 個格子 你有 9 個格子 所以輸出的總容積會是 3乘3乘8 輸出會是 3乘3乘8，因為你有 3乘3 個格子 對於其中的每一格 你有一個 8 維的向量 y 所以輸出容積是 3乘3乘8 例如說，這一個在左上角的 1乘1乘8 的容積，是對應到 九格中左上角那格的輸出向量 對這 3乘3 位置的每一個 對於這九格中的每格 每格都對應到你想要輸出的 8 維向量 y 有些向量會是「無關」 — 如果裡面沒物件 這就是為什麼整個輸出、 這圖片輸出的標記會是 3乘3乘8 的容積。 那麼，要訓練這個網路的話 輸入是 100乘100乘3 這是輸入的圖片 然後照慣例你有 ConvNet 卷積層、max pool 層、等等 所以到最後 你要設計這些卷積層和最大池化層 讓他最終對應成 3乘3乘8 的輸出。 所以你要做的是，你有個輸入 X，像這張圖片 你還有目標標籤 y，是 3乘3乘8 然後用反向傳播來訓練神經網路 讓每個輸入 X 能對應到輸出的容積 y。 那麼，這個演算法的優點在於 神經網路可以輸出準確的邊界框，像這邊這樣 那麼在測試的時候， 你要做的是餵一張圖片 X 進去 跑正向傳播，得到輸出 y 然後對於這九個輸出的每一個 — 對於 3乘3 輸出的每一個位置 你可以先看看這個 0 或 1： 這九個位置有沒有相關的物件呢？ 如果有物件的話，是哪一種物件？ 還有在那一格當中，邊界框在哪裡？ 只要每個格子裡面沒有超過一個物件 這個演算法應該 OK 至於一個格子裡有多個物件 這個問題我們之後會提到 不過實務上 — 我這邊用了很少的 3乘3 格子 但實務上，你應該要用比較密的格子 例如 19乘19 所以這邊最後是 19乘19乘8 這樣讓格子變比較密的話 同一個格子裡會有多個物件的機會就變小了。 只是要提醒一下 當把物件交給格子時 是要看物件的中心點 然後看中心點在哪個格子裡，再把物件交給那格 所以就算某個物件橫跨多個格子 也只會把物件交給九格的某一格 3乘3的某一格 或是19乘19的某一格。 如果用 19乘19 格 那麼兩個物件的中心點 恰巧在同一個格子裡面的機會就比較小。 那麼，有兩件事情要注意 第一，這方法就像本周第一部影片 提到的圖片「分類且定位」的問題 他會輸出邊界框的座標 而且你的網路可以輸出 任何長寬比例的邊界框 並且輸出更精準的座標 不會被你滑動視窗的跨步大小所限。 第二件事： 這是卷積化的實作法；你不是把這演算法 在3乘3格子上跑過九遍，或是在19乘19的格子跑過361遍 所以你不會把同樣的方法跑361次。 相反地，這是單一的、卷積化的實作 你用一個 ConvNet，裡面的 3乘3 或 19乘19 格 裡面的運算有很多都可以共享。 所以這演算法非常有效率 實際上，YOLO 演算法的好處 這方法有名的原因，是他卷積化的作法 他跑得飛快 甚至能用在即時的物件偵測。 那麼，在結束之前 我還想告訴你們另一個細節： 要怎麼把邊界框轉成數字 b_x, b_y, b_h, b_w 呢？ 讓我們看看下一張投影片 我們有這兩輛車 還有 3乘3 的格子 我們用右邊的車作為例子 在這一個格子，裡面有物件，所以標籤 y 是 1 p_c 等於 1 然後是 b_x, b_y b_h, b_w，然後 0, 1, 0 所以要怎麼表示這邊界框呢？ 在 YOLO 演算法中，相對於這一個正方形 我們的慣例是左上角是 (0, 0) 而右下角是 (1, 1) 所以要表示這個中間點的位置 這個橘色的點， b_x 大概會是 看起來 x 大概是 0.4 因為看起來像是往右 0.4 然後 y... 我猜大概是 0.3 然後邊界框的高，是以 這個框相對於整個寬度的比例而定 所以紅色框的寬度大約是藍色線的 90% 所以 b_h (譯註 應該是 b_w) 是 0.9。 而這個的高大概是整個格子高度的一半 所以這樣 b_w （譯註 應該是 b_h) 會是 0.5。 也就是說，b_x, b_y, b_h, b_w 是相對於這一個格子來表示 所以 b_x 和 b_y 他們一定在 0 到 1 之間，對吧 因為根據定義 這個橘色的點，一定會位於其所在格子的裡面 如果不在 0 到 1 中間，那就會在格子外面 那我們就會把他交給其他的格子。 可是這兩個呢，他們可以比 1 還大 特別是如果有輛車的邊界框長這樣子 那麼這框框的高度和寬度 會比 1 還要大。 其實，要表示邊界框可以有很多方法 不過這個方法還滿合理的 雖然如果你去讀 YOLO 論文的話 在 YOLO 裡面他們 有其他的參數，讓整件事做得更好 不過我希望這個方法還算合理，跑得不錯 雖然他們有更複雜的參數 和S型函數有關，確保這在 0 到 1 中間 還用了指數的參數來確保這不會是負的 因為 0.9 啦 0.5 啦這些一定要大於等於 0 他們還有其他更進階的參數化 讓成效更好一點 不過你看到的這個方法應該也還行 那麼，這就是 YOLO「你只要看一遍」演算法 再接下來的影片，我會介紹 一些其他的概念，讓這個演算法更厲害。 在此同時 你想要的話可以讀讀 投影片下方所標示的 YOLO 論文 不過先警告一下 如果你想讀這些論文 YOLO 的論文其實有點難讀 我還記得我第一次讀的時候 我實在很難了解這在做什麼 我最後是問了好幾個朋友 非常厲害的研究員來幫助我 甚至他們當時也花了不少功夫了解裡面一些細節。 所以你讀了這論文 覺得很辛苦，這也是沒關係的 其實... 我希望不會這樣 但可惜大家通常都會很辛苦 就算是有經驗的研究員 常在讀論文的，要去了解裡面的細節也頗辛苦 他們必須要去追程式碼 或者問作者 或做其他的事來了解這演算法的細節。 不過呢，如果你想讀的話，不要聽了我的話以後就不看了 可是這真的有點難。 總之呢，你現在了解 YOLO 演算法的基本概念了 讓我們繼續看看其他的，能讓這演算法更厲害的東西