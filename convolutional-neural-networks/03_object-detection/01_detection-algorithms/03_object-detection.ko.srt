1
00:00:00,000 --> 00:00:05,695
랜드마크 감지는 물론 객체 위치 측정에 대해서도 배웠습니다.

2
00:00:05,695 --> 00:00:09,470
이제 다른 object detection algorithm(객체 감지 알고리즘)을 구축해 봅시다.

3
00:00:09,470 --> 00:00:13,005
이 강의에서는 Sliding Windows Detection Algorithm(슬라이딩 윈도우 감지 알고리즘)을 사용하여

4
00:00:13,005 --> 00:00:18,150
객체 감지를 수행하기 위해 컨볼네트를 사용하는 방법을 배우겠습니다.

5
00:00:18,150 --> 00:00:21,154
자동차 감지 알고리즘을 만들고 싶다고 가정 해 봅시다.

6
00:00:21,154 --> 00:00:22,315
여러분이 할 수 있는 일은 이것입니다.

7
00:00:22,315 --> 00:00:24,734
먼저 x와 y로 레이블 된 트레이닝 세트를 만들 수 있습니다.

8
00:00:24,734 --> 00:00:29,100
밀접하게 크롭된 자동차 이미지들입니다.

9
00:00:29,100 --> 00:00:32,970
이것은 이미지 x 인데요, 잘 만든 긍정적인 예시가 되겠죠, 자동차가 있습니다.

10
00:00:32,970 --> 00:00:35,140
여기도 자동차, 저기도 자동차기 있죠

11
00:00:35,140 --> 00:00:37,755
여기엔 자동차가 없고, 여기도 자동차가 없습니다.

12
00:00:37,755 --> 00:00:39,840
이 트레이닝 세트에서 우리의 목표를 위해서,

13
00:00:39,840 --> 00:00:43,733
자동차를 바싹 자른 이미지를 가지고 시작해 봅시다.

14
00:00:43,733 --> 00:00:47,365
이는 x가 그냥 거의 자동차 라는 뜻이죠.

15
00:00:47,365 --> 00:00:49,650
따라서 사진을 하나 찍어서

16
00:00:49,650 --> 00:00:52,340
자동차가 아닌 부분은 다 잘라내어 주세요.

17
00:00:52,340 --> 00:00:57,450
그러면 이미지 전체에 거의 자동차만 중심으로 들어가있는 것을 얻게 됩니다.

18
00:00:57,450 --> 00:01:01,090
주어진 이 레이블 트레이닝 세트에서,

19
00:01:01,090 --> 00:01:05,412
이렇게 바싹 잘라진 이미지를

20
00:01:05,412 --> 00:01:07,977
인풋하는 컨볼네트를 학습시킬 수 있습니다.

21
00:01:07,977 --> 00:01:12,135
컨볼네트 작업은 아웃풋 y를 생성합니다.

22
00:01:12,135 --> 00:01:15,090
0 이나 1, 이것은 자동차 인가 아닌가를 말해주는 것이죠.

23
00:01:15,090 --> 00:01:17,044
이 컨볼네트를 학습하기만 하면

24
00:01:17,044 --> 00:01:20,515
슬라이딩 윈도우 감지에서 이걸 사용할 수 있습니다.

25
00:01:20,515 --> 00:01:21,870
따라서 여러분이 해야 할 것은,

26
00:01:21,870 --> 00:01:25,560
이런 테스트 이미지가 있다면,

27
00:01:25,560 --> 00:01:29,625
특정 사이즈의 창문을 하나 골라서 시작하는 것입니다. 여기 아래 보여지는 것처럼 말이죠.

28
00:01:29,625 --> 00:01:35,070
그리고 나서 작은 직사각형 영역인 컨볼네트로 집어 넣으면 됩니다.

29
00:01:35,070 --> 00:01:38,670
그러니, 이 아래에 있는 빨간색 사각형을 가져다가

30
00:01:38,670 --> 00:01:41,235
이 컨볼네트에 넣으십시오.

31
00:01:41,235 --> 00:01:43,020
그리고 컨볼네트가 예측을 하게 하는 겁니다.

32
00:01:43,020 --> 00:01:47,215
추측컨대, 이 빨간 사각형으로 된 작은 영역에 대해서,

33
00:01:47,215 --> 00:01:50,640
컨볼네트는 아마 '아니오 이 작은 빨간 사각형에는 자동차가 없습니다'라고 말할 것입니다.

34
00:01:50,640 --> 00:01:52,310
슬라이딩 윈도우 감지 알고리즘에서

35
00:01:52,310 --> 00:01:56,900
여러분이 해야 하는 일은 이 두 번째 이미지를 인풋으로 전달하고,

36
00:01:56,900 --> 00:02:00,000
이 빨간 사각형으로 된 부분을 약간 옆쪽으로 옮기고

37
00:02:00,000 --> 00:02:03,970
이것을 컨볼네트로 피드하는 것입니다.

38
00:02:03,970 --> 00:02:06,715
그래서, 이 컨볼네트의 빨간 사각형으로 된 이미지 영역을

39
00:02:06,715 --> 00:02:10,665
피딩해서, 컨볼네트를 다시 실행합니다.

40
00:02:10,665 --> 00:02:16,275
그리고 나서, 세 번째 이미지로 이 작업을 하고, 이런 식으로 계속 이어갑니다.

41
00:02:16,275 --> 00:02:23,415
그리고 이 이미지에서 창문들을 모든 각각 위치로 밀 수 있을 때까지 계속하십시오.

42
00:02:23,415 --> 00:02:28,975
이 애니메이션이 더 빨리 진행하게 하려고 이 예시에서는 상당히 큰 스트라이드를 만들고 있습니다.

43
00:02:28,975 --> 00:02:34,700
이것의 핵심은 이 사이즈의 모든 영역을 지나게 해서

44
00:02:34,700 --> 00:02:38,460
작게 잘라진 이미지를 컨볼네트로 전달하고

45
00:02:38,460 --> 00:02:45,125
각 위치에서 스트라이드 0 혹은 1로 분류되도록 하는 것입니다.

46
00:02:45,125 --> 00:02:47,085
이것을 실행해서 일단 완료하는 것을

47
00:02:47,085 --> 00:02:54,230
이미지를 통과하는 슬라이딩 윈도우이라고 부릅니다.

48
00:02:54,230 --> 00:02:55,295
그럼 여러분은 이를 반복하면 되는데,

49
00:02:55,295 --> 00:02:57,710
이번에는 더 큰 창문을 사용하십시오.

50
00:02:57,710 --> 00:03:02,191
그래서 조금 더 큰 영역을 취해서 그 영역을 실행시키세요.

51
00:03:02,191 --> 00:03:06,440
그래서, 컨볼네트가 원하는 인풋 사이즈로 이 영역을 다시 크기를 맞추십시오.

52
00:03:06,440 --> 00:03:10,235
컨볼네트로 이것을 다시 보내서 아웃풋 0이나 1을 산출하도록 하십시오.

53
00:03:10,235 --> 00:03:15,305
그리고 스트라이드를 사용해서 다시 이 창문을 옆으로 밀어내시면 됩니다.

54
00:03:15,305 --> 00:03:20,500
끝에 도착할 때 까지 전체 이미지를 계속해서 실행하십시오.

55
00:03:20,500 --> 00:03:26,283
그러면 세 번째에는 훨씬 더 큰 창문으로 이 작업을 수행하시면 됩니다.

56
00:03:26,283 --> 00:03:29,738
그렇습니다. 이렇게 하시면

57
00:03:29,738 --> 00:03:36,080
창문이 있는 이미지 어딘가에 자동차가 있는 한

58
00:03:36,080 --> 00:03:40,200
이 창문을 컨볼네트로 보내면

59
00:03:40,200 --> 00:03:44,890
컨볼네트는 이 인풋영역에 대해 하나의 아웃풋을 가지게 될 것입니다.

60
00:03:44,890 --> 00:03:47,825
그러면 여러분은 저기에 자동차가 있다는 것을 감지하게 되는 것이죠.

61
00:03:47,825 --> 00:03:52,895
이 알고리즘은 슬라이딩 윈도우 감지라고 불려 집니다. 왜냐하면 이런 창문,

62
00:03:52,895 --> 00:03:58,745
이 정사각형들을 이 전체 이미지를 가로지르게 하고

63
00:03:58,745 --> 00:04:05,770
자동차를 포함하고 있는지 아닌지 스트라이드를 가진 모든 사각영역을 분류하기 때문입니다.

64
00:04:05,770 --> 00:04:10,055
슬라이딩 윈도우 감지에는 커다란 단점이 하나 있습니다.

65
00:04:10,055 --> 00:04:12,704
바로 계산 비용입니다.

66
00:04:12,704 --> 00:04:16,460
이미지에 있는 많은 사각 영역들을 잘라내고

67
00:04:16,460 --> 00:04:21,370
컨볼네트를 통해서 독립적으로 그 각각을 실행시키기 때문입니다.

68
00:04:21,370 --> 00:04:24,505
여러분이 아주 거친 스트라이드,

69
00:04:24,505 --> 00:04:26,745
즉 아주 큰 스트라이드나 아주 큰 사이즈를 사용한다면,

70
00:04:26,745 --> 00:04:31,598
컨볼네트를 거쳐 보내야 할 창문의 숫자는 줄어들게 될 것입니다.

71
00:04:31,598 --> 00:04:35,810
하지만 더 거친 granularity(입상도)는 수행력에 안 좋은 영향을 줄 수도 있습니다.

72
00:04:35,810 --> 00:04:39,630
반면, 아주 고운 입상도, 즉 아주 작은 스트라이드를 사용한다면,

73
00:04:39,630 --> 00:04:44,005
컨볼네트를 지나게 하는 많은 양의 이 모든 작은 영역은

74
00:04:44,005 --> 00:04:48,995
아주 높은 계산 비용이 있다는 것을 의미합니다.

75
00:04:48,995 --> 00:04:54,180
따라서, 신경망이 떠오르기 이전에는, 객체 감지를 수행하기 위해

76
00:04:54,180 --> 00:04:56,910
핸드 엔지니어 피처를 통해

77
00:04:56,910 --> 00:05:00,450
단순 선형 분류기와 같은 훨씬 간단한 분류기를 사용하곤 했었습니다.

78
00:05:00,450 --> 00:05:04,870
그 시대에는, 각 분류기가 계산하기에 상대적으로 저렴하고

79
00:05:04,870 --> 00:05:06,480
그저 선형함수이기 때문에,

80
00:05:06,480 --> 00:05:08,980
슬라이딩 윈도우 감지는 잘 작동했었습니다.

81
00:05:08,980 --> 00:05:10,395
그리 나쁜 방법은 아니지만,

82
00:05:10,395 --> 00:05:15,450
컨볼네트로 단일 분류 과제를 실행하는 것은 훨씬 더 비싸고

83
00:05:15,450 --> 00:05:21,125
이 방법으로 하는 슬라이딩 윈도우는 실행불가능 하리만큼 느립니다.

84
00:05:21,125 --> 00:05:26,305
매우 고운 입성도 즉 매우 작은 스트라이드를 사용하지 않는 한,

85
00:05:26,305 --> 00:05:32,850
이미지 내에서 정확하게 객체 위치를 감지하는 것은 불가능합니다.

86
00:05:32,850 --> 00:05:38,575
하지만 다행히도, 계산 비용 문제는 좋은 해결책을 가지고 있습니다.

87
00:05:38,575 --> 00:05:41,845
특히나, 슬라이딩 윈도우 객체 감지기는

88
00:05:41,845 --> 00:05:45,935
컨볼루션적으로 훨씬 효과적으로 실행될 수 있습니다.

89
00:05:45,935 --> 00:05:48,310
어떻게 하면 될지 다음 강의에서 봅시다.