지난 강의에서 마지막 강의에서는 슬라이딩 윈도우의 컨볼루션 구현을 사용하는 방법을 배웠습니다. 계산 상 효율적이지만, 여전히 가장 정확한 바운딩 박스를 아웃풋 하지 못하는 문제가 있습니다. 이 강의에서는 바운딩 박스 예측을 보다 정확 하게하는 방법을 함께 보시죠. 슬라이딩 윈도우로 이 별개의 위치들을 가져 와서, 가로질러 크로스파이어를 실행합니다. 이 경우 10 이 경우 어느 상자도 자동차 위치와 완벽하게 일치하지 않습니다. 어쩌면 이 상자가 가장 잘 어울리는 것일 수도 있습니다. 또한 완벽하게 바운딩 박스가 완전히 정사각형이 아니기 때문에 실제로는 약간 더 넓은 직사각형 또는 약간 수평으로 가로 세로 비율이 그려져 있는 것처럼 보입니다. 이 알고리즘이 더 정확한 바운딩 박스를 아웃풋하도록 하는 방법이 있을까요? 이 아웃풋을 더 정확하게 바운딩 박스로 가져 오는 좋은 방법은 YOLO 알고리즘을 사용하는 것입니다. YOLO는 You Only Look Once의 약자입니다. 그리고 이들 Joseph Redmon, Santosh Divvala, Ross Girshick 및 Ali Farhadi에 의한 의한 알고리즘입니다 여기 당신이 해야 할 일이 있습니다. 인풋 이미지가 100 x 100 인 경우 이 이미지에 그리드를 배치한다고 가정 해 보겠습니다. 설명을 위해 3 x 3 그리드를 사용하려고 합니다 실제 구현에서는 19 x 19 그리드와 같이 더 미세한 그리드를 사용합니다. 그리고 기본 아이디어는 몇몇 강의에서 보셨던 이미지 분류 및 위치 측정 알고리즘을 사용하여 9 개의 각 그리드에 적용하는 것입니다. 기본 아이디어는 이번 주 첫 강의에서 보셨던 이미지 분류 및 위치 측정 알고리즘을 가지고 9 개의 각 그리드에 적용하는 것입니다. 좀 더 구체적으로, 여기에 훈련용으로 사용하는 레이블을 정의하는 방법이 있습니다. 따라서 9 개의 그리드 셀 각각에 대해, 레이블 Y를 지정합니다 여기서 레이블 Y는 이전에 본 것처럼 8 차원 벡터입니다. 해당 그리드 셀에 이미지가 있는지 여부에 따라 PC 01을 아웃풋한 다음 bx, by, bh, bw을 사용해서 이미지가 있고, 그리드 셀에 연관된 객체가 있으면 바운딩박스를 구체화시킵니다. 그런 다음 C1, C2, C3, 배경 클래스를 세지 않고, 세 클래스를 시도하고 인식하십시오. 그래서 당신은 보행자 클래스, 오토바이 및 백그라운드 클래스를 인식하려고 합니다. C1 C2 C3 는 보행자, 자동차 그리고 오토바이 클래스를 말합니다. 이 이미지에서 우리는 9 개의 그리드 셀을 가지므로 각 그리드 셀에 대해 이와 같은 벡터를 가집니다. 그러면 왼쪽 상단 그리드 셀부터 시작해 봅시다. 이 위쪽에 있는 것은 여기엔 객체가 없죠. 왼쪽 위의 그리드 셀에 대한 레이블 벡터 Y는 0이 될 것이고 나머지는 고려하지 않을 것입니다. 아웃풋 레이블 Y는 이 그리드 셀과 이 그리드 셀, 그리고 아무 것도 없는 모든 그리드 셀에 대해 같을 것입니다. 모두 흥미로운 객체는 없습니다 자, 이 그리드 셀은 어떻습니까? 좀 더 자세히 설명하기 위해 이 이미지에는 두 개의 객체가 있습니다. YOLO 알고리즘이 수행하는 작업은 두 객체의 도달 중간 점을 취한 다음, 중간 점을 포함하는 그리드 셀에 이 객체를 할당하는 것입니다. 따라서 왼쪽 자동차는 이 그리드 셀에 지정되고, 이 오른쪽 차는, 이 중간 점이, 이 그리드 셀에 지정됩니다. 중앙 그리드 셀에는 두 자동차의 일부가 있지만 중앙 그리드 셀은 흥미로운 객체가 없다고 생각해서 중앙 그리드 셀인 레이블 Y 클래스는 객체가 없는 이 벡터처럼 보이게 됩니다. 따라서 첫 번째 구성 요소는 PC가 되고, 나머지는 상관없음이 됩니다. 반면에 이 셀에는, 왼쪽에 초록색으로 동그라미 해 놓은 이 셀, 타겟 레이블 Y는 다음과 같습니다. 객체가 없고 바운딩 박스의 위치를 구체화시키기 위해 bx, by, bh, bw를 씁니다. 그럼 한 번 봅시다. 클래스 1이 보행자라면, 그것은 0입니다. 클래스 2는 자동차 입니다. 클래스 3은 오토바이였는데, 0 이죠. 그리고 비슷하게, 오른쪽에 있는 그리드 셀은 그 안에 객체가 있기 때문에 오른쪽에 있는 그리드 셀에 해당하는 대상 레이블과 같은 벡터를 갖게 됩니다 따라서 이러한 9 개의 그리드 셀 각각에 대해 결국 8 차원 아웃풋 벡터를 가지게 됩니다. 그리고 당신은 3 x 3 그리드 셀을 가지고 있기 때문에, 9 개의 그리드 셀을 가지게 됩니다. 아웃풋의 전체 볼륨은 3 x 3이 될 것입니다. 그래서 3x3 그리드 셀을 가지고 있기 때문에 목표 아웃풋은 3 x 3 x 8 이 될 것입니다. 각각의 3 x 3 그리드 셀에서 8 차원 벡터 Y를 가지고 있습니다. 따라서 목표 아웃풋 볼륨은 3 x 3 x 8이고, 예를 들어, 이 왼쪽 상단에서 1 x 1 x 8볼륨 9개 그리드 셀의 왼쪽 상단에 있는 목표 아웃풋에 일치합니다. 그리고 3 x 3 위치 각각에 대해, 각 9개 그리드 셀에서 이것은 각각에 대해 아웃풋하고자 하는 8 차원 목표 벡터 Y에 해당합니다. 거기에 객체가 없다면 이는 '상관없음' 벡터를 가질 것입니다. 이런 이유로 총 목표 아웃풋, 이 이미지에 대한 아웃풋 레이블인 이 자체로 3 x 3 x 8 볼륨입니다. 이제 신경망을 훈련시키기 위해 인풋은 100 by 100 by 3이고 이것은 인풋 이미지입니다. 그리고 컨볼 레이어, 맥스풀 레이어 등등을 가진 일반적인 컨볼네트가 있습니다. 마지막으로 이걸 가지고, 컨볼레이어와 맥스풀 레이어 등을 선택해서 사용하면 마침내 3 x 3 x 8 아웃풋 볼륨으로 매핑됩니다. 이제 여러분이 할 일은, 이렇게 생긴 인풋 이미지 X를 만들고 3 x 3 x 8 인 이러한 목표 라벨 Y를 만들 후 신경망 훈련을 위해 후 방향 전파 를 사용하여 인풋 X에서 아웃풋 볼륨 Y 매핑합니다 따라서 이 알고리즘의 장점은 신경망이 다음과 같이 정확한 바운딩 박스를 아웃풋한다는 것입니다. 테스트 시간에, 당신이 해야 하는 일은 인풋 이미지 X를 제공하고, 이 아웃풋 Y를 얻을 때까지 앞으로 프롭을 실행하는 것입니다. 그런 아웃풋의 3 x 3 위치 각각에 대한 9 개의 아웃풋 각각에 대해 1과 0을 읽어낼 수 있게 됩니다. 9 개 위치 중 하나와 관련된 객체가 있습니까? 그리고 객체가 있고, 무슨 객체인가요, 그 그리드 셀의 객체에 대한 바운딩 박스는 어디에 있습니까? 그리고 각 그리드 셀에 하나 이상의 객체가 없으면 이 알고리즘은 잘 작동합니다. 그리드 셀 내에 여러 객체를 갖는 문제는 나중에 다룰 내용입니다. 상대적으로 작은 3 x 3 그리드를 사용하는 경우를 봅시다. 실제로는 더 미세한, 19 x 19 크기의 그리드를 사용할 수 있습니다. 그럼 19 x 19 x 8 을 얻게 되고 그리고 이것은 그리드를 더욱 미세하게 만듭니다. 이것은 동일한 그리드 셀에 여러 객체가 할당 될 가능성을 줄여줍니다. 다시 말하면, 이는 객체의 중간 점을 보고, 객체의 중간 점을 포함하는 그리드 셀 하나에 해당 객체를 할당하는 방법입니다 따라서 각 객체는, 객체가 여러 그리드 셀을 사용하더라도, 9개 그리드 셀 중의 하나, 아니면 3 x 3 아니면 19 x 19 그리드 셀의 하나, 즉 19 x 19 그리드의 알고리즘에만 할당됩니다. 같은 그리드 안에 객체의 중간 점이 두 개가 될 확률은 좀 더 작아지는 것이죠. 두 가지를 기억하십시오, 첫째, 이것은 이번 주 첫 번째 동영상에서 설명한 이미지 분류 및 위치 측정 알고리즘과 매우 유사합니다. 그리고 바운딩 볼이 명시적으로 좌표를 아웃풋합니다 따라서 네트워크에서 모든 aspect ratio(형상비)의 바운딩 박스를 아웃풋 할 수있을 뿐 아니라 슬라이딩 윈도우 분류기의 스트라이프 크기에 의해 결정되지 않는 훨씬 정확한 좌표를 아웃풋 할 수 있습니다. 두 번째로, 이것은 길쌈 구현이며, 3 x 3 그리드에 아홉 번을 실행하지 않거나 19 x19 알고리즘, 19의 제곱인 361 을 사용하고 있다면 같은 알고리즘을 361번 혹은 19의 제곱 번 만큼 실행하고 있지 않은 것입니다. 대신, 이것은 한 단위의 컨볼루션 구현입니다. 이것은 여러분의 모든 3 x 3 혹은 19 x 19이 필요로 하는 연산 간에 공유된 많은 것을 가지고 있는 하나의 컨볼네트를 사용하는 것입니다. 따라서 이것은 매우 효율적인 알고리즘입니다. 사실 YOLO 알고리즘에 대한 좋은 점은 꾸준한 인기가 있다는 것입니다. 이 알고리즘은 컨볼루션 구현이어서, 실제로는 매우 빠르게 실행됩니다. 그래서 이것은 실시간으로 물체를 탐지하는 경우에도 적용됩니다. 자, 마무리하기 전에 당신과 공유하고 싶은 또 하나의 세부 사항이 있는데요, 이 bounding bx, by, bh, bw를 어떻게 인코딩 해야 할까요? 다음 슬라이드에서 이에 대해 논의 해 보도록 하죠. 이 두 대의 자동차를 보시죠 우리는 3 x 3 그리드를 사용한다는 것을 기억하십시오 자, 오른쪽 차의 예를 들어 봅시다 이 그리드 셀에는 객체가 있으므로, 타겟 레이블 Y는 1이 됩니다. 즉 pc는 1이죠. 그리고 나서 bx, by, bh, bw와 0, 1, 0입니다. 그럼, 어떻게 바운딩 박스를 지정할까요? YOLO 알고리즘에서, 이 네모와 관련하여, 여기 왼쪽 위의 점은 (0, 0)이고 이 오른쪽 아래의 점이 (1, 1) 인 컨벤션을 취할 때, 그 중간 점의 위치를 지정하기 위해, 그 주황색 점, bx는, x가 약 0.4 인 것처럼 보입니다 어쩌면 그들의 오른쪽으로 약 0.4 로 보입니다. 그리고 나서 y는 아마 0.3 일 것 같습니다. 그리고 바운딩 박스의 높이는 192 이 상자의 전체 너비의 비율로 지정됩니다. 그래서, 이 빨간 상자의 너비는 아마 그 파란색 선의 90 %입니다. 그래서 bh는 0.9이고 높이는 그리드 셀의 전체 높이의 절반 일 수 있습니다. 그래서 이 경우 bw는 0.5라고합시다. 다시 말해, 이 bx, by, bh, bw는 그리드 셀과 관련하여 지정됩니다 그래서 bx와 by는 0과 1 사이여야 합니다. 그렇죠? 이는 정의에 따라 보자면, 그 주황색 점이 그 할당된 그리드 셀의 범위 내에 있기 때문에 0과 1 사이가 아닌 경우는 상자 밖에 있게 되고, 다른 그리드 셀에 할당될 것입니다. 그러나 이것들은 1보다 더 클 수 있습니다. 특히 바운딩 박스가 이렇게 있는 자동차를 가지고 있다면 바운딩 박스의 높이와 너비는 1보다 커질 수 있습니다. 따라서 바운딩 박스를 지정하는 방법은 여러 가지가 있지만 이것이야말로 매우 합리적인 방법 중 하나입니다. 비록 YOLO 연구 논문을 읽는다면, YOLO 연구 라인을 보면, 훨씬 더 잘 작동할 수 있는 파라미터화 된 것들이 있습니다. 이것이 한 가지 합리적인 환경을 제공하여 잘 작동할 수 있게 되기를 바랍니다. 비록 이것이 0과 1 사이에 있는지 확인하기 위한 시그모이드 함수와 관련된 좀 더 복잡한 파라미터화가 있긴 하지만 말이죠. 그리고 설명 파라미터화를 사용하여 이것들이 음수가 아니라는 것을 확인하십시오. 0.9, 0.5 이니까요. 이것은 0보다 크거나 같아야만 합니다. 조금 더 나은 작업을 하는 다른 고급 파라미터가 있지만 여기에서 본 것도 잘 작동할 것입니다. 이것이 바로 YOLO 또는 You Only Look Once 알고리즘입니다. 그리고 다음 몇 개의 강의에서는 이 알고리즘을 더 잘 만드는 데 도움이 되는 몇 가지 다른 아이디어를 보여 드리겠습니다. 그 동안, 원하시면 제가 사용한 지난 몇 장의 슬라이드 하단에 있는 YOLO 논문 참고 자료를 살펴보시면 좋을 것 같습니다. 다만 조심하셔야 할 것은 YOLO 논문은 어려운 논문 중에 하나라는 점입니다. 처음으로 이 논문을 읽었을 때, 무슨 말을 하고 있는지 이해하기 어려웠던 것이 기억나는군요. 그리고 저는 친구들 몇 명과 아주 훌륭한 연구원들에게 이해할 수 있게 도와달라고 했었습니다. 심지어 그들도 논문의 세부 사항을 이해하는 데 어려움을 겪었습니다. 그래서 논문을 보실 때, 이해하기 어려울지라도 괜찮습니다 나는 그것이 드문 일 이었으면 좋겠지만 슬프게도 드물지 않은 일인데요, 그것은 바로 고위 연구원들조차도 연구 논문을 검토하고 세부 사항을 파악하기가 어렵다는 것입니다. 따라서 오픈 소스 코드를 보거나 작성자 또는 다른 사람에게 연락하여 이러한 결과의 세부 사항을 파악해야 합니다. 그러나 원한다면 여러분이 읽어보는 걸 제가 막을 순 없죠. 그 치만 이것은 어려운 것 중의 하나라는 겁니다. 자, 이렇게 하시면, 이제 YOLO 알고리즘의 기본 사항을 이해할 수 있습니다. 이 알고리즘이 더 잘 작동하도록 하는 몇 가지 추가 사항들로 넘어 갑시다.