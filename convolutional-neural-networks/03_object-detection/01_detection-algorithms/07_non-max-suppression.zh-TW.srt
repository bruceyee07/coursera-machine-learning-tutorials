1
00:00:00,000 --> 00:00:03,990
目前你所學的物件偵測，有一個問題是

2
00:00:03,990 --> 00:00:09,025
你的演算法對同一個物件可能會找出多個偵測：

3
00:00:09,025 --> 00:00:11,490
對於一個物件，他不會只偵測出一次

4
00:00:11,490 --> 00:00:13,940
他有可能會多次偵測之。

5
00:00:13,940 --> 00:00:16,470
「抑制非最大值」(non-max suppression) 可以

6
00:00:16,470 --> 00:00:19,865
確保你的演算法對一個物件只會偵測一次

7
00:00:19,865 --> 00:00:21,220
讓我們看個例子

8
00:00:21,220 --> 00:00:23,610
假設你想要在這張照片偵測出

9
00:00:23,610 --> 00:00:26,070
行人、汽車和機車

10
00:00:26,070 --> 00:00:29,040
你會在上面放格子

11
00:00:29,040 --> 00:00:33,375
這是 19乘19 的格子

12
00:00:33,375 --> 00:00:36,500
那麼，技術上來說這輛車只會有一個中心點

13
00:00:36,500 --> 00:00:39,105
所以他只會被交給某一個格子

14
00:00:39,105 --> 00:00:43,035
左邊的汽車也只有一個中間點

15
00:00:43,035 --> 00:00:48,745
所以應該只會有一個格子會預測出這裡有輛車。

16
00:00:48,745 --> 00:00:50,355
然而實務上，你會對

17
00:00:50,355 --> 00:00:56,006
每一個格子跑物件分類/定位演算法

18
00:00:56,006 --> 00:00:57,510
所以還滿有可能

19
00:00:57,510 --> 00:01:01,140
這個格子會覺得汽車的中心點在他裡面

20
00:01:01,140 --> 00:01:02,578
這格可能也會

21
00:01:02,578 --> 00:01:05,130
這格也有可能。而對於左邊的汽車也一樣

22
00:01:05,130 --> 00:01:07,520
可能不只這一格

23
00:01:07,520 --> 00:01:09,957
如果之前看過這張測試圖片

24
00:01:09,957 --> 00:01:14,070
不只這個格子會覺得他找到車了

25
00:01:14,070 --> 00:01:16,665
可能這個格子、這一格、其他格

26
00:01:16,665 --> 00:01:19,730
也會覺得他們找到車子了。

27
00:01:19,730 --> 00:01:24,865
所以讓我們透過實例來看看「抑制非最大值」怎麼進行

28
00:01:24,865 --> 00:01:26,550
因為你對於

29
00:01:26,550 --> 00:01:31,710
每個格子去執行分類/定位演算法

30
00:01:31,710 --> 00:01:34,635
在這些 361 個格子上。

31
00:01:34,635 --> 00:01:38,670
有可能其中很多格子會舉手說

32
00:01:38,670 --> 00:01:43,845
「我的 p_c、我覺得我裡面有物件的機率很高」

33
00:01:43,845 --> 00:01:47,120
在 361 個格子裡，可能不會只有兩個格子

34
00:01:47,120 --> 00:01:51,330
覺得他們偵測到了物件。

35
00:01:51,330 --> 00:01:52,905
所以你的演算法在跑的時候

36
00:01:52,905 --> 00:01:58,015
每一個物件可能都有多種偵測結果

37
00:01:58,015 --> 00:01:59,910
那麼，「抑制非最大值」做的是

38
00:01:59,910 --> 00:02:02,645
把這一堆偵測結果清乾淨

39
00:02:02,645 --> 00:02:06,660
所以最終每輛車只會有一個偵測結果

40
00:02:06,660 --> 00:02:09,910
不會一輛車就有多種偵測。

41
00:02:09,910 --> 00:02:12,000
這演算法具體的作法是

42
00:02:12,000 --> 00:02:16,645
他會先看每個偵測的機率

43
00:02:16,645 --> 00:02:18,630
可以算是 p_c — 雖然

44
00:02:18,630 --> 00:02:21,010
你在本週的作業會學到一些細節

45
00:02:21,010 --> 00:02:23,548
這其實是 p_c 乘以 c_1

46
00:02:23,548 --> 00:02:24,879
或 c_2 或 c_3

47
00:02:24,879 --> 00:02:29,685
不過在這裡我們先假設 p_c 是那個偵測的機率

48
00:02:29,685 --> 00:02:32,190
演算法會先拿最大的一個

49
00:02:32,190 --> 00:02:35,070
在這例子就是 0.9，然後說

50
00:02:35,070 --> 00:02:37,909
「那是我最有信心的偵測

51
00:02:37,909 --> 00:02:41,615
所以讓他變亮、突顯出在這裡找到了車」

52
00:02:41,615 --> 00:02:45,630
這步完畢後，接下來「抑制非最大值」的步驟是

53
00:02:45,630 --> 00:02:49,590
看過剩下所有的長方形，而對於那些重疊很多

54
00:02:49,590 --> 00:02:51,225
有很高 IoU 的

55
00:02:51,225 --> 00:02:54,625
疊到剛剛亮亮輸出的，那些會被抑制

56
00:02:54,625 --> 00:02:58,385
所以這裡這兩個 0.6, 0.7 的長方形

57
00:02:58,385 --> 00:03:02,048
這兩個都和亮藍色的長方形重疊很多

58
00:03:02,048 --> 00:03:03,555
所以你會抑制、隱藏那些

59
00:03:03,555 --> 00:03:07,105
把他們變暗，表示他們被抑制了。

60
00:03:07,105 --> 00:03:09,405
接下來，你在剩下的長方形當中

61
00:03:09,405 --> 00:03:11,760
找出有最高機率的那個

62
00:03:11,760 --> 00:03:15,180
有最高的 p_c，在這例子是 0.8 的這個

63
00:03:15,180 --> 00:03:17,025
所以我們就交出去說

64
00:03:17,025 --> 00:03:18,480
「好我這邊找到一輛車了」

65
00:03:18,480 --> 00:03:21,030
然後抑制非最大值的步驟

66
00:03:21,030 --> 00:03:25,785
就把其他如果有高 IoU 的丟掉。

67
00:03:25,785 --> 00:03:30,315
所以現在，每個長方形要嘛亮的要嘛暗的

68
00:03:30,315 --> 00:03:33,295
如果你把暗的長方形拿掉

69
00:03:33,295 --> 00:03:35,670
剩下的就是亮的

70
00:03:35,670 --> 00:03:39,325
這兩個就會是最終的預測。

71
00:03:39,325 --> 00:03:41,445
那麼，這就是「抑制非最大值」(non-max suppression)

72
00:03:41,445 --> 00:03:44,530
「非最大值」意味著你會

73
00:03:44,530 --> 00:03:48,215
輸出有最大機率的分類預測

74
00:03:48,215 --> 00:03:52,006
並抑制周圍「非最大」的預測

75
00:03:52,006 --> 00:03:55,684
所以被稱作抑制非最大值。

76
00:03:55,684 --> 00:03:58,185
讓我們進一步看看這演算法的細節

77
00:03:58,185 --> 00:04:00,590
第一，在這 19乘19 的格子上

78
00:04:00,590 --> 00:04:07,925
你會得到 19乘19乘8 的輸出容積

79
00:04:07,925 --> 00:04:09,945
不過在這例子

80
00:04:09,945 --> 00:04:13,794
我想簡化成，你只是要做汽車的偵測

81
00:04:13,794 --> 00:04:16,080
所以讓我丟掉 c_1, c_2,

82
00:04:16,080 --> 00:04:18,480
c_3, 假設在這張投影片

83
00:04:18,480 --> 00:04:21,578
19乘19 其中每個的輸出

84
00:04:21,578 --> 00:04:23,910
361 個中每個

85
00:04:23,910 --> 00:04:25,350
— 也就是 19 的平方

86
00:04:25,350 --> 00:04:26,835
對於每一個位置

87
00:04:26,835 --> 00:04:29,185
你會得到如下的輸出：

88
00:04:29,185 --> 00:04:31,443
有物件的機率、

89
00:04:31,443 --> 00:04:32,725
然後是邊界框

90
00:04:32,725 --> 00:04:34,135
如果你只有一種物件

91
00:04:34,135 --> 00:04:38,245
就不會預測 c_1, c_2, c_3。

92
00:04:38,245 --> 00:04:40,140
至於有多種物件的時候

93
00:04:40,140 --> 00:04:41,875
其中的細節的話

94
00:04:41,875 --> 00:04:43,870
我們就留到程式作業

95
00:04:43,870 --> 00:04:47,980
你在這周結束時會做到的。

96
00:04:47,980 --> 00:04:50,795
那麼，要實作抑制非最大值

97
00:04:50,795 --> 00:04:54,405
第一件事，你可以丟掉那一些，

98
00:04:54,405 --> 00:04:57,295
把預測的 p_c 在某個邊界值以下，例如 0.6

99
00:04:57,295 --> 00:05:01,243
的那些邊界框都丟掉。

100
00:05:01,243 --> 00:05:04,140
所以我們會說：除非你覺得至少有

101
00:05:04,140 --> 00:05:08,165
0.6 的機率會有物件，否則我們就丟掉他吧

102
00:05:08,165 --> 00:05:13,590
所以這步會丟掉所有低機率的邊界框。

103
00:05:13,590 --> 00:05:19,695
你可以把這步驟想成，對於 361 每個位置

104
00:05:19,695 --> 00:05:23,625
你會輸出一個邊界框，

105
00:05:23,625 --> 00:05:28,140
還會輸出「這個邊界框很好」的機率

106
00:05:28,140 --> 00:05:29,415
所以我們會丟掉

107
00:05:29,415 --> 00:05:33,945
每個只有低機率的框框。

108
00:05:33,945 --> 00:05:35,730
接下來，如果還有

109
00:05:35,730 --> 00:05:41,130
沒丟掉、或是沒處理的邊界框

110
00:05:41,130 --> 00:05:45,910
每一次，你會挑出最高機率的框框

111
00:05:45,910 --> 00:05:47,835
有最高 p_c 的框

112
00:05:47,835 --> 00:05:50,380
然後輸出它，當作一個預測

113
00:05:50,380 --> 00:05:54,720
所以這步驟就是前一張投影片中，我們挑出某個邊界框

114
00:05:54,720 --> 00:05:56,725
讓他變成亮色的

115
00:05:56,725 --> 00:06:02,195
所以你會把那一個交出去，預測那邊會有輛車。

116
00:06:02,195 --> 00:06:05,803
接下來，你會丟掉剩下的邊界框

117
00:06:05,803 --> 00:06:08,905
那些還沒輸出的

118
00:06:08,905 --> 00:06:10,955
之前也沒被丟掉的

119
00:06:10,955 --> 00:06:14,490
— 所以把剩下那些重疊很多的邊界框、

120
00:06:14,490 --> 00:06:15,945
有很高 IoU 的、

121
00:06:15,945 --> 00:06:20,305
與前一步輸出的框重疊很多的，把他們丟掉。

122
00:06:20,305 --> 00:06:25,425
所以迴圈裡的第二步，就是在前張投影片

123
00:06:25,425 --> 00:06:28,680
你黑掉其他的邊界框

124
00:06:28,680 --> 00:06:32,310
— 就是那些跟你剛剛變亮的

125
00:06:32,310 --> 00:06:34,115
有重疊很多的邊界框。

126
00:06:34,115 --> 00:06:36,835
所以，你不斷這樣做，

127
00:06:36,835 --> 00:06:40,000
只要還有尚未處理的邊界框，

128
00:06:40,000 --> 00:06:45,225
一直做到每一個邊界框已經變成預測結果

129
00:06:45,225 --> 00:06:48,990
或是因為重疊很高被丟掉

130
00:06:48,990 --> 00:06:50,580
有很高的 IoU

131
00:06:50,580 --> 00:06:53,550
與前一步剛輸出的框框、

132
00:06:53,550 --> 00:06:58,610
偵測出物件的邊界框重疊很高的。

133
00:07:00,000 --> 00:07:06,640
這張投影片提的，是只有一種物件的方法

134
00:07:06,640 --> 00:07:10,940
如果你想要偵測三種物件，假設是路人、

135
00:07:10,940 --> 00:07:16,215
汽車、和機車，這樣輸出的向量有額外三個維度

136
00:07:16,215 --> 00:07:18,860
這樣子的話，正確的方法是

137
00:07:18,860 --> 00:07:22,745
各自獨立，進行三次「抑制非最大值」

138
00:07:22,745 --> 00:07:26,635
每一種類別做一次。

139
00:07:26,635 --> 00:07:29,475
不過其中的細節，我就

140
00:07:29,475 --> 00:07:33,132
留待這禮拜的程式作業，讓你自己去做

141
00:07:33,132 --> 00:07:38,912
你會需要實作有多種物件的抑制非最大值。

142
00:07:38,912 --> 00:07:41,210
那麼，這就是「抑制非最大值」(non-max suppression)

143
00:07:41,210 --> 00:07:45,090
如果你照我們所教的，做出物件偵測的演算法

144
00:07:45,090 --> 00:07:48,175
你其實會得到滿不錯的結果。

145
00:07:48,175 --> 00:07:51,876
不過在總結 YOLO 演算法之前

146
00:07:51,876 --> 00:07:54,810
我還想和你分享最後一個概念

147
00:07:54,810 --> 00:07:57,295
能夠讓這演算法更加厲害

148
00:07:57,295 --> 00:08:00,235
也就是 "anchor boxes" (錨框)

149
00:08:00,235 --> 00:08:02,000
讓我們進入下一段影片