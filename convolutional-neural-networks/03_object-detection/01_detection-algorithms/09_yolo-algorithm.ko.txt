이미 대부분의 객체 감지 구성 요소를 보았습니다. 이 강의에서는 모든 구성 요소를 결합하여 YOLO 객체 감지 알고리즘을 구성 해 보겠습니다. 먼저, 트레이닝 세트를 구성하는 방법을 살펴 보겠습니다. 보행자, 자동차 및 오토바이의 세 가지 객체를 탐지하는 알고리즘을 학습시킨다고 가정합니다 그리고 명시적으로 전체 배경 클래스를 가져야 하므로 여기에 클래스 레이블 만 넣으면 됩니다. 두 개의 앵커 박스를 사용하는 경우 아웃풋 y는 3 x 3이 되겠죠, 이는 3 x 3 그리드 셀을 사용하기 때문입니다. 그리고 여기 x2, 이것은 앵커의 개수입니다. x8, 이는 여기 있는 이 디멘션을 가리키는 것입니다. 8은 사실 5 인데요, 여기에 클래스의 숫자 3을 더한 것입니다. Pc와 여기 바운딩 박스를 더하면 여기 5개 되는 것이고, 그리고 나서 C1, C2, C3. 이것의 디멘션은 클래스의 개수와 동일합니다. 3 x 3 x 2 x 8 이든 3 x 3 x 16 이 둘 중 하나를 볼 수 있는 것입니다. 따라서 트레이닝 세트를 구성하기 위해서는, 이 9개 그리드 셀 각각을 살펴보고 적합한 타겟 벡터 Y를 만들면 됩니다. 이 첫 번째 그리드 셀을 가지고 와서, 이 그리드 셀에서는 감지할만한 것이 없군요. 보행자, 자동차, 오토바이, 이 세 클래스 중에 그 어느 것도 왼쪽 상단 그리드에는 보이지 않습니다. 그래서 이 그리드셀에 상응하는 타겟은 이것과 동일할 것입니다. 첫 번째 앵커박스에 있는 Pc는 0인데요, 첫 번째 앵커박스와 관련된 것이 아무것도 없기 때문입니다. 그리고 또한 두 번째 앵커박스도 0 이고, 이런 식으로 되어 여기 이 다른 값들도 신경 쓸 필요 없는 것들이 되죠. 대부분의 그리드 셀들은 이 안에 아무것도 없습니다. 하지만 이 쪽에 있는 이 박스는 이 타겟 벡터 Y를 가지고 있습니다. 여러분의 트레이닝세트가 이 자동차에 대해서 바운딩 박스를 가진다고 추측해볼 수 있습니다. 높이보다는 옆으로 좀 더 넓게 되어있군요. 그리고 만약 여러분의 앵커박스가 있는데, 이것이 앵커박스 1이고, 이건 앵커박스 2라면, 이 빨간 박스는 앵커박스 2를 가진 약간만 더 높은 IoU를 가지고 있어서, 이 자동차는 이 벡터의 아래쪽 부분과 연관되는 것입니다. 앵커박스 1과 연관된 Pc는 0이고, 이 모든 요소들을 전부 신경 쓸 필요 없는 것들이므로, 이 Pc 는 0 이 됩니다. 그리고 빨간색 바운딩 박스의 위치를 구체화시키기 위해서는 이것들을 사용해야 하는 것이죠. 그리고 이 옳은 객체가 클래스 2라고 구체화 시키십시오. 이것이 자동차가 맞습니다. 따라서 이렇게 진행하시면, 각각의 9 그리드 위치, 3 x 3 그리드 위치에서 여러분은 이런 벡터를 얻게 될 것이고, 16개차원의 벡터를 얻게 될 것입니다. 그러므로, 최종 아웃풋 볼륨은 3 x 3 x 16이 될 것입니다. 아, 그리고 평소와 같이 슬라이드의 단순화를 위해, 3 x 3 그리드를 사용했습니다. 실제로는 19 x 19 x 6에 가까울 수도 있습니다 실제로 앵커 박스를 더 많이 사용하면 19 x 19 x 5 x 8 이 될 텐데요, 5 x 8은 40이므로 19 x 19 x 40이됩니다. 5 개의 앵커 박스를 사용하면 이것이 바로 학습이죠, 이제 100 x 100 x 3 이미지를 인풋해서 컨볼네트를 학습시키십시오. 그러면 컨볼네트는 마침내 예제와 같이 3 x 3 x 16 혹은 3 x 2 x 8 의 아웃풋 볼륨을 출력하게 될 것입니다. 알고리즘이 예측을 어떻게 내릴 수 있는지 살펴보십시오. 이미지가 주어지면 신경망은 이것을 3 x 3 x x2x 8 크기로 출력합니다 9 개의 그리드 셀 각각에 대해 이와 같은 벡터를 얻을 수 있죠. 따라서 왼쪽 위에 있는 그리드 셀의 경우 여기에 객체가 없으면 여기와 여기에서는 0을 출력하고 여기서는다른 값을 출력할 것입니다. 신경망은 물음표를 출력 할 수 없으며 신경 쓰지 않아도 된다는 표시를 하지 못합니다. 그러니 제가 이 나머지에 숫자를 넣도록 하겠습니다. 이 숫자들은 기본적으로 무시되 버릴 것입니다. 신경망이 여기에 객체가 없다고 알려주고 있으니까요. 아웃풋이 바운딩박스인지 아니면 자동차인지 그 여부는 중요하지 않습니다. 기본적으로 숫자의 세트, 더 많거나 적은 노이즈만 있습니다. 대조적으로, 이 상자에 대해서는, 왼쪽 하단의 상자에 대한 Y 값은 바운딩 상자 1에 대해 0 일 것입니다. 그리고 나서 노이즈처럼 숫자들을 쓰고, 아마도, 자동차에 대해 정확한 바운딩 박스를 구체화시키는 숫자 세트를 출력할 수 있을 것입니다. 이것이 바로 신경망이 예측을 하는 방법입니다. 마지막으로 non-max 억제를 통해 이를 실행합니다. 이것을 좀 더 재미있게 하기 위해서, 새로운 테스트 세트 이미지를 살펴 보겠습니다. 다음은 non-max 억제를 실행하는 방법입니다. 두 개의 앵커 상자를 사용하는 경우 각 그리드가 아닌 셀에 대해 두 개의 예측된 바운딩 박스를 얻으십시오. 그 중 일부는 매우 낮은 확률 매우 낮은 Pc를 갖지만 9 개의 그리드 셀에 각각에 대해 2 개의 예상 바운딩박스를 여전히 얻으면 됩니다. 이것들이 여러분이 얻게 될 바운딩박스입니다. 그리고 바운딩박스 중 일부는 그리드 셀의 높이와 너비 바깥쪽으로 나갈 수 있습니다 그런 다음 낮은 확률 예측을 제거합니다. 그래서 신경망이 객체는 아마도 거기에 존재하지 않을 거라고 말하는 것조차 없애 버려야합니다 그러니 이건 제거합시다. 그리고 마침내 당신이 감지하고 싶은 세 가지 클래스가 있고, 보행자, 자동차 및 오토바이를 감지하고 싶으면 세 클래스 각각에 대해, 그 클래스에서 올 것으로 예측되었던 객체들에 대해 non-max 억제를 독립적으로 실행하십시오. 보행자 클래스의 예측에 대해 non-max 억제를 사용하고 자동차 클래스에 대해 non-max 억제를 실행하고, motorcycle 클래스에 대해 non-max 억제를 실행합니다. 기본적으로 세 번 실행하여 최종 예측을 생성하십시오. 그리고 이 아웃풋은 이 이미지에 있는 모든 자동차와 모든 보행자를 감지했을 것입니다. 이것이 YOLO 객체 탐지 ??알고리즘을위한 것이고, 실제로 가장 효과적인 객체 감지 알고리즘 중 하나입니다. 이는 또한 객체 감지와 관련된 전체 컴퓨터 비전 문헌을 통틀어 가장 많은 훌륭한 아이디어 들를 아우릅니다. 그리고 이번 주에 실시되는 문제 연습에서 이것의 많은 구성 요소 실행을 실습 할 수 있는 기회를 갖게 됩니다. 이번 주 연습문제를 즐기시기 바랍니다. 이 강의 뒤에 선택강의가 하나 있는데요 봐도 좋고 보지 않아도 되는 것이지만 어느 쪽을 선택하시던 다음 강의에서는 꼭 만나 뵙기를 바랍니다.