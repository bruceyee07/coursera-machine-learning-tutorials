1
00:00:01,100 --> 00:00:02,740
안녕하세요.

2
00:00:02,740 --> 00:00:05,368
환영합니다. 이번 주에는 객체 탐색에 대해 배우도록 하겠습니다.

3
00:00:05,368 --> 00:00:08,980
‘객체 탐색’이란 컴퓨터비전 분야 중 하나로서

4
00:00:08,980 --> 00:00:12,460
불과 몇 년 전에 비해 급격히 증가하고 있으며, 훨씬 효과적으로 사용되고 있습니다.

5
00:00:12,460 --> 00:00:18,430
object detection 객체탐색기능을 구축하기 위해서는 먼저 object
localization (객체위치식별) 에 대해 학습하는 것이 필요합니다.

6
00:00:18,430 --> 00:00:20,595
우선 그 의미를 한 번 정의하며 시작해 봅시다.

7
00:00:20,595 --> 00:00:25,760
여러분은 이미 어떠한 알고리즘이 위와 같은 사진을 보며 자동차라고
알려주는

8
00:00:25,760 --> 00:00:30,500
이미지분류작업 (Image
Classification Image) 에 익숙할 것 입니다.

9
00:00:30,500 --> 00:00:31,920
이러한 기능을 바로 ‘분류법’ 이라고 할 수 있습니다.

10
00:00:34,560 --> 00:00:38,964
이 강의영상의 뒷부분에서 언급하겠지만, 여러분이 네트워크 내에서의 구축작업 중 마주하게 되는 문제점들은

11
00:00:38,964 --> 00:00:41,550
‘위치측정기능을 동반한 분류법’ 입니다.

12
00:00:41,550 --> 00:00:45,659
이것은 단순히 우리가 ‘이
물체가 자동차다’ 라고 이름 붙이는 것뿐만 아니라,

13
00:00:45,659 --> 00:00:49,758
이 알고리즘이 사물을 대상으로 경계상자를 표시하거나,

14
00:00:49,758 --> 00:00:55,090
사진 속에 있는 자동차의 위치 주변을 따라 빨간 직사각형을
그리는 일들 또한 담당하는 것을 의미합니다.

15
00:00:55,090 --> 00:00:59,310
이러한 것을 위치측정문제가 있는 분류법 이라고 부릅니다. 

16
00:00:59,310 --> 00:01:03,790
‘로컬라이제이션’ 이라는 용어는 여러분이
탐지한 자동차가 사진 속 어디에

17
00:01:03,790 --> 00:01:05,760
있는지 알아내는 것을 말합니다. 

18
00:01:05,760 --> 00:01:09,530
이번 주 후반에 가면, 탐지문제 (Detection Problem) 에 대해 알아볼 텐데요,

19
00:01:09,530 --> 00:01:13,590
그때에는 사진 속에 여러 개의 객체가 등장할 수도 있으니

20
00:01:13,590 --> 00:01:17,900
여러분은 그것들을 전부 탐지해내야 하고, 모든 객체의 위치들을 알아내야만 합니다. 

21
00:01:17,900 --> 00:01:21,820
만약 자율주행 애플리케이션에서 이 작업을 수행하는 경우, 

22
00:01:21,820 --> 00:01:24,480
다른 자동차들뿐만 아니라 그 외 보행자와 오토바이,

23
00:01:24,480 --> 00:01:29,310
심지어는 다른 주변 물건들까지도 탐지해내야 할 수도 있습니다

24
00:01:29,310 --> 00:01:31,090
그래서 이번 주 후반에 이것을 살펴보도록 하겠습니다

25
00:01:31,090 --> 00:01:36,220
이번 주에 사용하게 될 용어들 중, 분류법과

26
00:01:36,220 --> 00:01:42,130
위치측정문제 분류법은 대체적으로 하나의 객체를 다루고 있습니다.

27
00:01:42,130 --> 00:01:45,930
대개는 여러분이 인식 혹은 인식과 위치측정 모두를 하고자
하는 이미지의

28
00:01:45,930 --> 00:01:47,600
중앙에 큰 객체가 하나 있습니다.

29
00:01:47,600 --> 00:01:53,150
이와는 반대로, 탐지문제에서는, 다수의 객체가 존재할 수 있습니다.

30
00:01:53,150 --> 00:01:57,450
그리고 실제로는, 단일
이미지 내에 있는

31
00:01:57,450 --> 00:01:59,110
다른 카테고리들의 여러 객체 일 수도 있습니다.

32
00:01:59,110 --> 00:02:03,195
따라서 이미지 분류법에 대해 앞서 배웠던 아이디어들은 

33
00:02:03,195 --> 00:02:04,815
위치 측정 분류법에 매우 유용할 것 입니다.

34
00:02:04,815 --> 00:02:06,885
또한 위치측정을 위해 배운 아이디어들은

35
00:02:06,885 --> 00:02:10,795
탐지작업에 유용하게 사용된다는 것을 알 수 있을 것입니다.

36
00:02:10,795 --> 00:02:14,245
그럼 먼저 위치측정 분류법에 대해 이야기하며 시작해보겠습니다.

37
00:02:15,255 --> 00:02:20,535
여러분은 이미 이미지분류 문제에 익숙하실 겁니다,

38
00:02:20,535 --> 00:02:26,210
여러 레이어를 가진 컨브네트에 사진을 입력할 수 있고, 보시는 것처럼 컨브네트가 생겼습니다.

39
00:02:26,210 --> 00:02:31,348
그리고 이것은 예측된 조항을 출력하는 

40
00:02:31,348 --> 00:02:38,170
Softmax 유닛 공급의 벡터특징 생성이라는 결과를 가져옵니다.

41
00:02:38,170 --> 00:02:41,070
그래서 여러분이 만약 자율주행 자동차를 만들고 있다면

42
00:02:41,070 --> 00:02:44,370
아마도 여러분의 객체 카테고리들은 다음과 같을 수 있습니다.

43
00:02:44,370 --> 00:02:49,740
보행자, 자동차, 오토바이 또는 배경 등이죠.

44
00:02:49,740 --> 00:02:51,660
이 말은 위의 객체들 중 그 어느 것도 없는 경우라면,

45
00:02:51,660 --> 00:02:53,160
예를 들어, 보행자도
없고,

46
00:02:53,160 --> 00:02:57,735
차, 오토바이도
없다면, 여러분은 해당 출력 배경만 갖게 될 것입니다. 

47
00:02:57,735 --> 00:03:03,755
따라서 이것들이 종류입니다.
이들은 이렇게 4가지가 출력 가능한 softmax를
가지고 있습니다. 

48
00:03:03,755 --> 00:03:07,775
이것은 표준 분류 파이프라인입니다.

49
00:03:07,775 --> 00:03:12,585
이미지에 있는 자동차를 위치측정하고 싶다면 어떻게 해야 될까요? 

50
00:03:12,585 --> 00:03:17,156
그걸 위해서는, 경계상자를
출력하는 

51
00:03:17,156 --> 00:03:21,940
출력단위를 갖는 신경망을 변경하시면 됩니다. 

52
00:03:21,940 --> 00:03:27,179
그래서, 특히
신경망 출력으로 4개의 종류를 더 가질 수 있고, 

53
00:03:27,179 --> 00:03:32,236
이제 그것들을 bx,
by, bh, 그리고 bw라고 부르겠습니다.

54
00:03:32,236 --> 00:03:40,110
그리고 이 4개의
숫자는 탐지된 객체의 경계상자를 파라미터화 했습니다.

55
00:03:40,110 --> 00:03:44,820
그래서 이 강의에서는, 이미지의
왼쪽 상단에 있는 표기법을 사용하려고 합니다.

56
00:03:44,820 --> 00:03:49,610
좌표 (0,0)로
표시하겠습니다. 

57
00:03:49,610 --> 00:03:52,660
그리고 오른쪽 아래에는
(1,1)을 나타냅니다.

58
00:03:52,660 --> 00:03:55,442
경계상자를 지정하면

59
00:03:55,442 --> 00:04:00,060
빨간색 직사각형에 중간 점을 지정해야 합니다

60
00:04:00,060 --> 00:04:03,057
그러면 경계상자의 폭,
bw뿐 아니라

61
00:04:03,057 --> 00:04:08,193
높이 bh 에
의해 

62
00:04:08,193 --> 00:04:14,300
이 지점 bx를
정하는 것이죠.

63
00:04:14,300 --> 00:04:19,868
이제 신경망이 예측하려고 하는 

64
00:04:19,868 --> 00:04:23,950
트레이닝 세트에 객체 교차 레이블뿐만 아니라

65
00:04:23,950 --> 00:04:26,740
4개의 추가적인 숫자들을 포함하고 있다면, 

66
00:04:26,740 --> 00:04:31,430
경계상자를 제공하는 것이 여러분의 알고리즘 출력을 만들어내기
위한 지도학습을 사용할 수 있게 하는 것 입니다. 

67
00:04:31,430 --> 00:04:35,910
이는 분류라벨뿐만 아니라 탐지했던 객체의 경계상자가

68
00:04:35,910 --> 00:04:39,830
어디에 있는지 알려줄 4개의
파라미터입니다. 

69
00:04:39,830 --> 00:04:42,415
따라서 이 예에서 이상적인
bx는 약 0.5 일 수 있습니다

70
00:04:42,415 --> 00:04:47,254
왜냐하면 이것이 이미지의 오른쪽으로 절반 정도 이기 때문입니다. 

71
00:04:47,254 --> 00:04:55,863
0.7까지도 가능한데요, 이는 이미지의 아래쪽으로
대략 70% 이기 때문입니다.

72
00:04:55,863 --> 00:05:00,620
이 붉은 사각형의 높이가 이미지의 전체 높이의 약 30%이기 때문에 

73
00:05:00,620 --> 00:05:04,960
bh는 대략 0.3정도 될 것입니다. 

74
00:05:04,960 --> 00:05:10,170
빨간색 상자의 너비가 전체 이미지의 전체 너비의 약 0.4이기 때문에 bw는 약 0.4
일 수 있습니다.

75
00:05:10,170 --> 00:05:14,510
빨간색 상자의 너비가 전체 이미지의 전체 너비의 약 0.4이기 때문에 bw는 약 0.4
일 수 있습니다.

76
00:05:15,940 --> 00:05:20,905
우리가 이것을 위해 지도학습과제로서 목표라벨 y를 어떻게 정의 내릴까 하는 측면에서, 

77
00:05:20,905 --> 00:05:24,581
한 번 이것을 공식화 해봅시다. 

78
00:05:24,581 --> 00:05:29,195
그래서 기억해야 할 것은,
이것들은 4 가지 분류이고, 

79
00:05:29,195 --> 00:05:34,775
신경망은 분류라벨, 즉
분류라벨의 가능성뿐만 아니라 

80
00:05:36,035 --> 00:05:39,195
이 4개의 숫자를
출력합니다.

81
00:05:40,530 --> 00:05:47,710
다음과 같이 목표라벨 y를
정의 내려봅시다. 

82
00:05:47,710 --> 00:05:53,480
이것은 벡터입니다. 첫
번째 요소인 pc는

83
00:05:53,480 --> 00:05:54,560
‘객체가 있는가?’로 정했습니다.

84
00:05:55,930 --> 00:06:02,140
따라서 객체가 클래스 1,
2 또는 3 이 되면, pc는 1이 될 것입니다. 

85
00:06:02,140 --> 00:06:04,477
이것이 배경 분류라면, 

86
00:06:04,477 --> 00:06:09,018
탐지하고자 하는 객체가 아무것도 없다면, pc는 0이 될 것입니다. 

87
00:06:09,018 --> 00:06:11,973
객체가 있을 가능성을 나타내는 것으로

88
00:06:11,973 --> 00:06:15,020
pc를 간주할 수도 있습니다. 

89
00:06:15,020 --> 00:06:19,320
즉, 여러분이
탐지하려고 하는 분류 중 하나가 거기에 있다는 가능성을 말하는 것입니다. 

90
00:06:19,320 --> 00:06:22,640
따라서 이것은 배경분류 이외의 것을 가리키는 것이죠.

91
00:06:22,640 --> 00:06:28,338
다음으로는, 만약
객체가 있다면, 여러분은 bx,

92
00:06:28,338 --> 00:06:35,010
by, bh와 bw, 즉 탐지했던 객체를 위해서 경계상자를
출력하고 싶어할 것입니다.

93
00:06:35,010 --> 00:06:40,436
그리고 최종적으로 객체가 있다면, 만약 pc가 1이라면,

94
00:06:40,436 --> 00:06:44,054
c1, c2 그리고 

95
00:06:44,054 --> 00:06:49,610
c3를 출력값으로 입력해야 합니다, 이들은 class 1, class2, class3를 의미합니다. 

96
00:06:49,610 --> 00:06:53,030
따라서 이는 보행자, 자동차
또는 오토바이가 되겠네요. 

97
00:06:53,030 --> 00:06:56,340
그리고 우리가 다루고 있는 문제에서 

98
00:06:56,340 --> 00:06:59,450
여러분의 이미지는 단지 하나의 객체만을 가지고 있다고 가정합시다.

99
00:06:59,450 --> 00:07:03,040
따라서 대부분의 개체 중 하나가 그림에 나타납니다.

100
00:07:03,040 --> 00:07:06,490
이 위치 측정 문제를 가진 분류에서 나오는 것이죠.

101
00:07:06,490 --> 00:07:09,240
몇 가지 예제를 좀 더 살펴봅시다. 

102
00:07:09,240 --> 00:07:16,310
이것이 트레이닝 세트 이미지이고, 이것이 x이고, 

103
00:07:16,310 --> 00:07:22,650
y는 pc가 1이 되는 첫 번째 구성요소가 될 것입니다. 

104
00:07:22,650 --> 00:07:27,870
왜냐하면 객체 bx, by, bh와 bw가 경계상자를 지정할 테니까요. 

105
00:07:27,870 --> 00:07:32,260
따라서 라벨이 지정된 트레이닝 세트에는 라벨에 있는 경계상자가 필요할 것입니다. 

106
00:07:32,260 --> 00:07:35,570
그리고 마지막으로 이건 자동차인데요, class 2이죠.

107
00:07:35,570 --> 00:07:38,680
c1은 보행자가 아니기 때문입니다 0일 것입니다.

108
00:07:38,680 --> 00:07:44,640
c2는 자동차이므로 1이 되고, c3는 오토바이가 아니므로 0이 될 것입니다. 

109
00:07:44,640 --> 00:07:50,630
c1, c2, 그리고 c3 중에서, 기껏해야 그 중 하나는 1이 될 것입니다.

110
00:07:50,630 --> 00:07:54,010
이것은 이미지 안에 객체가 있다면 거죠.

111
00:07:54,010 --> 00:07:55,890
이미지 안에 객체가 없다면 어떻게 될까요? 

112
00:07:55,890 --> 00:07:59,957
x가 이것과 같은 트레이닝 예시가 있다면 어떻게 될까요?

113
00:07:59,957 --> 00:08:03,807
이런 경우에는, pc는 0이 될 것이고,

114
00:08:03,807 --> 00:08:08,979
이 나머지 원소들은 상관없는 것들이 됩니다.

115
00:08:08,979 --> 00:08:13,940
이 안에 물음표를 다 써보겠습니다. 

116
00:08:13,940 --> 00:08:18,318
이것은 ‘don’t care’ (상관없는)것입니다. 왜냐하면 이 이미지 안에 객체가 없다면

117
00:08:18,318 --> 00:08:23,074
세 개의 객체 c1, c2, c3뿐만 아니라 네트워크 출력 값에 있는

118
00:08:23,074 --> 00:08:27,280
경계상자가 무엇인지 상관없기 때문입니다. 

119
00:08:27,280 --> 00:08:33,870
그래서 일련의 라벨 트레이닝 예제를 통해, 객체가 있는 이미지와 객체가 없는 이미지 둘 다를 위해서 

120
00:08:33,870 --> 00:08:38,680
어떻게 코스트 라벨 y뿐만 아니라

121
00:08:38,680 --> 00:08:42,880
입력이미지 x를 구성할지를 생각해 보는 것입니다. 

122
00:08:42,880 --> 00:08:45,660
그러면 이 세트가 여러분의 트레이닝 세트를 결정할 것입니다.

123
00:08:47,100 --> 00:08:51,520
마지막으로 신경망을 훈련시키기 위해

124
00:08:51,520 --> 00:08:53,930
사용하는 loss function (손실함수)를 설명하겠습니다. 

125
00:08:53,930 --> 00:08:59,070
기본 참 레이블는 y 였고, 신경망은 ŷ을 입니다. 

126
00:08:59,070 --> 00:09:01,010
그럼 손실은 무엇이 될까요?

127
00:09:01,010 --> 00:09:05,484
만약 제곱오차(squared error)를 사용하게 되면

128
00:09:05,484 --> 00:09:10,105
손실은 (ŷ1 - y1)제곱, 더하기 

129
00:09:10,105 --> 00:09:15,026
(ŷ2 - y2)의 제곱, 더하기

130
00:09:15,026 --> 00:09:19,810
이렇게 쭉 이어지다가 (ŷ - y8)의 제곱이 될 것입니다.

131
00:09:19,810 --> 00:09:23,970
이처럼 y는 8개 구성요소를 가지고 있는걸 확인하십시오.

132
00:09:23,970 --> 00:09:28,200
따라서 다른 원소들의 차이의 제곱의 총액이 되는 것입니다. 

133
00:09:28,200 --> 00:09:33,650
그리고 이것은 y1 = 1이면 손실입니다. 

134
00:09:33,650 --> 00:09:36,690
그리고 대상이 있는 경우입니다. 

135
00:09:36,690 --> 00:09:39,671
따라서, y1 = pc

136
00:09:39,671 --> 00:09:43,685
이미지에 객체가 있으면 pc = 1 이죠.

137
00:09:43,685 --> 00:09:47,475
따라서 손실은 모든 차이 나는 원소들의 제곱의 합이 되는 것입니다. 

138
00:09:48,675 --> 00:09:53,418
또 다른 경우는, 만약 y1 = 0이라면

139
00:09:53,418 --> 00:09:57,790
다시 말해, pc = 0 이죠.

140
00:09:57,790 --> 00:10:04,930
이 경우, 손실은 (ŷ1 -y1) 의 제곱 값입니다. 

141
00:10:04,930 --> 00:10:11,170
왜냐하면 이 두 번째 경우에, 나머지 요소들 전부 ‘don’t care’인 불필요한 것이기 때문이죠.

142
00:10:11,170 --> 00:10:16,068
신경 써야 하는 것은 pc를 출력하는 데에

143
00:10:16,068 --> 00:10:19,390
얼마나 정확하게 신경망이 작동하는지 입니다. 

144
00:10:19,390 --> 00:10:23,304
요약하자면, y1 = 1, 바로 이 경우를 말하는 건데요, 

145
00:10:23,304 --> 00:10:28,343
이 모든 여덟 개의 요소의 예측된 혹은 실제적인 출력값에서 생겨난

146
00:10:28,343 --> 00:10:33,402
근 편차에 대해 벌칙을 주는 차원에서 오차제곱을 사용할 수 있습니다.

147
00:10:33,402 --> 00:10:39,749
반면에, y1 = 0 이면, 두 번째 칸의 있는 ‘don’t care’ 상관없는 요소들 입니다..

148
00:10:39,749 --> 00:10:44,698
신경 써야 하는 것은 

149
00:10:44,698 --> 00:10:48,880
신경망이 y1, 즉 pc를 얼마나 정확하게 예측하는가 입니다. 

150
00:10:48,880 --> 00:10:53,554
모든 세부적인 것들을 알고 싶어하는 분들을 위해 추가 정보를 드리자면, 

151
00:10:53,554 --> 00:10:57,760
저는 설명을 단순하게 하려고 오차제곱을 사용했습니다만, 

152
00:10:57,760 --> 00:11:02,840
실제에서는 열어 기능들을 사용할 수 있습니다. 예를 들어, c1, c2, c3에

153
00:11:02,840 --> 00:11:06,438
log-likelihood loss와 softmax 출력값들을 사용할 수 있을 것입니다. 

154
00:11:06,438 --> 00:11:10,118
다른 요소들에다가는 오차제곱을 사용할 수도 있습니다. 

155
00:11:10,118 --> 00:11:14,414
예를 들어, 경계상자 좌표에 오차제곱 같은 것을 사용할 수 있습니다. 

156
00:11:14,414 --> 00:11:19,200
pc 에 대하여는, 로지스틱 회귀 손실과 같은 기능을 사용할 수 있을 것입니다. 

157
00:11:19,200 --> 00:11:22,830
오차제곱을 사용하더라도, 이것은 아마 잘 작동할 것입니다.

158
00:11:22,830 --> 00:11:27,030
자, 이것이 객체를 분류하는 것뿐 아니라

159
00:11:27,030 --> 00:11:29,140
위치 측정까지 하는 신경망을 어떻게 만들 수 있을지에 대한 내용입니다. 

160
00:11:29,140 --> 00:11:33,270
신경망으로 하여금 물체들이 사진 어디에 있는지를 알려주는 실제 숫자들을 출력하도록 시키는 

161
00:11:33,270 --> 00:11:38,040
이 아이디어는 매우 강력한 것으로 판명되었습니다. 

162
00:11:38,040 --> 00:11:42,940
다음 강의에서는, 이 아이디어가 몇몇 다른 위치에서도 사용되는지 공유하고 싶습니다. 

163
00:11:42,940 --> 00:11:48,180
신경망으로 하여금 실제 숫자 세트를 만들도록 하는 아이디어가

164
00:11:48,180 --> 00:11:51,980
컴퓨터 비전 분야 어디에서 사용하기에도 강력할 것입니다.

165
00:11:51,980 --> 00:11:53,360
다음 강의로 가시죠.