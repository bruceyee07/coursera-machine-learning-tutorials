בוידאו זה נדבר על גישה לבניית מערכות המלצה שנקראת סינון שיתופי. האלגוריתם שאנחנו מדברים עליו הוא בעל תכונה מעניינת מאוד שהוא עושה מה שנקרא למידת תכונות ובזה אני מתכוון שזה אלגוריתם שיכול להתחיל ללמוד בעצמו באילו תכונות להשתמש. הנה מערך הנתונים שהיה לנו, ואנחנו הנחנו שלגבי כל סרט, מישהו בא וסיפר לנו כמה רומנטי הסרט הזה וכמה אקשן יש בסרט הזה. אבל כפי שאפשר לדמיין זה יכול להיות מאוד קשה, לקחת זמן רב ולהיות יקר באמת לנסות להשיג מישהו שיצפה בכל סרט ויספר לנו כמה רומנטי כל סרט וכמה הוא מלא אקשן, ובדרך כלל אנחנו היינו רוצים אפילו יותר מאשר רק שתי התכונות האלה. אז מאיפה אנחנו יכולים לקבל את התכונות האלה? אז בואו נשנה קצת את הבעיה ונניח שיש לנו מערך נתונים שבו אנחנו לא יודעים את הערכים של התכונות האלה. אז אנחנו מקבלים את סדרת הנתונים של הסרטים ואת הדירוג שבו דירגו אותם המשתמשים, אבל אין לנו מושג כמה רומנטי כל סרט ואין לנו מושג כמה מלא פעולה כל סרט, אז אני אחליף את כל הדברים האלה בסימני שאלה. אבל עכשיו בואו נעשה הנחה קצת שונה. נניח שהגענו לכל אחד מהמשתמשים שלנו, וכל אחד מהמשתמשים שלנו סיפר לנו כמה הם אוהבים סרטים רומנטיים וכמה הם אוהבים סרטי פעולה. אז לאליס קישרנו וקטור פרמטרים θ1. לבוב θ2. לקרול θ3. ולדייב θ4. ונניח גם שאנחנו מכירים את המשתמשים ואליס מספרת לנו שהיא ממש אוהבת סרטים רומנטיים ולכן יש שם 5 שהוא המכפיל המשויך ל-x1 ונניח שאליס אומרת לנו שהיא ממש לא אוהבת סרטי פעולה ולכן יש כאן 0. ובוב אומר לנו משהו דומה וכך בנינו את θ2. בעוד קרול מספרת לנו שהיא באמת אוהבת סרטי פעולה, ולכן יש כאן 5, המכפיל שקשור ל-x2, וכזכור יש גם x0 שווה 1 ונגיד שקרול גם מספרת לנו שהיא לא אוהבת סרטים רומנטיים וכדומה, וגם לדייב יש סיפור דומה. בואו נניח שאיכשהו אנחנו יכולים ללכת למשתמשים וכל משתמש j אומר לנו פשוט מה הערך של θj עבורם. בעצם אומר לנו עד כמה הם אוהבים סוגים שונים של סרטים. אם אנחנו יכולים לקבל את הפרמטרים θ האלה מהמשתמשים שלנו אז מתברר שאפשר לנסות ולהסיק מה הם הערכים של x1 ו-x2 עבור כל סרט. בואו נראה דוגמה. בואו נסתכל על סרט 1. לסרט 1 קשור וקטור תכונות (x(1. הסרט הזה נקרא "אהבה סופסוף" אבל בואו נתעלם מהשם. בוא נניח שאנחנו לא יודעים על מה הסרט, בואו נתעלם מהשם של הסרט. כל מה שאנחנו יודעים הוא שאליס אהבה את הסרט הזה. בוב אהב את הסרט הזה. קרול ודייב שנאו את הסרט הזה. אז מה אנחנו יכולים להסיק? ובכן, אנחנו יודעים מוקטורי התכונות שאליס ובוב אוהבים סרטים רומנטיים כי הם אמרו לנו את זה, יש כאן 5. בעוד קרול ודייב, אנחנו יודעים שהם שונאים סרטים רומנטיים ושהם אוהבים סרטי פעולה. כי אלה הם וקטורי הפרמטרים שמשתמשים 3 ו-4, קרול ודייב, נתנו לנו. ולכן על סמך העובדה שסרט 1 היה אהוב על אליס ובוב ושנוא על קרול ודייב, אפשר להסיק בסבירות גבוהה שזה סרט רומנטי, ושזה בטח לא סרט פעולה רציני. הדוגמה הזו היא קצת פשטנית מבחינה מתמטית, אבל מה שאנחנו באמת שואלים הוא איך צריך וקטור התכונות x1 להיראות כדי ש-θ1ᵀ כפול x1 יהיה שווה בערך ל-5, זה הדירוג של אליס, וכך ש-θ2ᵀx1 יהיה גם הוא שווה בערך ל-5, וש-θ3ᵀx1 יהיה בערך 0, כי זה היה הדירוג של קרול, ו-θ4ᵀx1 יהיה בערך 0. ואפשר להעריך ש-x1 שווה 1 באיבר ההיסט, ואז 1.0, ו-0.0, זה נראה הגיוני בהתחשב במה שאנחנו יודעים על ההעדפות של אליס, בוב, קרול ודייב על סרטים והאופן שבו הם מדרגים את הסרט הזה . אז באופן כללי יותר, אנחנו יכולים ללכת לאורכה של הרשימה הזו ולנסות להבין מה יכולות להיות תכונות סבירות גם עבור הסרטים האחרים האלה. בואו ונפרמל את הבעיה הזו של לימוד התכונות xi. נניח שהמשתמשים שלנו נתנו לנו את ההעדפות שלהם. נניח שהמשתמשים שלנו באו ואמרו לנו את הערכים האלה עבור θ1 עד (θ(nᵤ, ועכשיו אנחנו רוצים ללמוד את וקטור התכונות xi עבור הסרט מספר i. מה שאנחנו יכולים לעשות הוא לפיכך להציג את בעיית האופטימיזציה הבאה. אנחנו רוצים לסכם את כל האינדקסים j שעבורם יש לנו דירוג עבור סרט i כי אנחנו מנסים ללמוד את התכונות של הסרט i, זאת אומרת את וקטור התכונות xi. ואז אנחנו רוצים למזער את ריבוע השגיאה, אנחנו רוצים לבחור תכונות xi, כך שהערך החזוי של איך ידרג המשתמש j את הסרט i, יהיה דומה או לא שונה מדי מבחינת ריבועי השגיאה, מהערך האמיתי (y(i,j שאותו ראינו בדירוג של המשתמש j על הסרט i. אז, רק לסיכום מה שעושה הביטוי הזה הוא לנסות לבחור תכונות xi כך שעבור כל המשתמשים j שדירגו את הסרט, האלגוריתם ינבא ערך עבור הדירוג של המשתמש את הסרט שאיננו רחוק מדי במובן ריבועי השגיאה מהערך האמיתי שהמשתמש אכן דירג את הסרט. אז זהו מונח ריבוע השגיאה. וכרגיל, אנחנו יכולים גם להוסיף ביטוי של הסדרה כדי למנוע מהתכונות להיות גדולות מדי. אז כך היינו לומדים את התכונות של סרט מסוים אחד, אבל מה שאנחנו רוצים לעשות הוא ללמוד את כל התכונות עבור כל הסרטים, ולכן מה שנעשה הוא להוסיף עוד סיכום מסביב לכל זה, אנחנו נסכם על כל ה-nₘ סרטים, למזער את המטרה כאן למעלה, ולסכם את זה על כל הסרטים. וכשנעשה את זה, נקבל את בעיית האופטימיזציה הרשומה כאן. ואם נמזער את זה, בתקווה נקבל סדרת תכונות סבירה עבור כל הסרטים. אז שוב על נקי, האלגוריתם עליו דיברנו בווידאו הקודם והאלגוריתם שדיברנו עליו בווידאו הנוכחי. בסרטון הקודם, מה שהראינו היה שאם יש לנו קבוצה של דירוגי סרטים, אם יש לנו הנתונים של (r(i,j וגם את (y(i,j, יש לנו דירוגים של סרטים. אז בהינתן תכונות של סרטים שונים אנחנו יכולים ללמוד את הפרמטרים θ האלה. אז לו ידענו את התכונות, יכולנו ללמוד את הפרמטרים θ עבור המשתמשים השונים. ומה שהראינו קודם בסרטון הזה הוא שאם המשתמשים מוכנים לתת לנו פרמטרים, שוב נוכל להעריך תכונות עבור הסרטים השונים. אז עכשיו זה סוג של בעית ביצה ותרנגולת. מה בא קודם? אם נוכל להשיג את הוקטורים θ, נוכל לדעת את הx-ים. אם יש לנו x-ים, נוכל ללמוד את הוקטורים θ. אז מה שאפשר לעשות הוא, וזה ממש עובד, מה שאפשר לעשות הוא בעצם לנחש באופן אקראי איזשהם ערכים של הווקטורים θ. ובהתבסס על הניחוש האקראי הראשוני שלנו עבור θ, אפשר להמשיך ולהשתמש בתהליך שעכשיו דיברנו עליו כדי ללמוד תכונות עבור הסרטים השונים. עכשיו בהינתן איזה סט ראשוני של תכונות עבור הסרטים, אפשר להשתמש בשיטה הראשונה שעליה דיברנו בווידאו הקודם כדי לנסות להשיג אומדן אפילו טוב יותר עבור הפרמטרים θ. ועכשיו כשיש לנו הגדרה יותר טובה של הפרמטרים θ עבור המשתמשים שלנו, אנחנו יכולים להשתמש בה כדי לקבל אולי אפילו קבוצה טובה יותר של תכונות, וכן הלאה. ואנחנו יכולים להריץ איטרציות, הלוך ושוב, אופטימיזציה של θ, של x, של θ, של x, וכן הלאה, זה באמת עובד וכשמריצים את זה, זה גורם לאלגוריתם להתכנס לסדרה סבירה של תכונות עבור הסרטים ולקבוצה סבירה של פרמטרים עבור המשתמשים השונים. אז זהו אלגוריתם ראשוני של סינון שיתופי. זה לא באמת האלגוריתם הסופי שבו אנחנו נשתמש. בסרטון הבא אנחנו נראה איך אפשר לשפר את האלגוריתם הזה ולהפוך אותו לדי הרבה יותר יעיל מבחינה חישובית. אבל אני מקווה שזה נותן לכם תחושה של איך אפשר לנסח את הבעיה כך שנוכל בו זמנית ללמוד הן את הפרמטרים של המשתמשים והן את התכונות של סרטים שונים. ועבור הבעיה הזו, עבור בעיית מערכת ההמלצות, הדבר הזה אפשרי רק משום שכל משתמש מדרג מספר סרטים, ובתקווה כל סרט מדורג על ידי הרבה משתמשים. אז אפשר לעשות איטרציות קדימה ואחורה כתהליך לאומדן של θ ושל x. אז לסיכום, בסרטון הזה ראינו אלגוריתם סינון שיתופי ראשוני. המונח 'סינון שיתופי' מתייחס לכך שכאשר אנחנו מפעילים את האלגוריתם הזה עם קבוצה גדולה של משתמשים, כל המשתמשים האלה משתפים למעשה, הם משתפים פעולה כדי לייצר דירוגים טובים יותר של סרטים עבור כולם, שכן כל משתמש שמדרג איזו תת-קבוצה של סרטים, כל משתמש כזה עוזר לאלגוריתם במעט ללמוד תכונות טובות יותר, ואז על ידי כך שאני מדרג בעצמי כמה סרטים, אני עוזר למערכת ללמוד תכונות טובות יותר והתכונות האלה יכולות לשמש כדי לייצר תחזיות טובות יותר על הסרטים עבור כולם. ולכן יש אווירה כזו של שיתוף פעולה שבה כל משתמש עוזר למערכת ללמוד תכונות טובות יותר לטובת הכלל. אז לזה קוראים סינון שיתופי. בסרטון הבא אנחנו ניקח את הרעיונות שפיתחנו, וננסה לפתח אלגוריתם אפילו טוב יותר, טכניקה קצת יותר טובה לסינון שיתופי.