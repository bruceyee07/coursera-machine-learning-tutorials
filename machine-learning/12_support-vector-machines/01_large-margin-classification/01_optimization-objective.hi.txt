अब तक आपने देखी है एक रेंज विभिन्न लर्निंग अल्गोरिद्म्स की. सूपर्वायज़्ड लर्निंग में,पर्फ़ॉर्मन्स बहुत से सूपर्वायज़्ड लर्निंग अल्गोरिद्म्स की होगी काफ़ी समान, और जो कम मायने रखता है अक्सर होता है या आप इस्तेमाल करें लर्निंग अल्गोरिद्म a और लर्निंग अल्गोरिद्म b, लेकिन जो ज़्यादा मायने रखता है होगा चीज़ें जैसे कितने डेटा पर आप बनाते हैं ये अल्गोरिद्म्स, तथा आपका कौशल अप्लाई करने में इन अल्गोरिद्म्स को. चीज़ें जैसे चुनाव आपके फ़ीचर्ज़ के डिज़ाइन का देने के लिए लर्निंग अल्गोरिद्म को, और आप चुनाव करते हैं रेगुलराइज़ेशन पेरामिटर, और वैसी चीज़ें. लेकिन, एक अन्य अल्गोरिद्म है जो बहुत प्रभावशाली है और इस्तेमाल होता है बहुत अधिक दोनो इंडस्ट्री और शिक्षा के क्षेत्र में, और उसे कहते हैं सपोर्ट वेक्टर मशीन. और तुलना में दोनो लॉजिस्टिक रेग्रेशन और न्यूरल नेटवर्क्स के, सपोर्ट वेक्टर मशीन या SVM कभी-कभी देती है एक बेहतर, और कभी-कभी ज़्यादा प्रभावशाली ढंग लर्न करने के लिए जटिल नॉन-लिनीअर फ़ंक्शन्स. तो चलो बात करते हैं उस बारे में अगले वीडियो में. बाद में इस कोर्स में, मैं करूँगा एक तुरत सर्वे / सर्वेक्षण एक रेंज का विभिन्न सूपर्वायज़्ड अल्गोरिद्म्स का सिर्फ़ मैं उन्हें बहुत संक्षेप में बताऊँगा. लेकिन सपोर्ट वेक्टर मशीन, देखते हुए इसकी लोकप्रियता और कितना प्रभावशाली है यह, यह होगा आख़िरी सूपर्वायज़्ड लर्निंग अल्गोरिद्म जिस पर मैं व्यतीत करूँगा काफ़ी समय इस कोर्स में. जैसे बनाने में हमारे अन्य लर्निंग अल्गोरिद्म्स, हम शुरू करेंगे ऑप्टिमायज़ेशन अब्जेक्टिव से. तो, चलो शुरू करते हैं इस अल्गोरिद्म के बारे में. वर्णन करने के लिए सपोर्ट वेक्टर मशीन का, मैं वास्तव में शुरू करूँगा लॉजिस्टिक रेग्रेशन से, और दिखाऊँगा कि कैसे हम बदल सकते हैं इसे थोड़ा, और पा सकते हैं जो अनिवार्यत: सपोर्ट वेक्टर मशीन है. तो लॉजिस्टिक रेग्रेशन में, हमारे पास है हमारी परिचित फ़ॉर्म हायपॉथिसस की और सिग्मोईड ऐक्टिवेशन फ़ंक्शन दिखाया हुआ दाईं तरफ़. और समझाने के थोड़ा गणित, मैं लूँगा z डिनोट करने के लिए थीटा ट्रान्स्पोज़ x. अब चलो सोचते हैं हम क्या चाहते हैं लॉजिस्टिक रेग्रेशन से करवाना. यदि हमारे पास है एक इग्ज़ाम्पल्ज़ जिसमें y बराबर है एक और उससे मेरा मतलब है एक इग्ज़ाम्पल या ट्रेनिंग सेट में, या टेस्ट सेट में या क्रॉस वैलिडेशन सेट में, लेकिन जब y है बराबर एक तब हम एक तरह से उम्मीद कर रहे हैं कि h ऑफ़ x होगा एक के लगभग. ठीक है, हम उम्मीद कर रहे हैं सही क्लैसिफ़ाई करने की उस इग्ज़ाम्पल को. और उसका क्या मतलब है कि थीटा ट्रान्स्पोज़ x होना चाहिए 0 से बड़ा. तो वहाँ है ग्रेटर दैन साइन, ग्रेटर दैन साइन उसका मतलब है बहुत बहुत बड़ा 0 से. और वह है क्योंकि यह है z, थीटा ट्रान्स्पोज़ x, जब z है काफ़ी बड़ा 0 से, ये बहुत दूर 0 से दाईं तरफ़. तब आउट्पुट लॉजिस्टिक रेग्रेशन की होती है लगभग एक. इसके विपरीत, यदि हमारे पास है एक इग्ज़ाम्पल जहाँ y बराबर है ज़ीरो, तब हम क्या उम्मीद कर रहे हैं कि हायपॉथिसस आउट्पुट करेगी एक वैल्यू लगभग ज़ीरो. और वह मेल खाता है थीटा ट्रान्स्पोज़ x ऑफ़ z का होना 0 से काफ़ी कम से क्योंकि वह मेल खाता है कि एक हायपॉथिसस आउट्पुट करेगी एक वैल्यू लगभग ज़ीरो. यदि आप देखें कॉस्ट फ़ंक्शन को लॉजिस्टिक रेग्रेशन के, आपको क्या मिलेगा कि प्रत्येक इग्ज़ाम्पल (x, y) योगदान देता है एक टर्म इस तरह की पूरे कॉस्ट फ़ंक्शन को, सही? तो पूरे कॉस्ट फ़ंक्शन के लिए, हमारे पास होगा एक सम/ योग सभी ट्रेनिंग इग्ज़ाम्पल्ज़ पर और 1 ओवर m टर्म, जो यह इक्स्प्रेशन है यहाँ, वह है टर्म जो एक ही ट्रेनिंग इग्ज़ाम्पल्ज़ योगदान देता है पूरे अब्जेक्टिव फ़ंक्शन को तो हम उन्हें सिर्फ़ जोड़ सकते हैं. अब यदि मैं लेता हूँ परिभाषा मेरी हायपॉथिसस की और प्लग करता हूँ यहाँ, तब मुझे क्या मिलता है कि प्रत्येक ट्रेनिंग इग्ज़ाम्पल योगदान देता है इस टर्म का, अनदेखा करते हुए 1 ओवर m लेकिन यह देता है वह टर्म मेरे पूरे कॉस्ट फ़ंक्शन को लॉजिस्टिक रेग्रेशन के लिए. अब लेते हैं दो केस जब y है बराबर एक के और जब y है बराबर ज़ीरो के. पहले केस में, मान लो कि y है बराबर 1. उस केस में, केवल पहली टर्म मायने रखती है अब्जेक्टिव में, क्योंकि यह वन माइनस y टर्म होगी ज़ीरो यदि y है बराबर एक. तो जब y है एक, जब हमारे इग्ज़ाम्पल x, y में, जब y है 1, हमें जो मिलता है यह टर्म. माइनस लॉग वन ओवर वन, प्लस e की पॉवर नेगेटिव z जहाँ समान पिछली लाइन के, मैं इस्तेमाल कर रहा हूँ z डिनोट करने के लिए थीटा ट्रान्स्पोज़ x और निश्चय ही एक कॉस्ट फ़ंक्शन में मेरे पास होना चाहिए यह माइनस लाइन जो हमारे पास अभी थी यदि y है एक तो वह है बराबर एक, मैं सिर्फ़ सरल करता हूँ एक तरीक़े से इक्स्प्रेशन में जो मैंने लिखा है नीचे यहाँ. और यदि हम प्लॉट करते हैं इस फ़ंक्शन को z के फ़ंक्शन की तरह, आप पाते हैं कि आपको मिलता है यह कर्व जो दिखाया है नीचे बाईं तरफ़ स्लाइड पर. और इसलिए, हम देखते भी हैं कि जब z बहुत बड़ा है, मतलब, जब थीटा ट्रान्स्पोज़ x बड़ा है, वह कॉरेस्पॉंड करता है z की एक वैल्यू से जो देती हैं हमें एक काफ़ी छोटी वैल्यू, एक बहुत ही छोटा योगदान कॉस्ट फ़ंक्शन को. और यह एक तरह से स्पष्ट करता है कि क्यों, जब लॉजिसिटिक रेग्रेशन देखता हैं एक पॉज़िटिव इग्ज़ाम्पल, जब y=1, यह सेट करता हैं थीटा ट्रान्स्पोज़ x को बहुत बड़ा क्योंकि वह कॉरेस्पॉंड करता है इस टर्म से, कॉस्ट फ़ंक्शन में, छोटा होने की वजह से. अब बनाने के लिए सपोर्ट वेक्टर मशीन, यह है जो हम करेंगे. हम लेंगे यह कॉस्ट फ़ंक्शन, यह माइनस लॉग 1 ओवर 1 प्लस e की पॉवर नेगेटिव z, और बदलाव करेंगे उसमें थोड़ा. मैं लेता हूँ यह पोईँट 1 यहाँ पर, और बनाता हूँ कॉस्ट फ़ंक्शन जो आप इस्तेमाल करेंगे. यह नया कॉस्ट फ़ंक्शन हो सकता है समतल यहाँ से बाहर की तरफ़, और और फिर हम बनाते हैं कुछ जो जाता है एक सीधी लाइन जैसे, लॉजिस्टिक रिग्रेशन के समान. लेकिन यह होगा एक सीधी लाइन इस हिस्से में. तो जो कर्व मैंने अभी बनाया मजेंटा में, और कर्व जो मैं अभी बनाया बैंगनी और मजेंटा में, तो यदि यह है एक लगभग सही अनुमान कॉस्ट फ़ंक्शन का लॉजिस्टिक रेग्रेशन में. सिवाय इसके कि अब यह बना है दो खंडो से, वहाँ है यह समतल खंड दाईं तरफ़, और फिर है यह सीधी लाइन का खंड बाईं तरफ़. और ज़्यादा चिंता न करें स्लोप की सीधी लाइन के खंड में. इससे ज़्यादा फर्क नहीं पड़ता. लेकिन वह है नया कॉस्ट फ़ंक्शन जो हम इस्तेमाल करेंगे जब y है एक, और आप सोच सकते हैं यह होना चाहिए कुछ, काफ़ी समान लॉजिसिटक रेग्रेशन के. लेकिन ऐसा होता है, कि यह देगा सपोर्ट वेक्टर मशीन को कॉम्प्यूटेशनल फ़ायदा और देता है हमें, बाद में, एक आसान ऑप्टिमायज़ेशन प्रॉब्लम जो होगी आसान हल करने के लिए सॉफ़्टवेयर से. हमने अभी बात की केस y बराबर एक की. दूसरा केस है यदि y बराबर है ज़ीरो. उस केस में, यदि आप देखते हैं कॉस्ट, तब सिर्फ़ दूसरी टर्म अप्लाई होगी क्योंकि पहली टर्म ज़ीरो हो जाती है, ठीक है? यदि y ज़ीरो के बराबर है, तब आपको मिलता है एक ज़ीरो यहाँ, तो आपके पास रह जाती है दूसरी टर्म इस इक्स्प्रेशन की. और इसलिए एक इग्ज़ाम्पल की कॉस्ट, या कॉस्ट फ़ंक्शन को योगदान, दिया जाएगा इस टर्म से यहाँ पर. और यदि आप प्लॉट करते हैं उसे z के एक फ़ंक्शन की तरह, रखते हुए z हॉरिज़ॉंटल ऐक्सिस पर, आपको मिलता है यह. और सपोर्ट वेक्टर मशीन के लिए, एक बार फ़िर, हम बदलेंगे इस नीली लाइन को कुछ समान चीज़ से और बदलेंगे इसे भी एक नई कॉस्ट से, यह समतल यहाँ, यह 0 यहाँ. और वह तब जाता है एक सीधी लाइन जैसे, इस तरह. तो मैं देता हूँ नाम इन दो फ़ंक्शन्स को. यह फ़ंक्शन बाईं तरफ़, मैं कहूँगा इसे कॉस्ट सबस्क्रिप्ट 1 ऑफ़ z, और यह फ़ंक्शन दाईं तरफ़, मैं कहूँगा इसे कॉस्ट सबस्क्रिप्ट 0 ऑफ़ z. और सब्स्क्रिप्ट सिर्फ़ बताती है कॉस्ट को जब y है 1, और जब y है ज़ीरो. इन परिभाषाओं के साथ, हम अब तैयार हैं बनाने के लिए एक सपोर्ट वेक्टर मशीन. यहाँ है कॉस्ट फ़ंक्शन, J ऑफ़ थीटा, जो हमारे पास है लॉजिसिटिक रेग्रेशन के लिए. यदि यह इक्वेज़न दिखती है थोड़ी अपरिचित, वह इसलिए क्योंकि पहले हमारे पास था एक माइनस साइन बाहर, लेकिन यहाँ मैंने क्या किया कि मैं इसके स्थान पर कर दिया माइनस साइन इन इक्स्प्रेशन्स के अंदर, तो इससे यह थोड़ा भिन्न दिखता हैं. सपोर्ट वेक्टर मशीन के लिए हम क्या करेंगे कि अनिवार्यत: लेंगे इसे और बदल देंगे इसे कॉस्ट 1 ऑफ़ z से, वह है कॉस्ट 1 ऑफ़ थीटा ट्रान्स्पोज़ x. और हम लेंगे इसे और बदल देंगे इसे कॉस्ट0 ऑफ़ z से, वह है कॉस्ट0 ऑफ़ थीटा ट्रान्स्पोज़ x. जहाँ कॉस्ट1 फ़ंक्शन है जो हमारे पास थे पिछली स्लाइड पर जो ऐसा दिखता हैं. और कॉस्ट 0 फ़ंक्शन, फिर से जो हमारे पास था पिछली स्लाइड पर, और जो ऐसा दिखता है. तो क्या है हमारे पास सपोर्ट वेक्टर मशीन के लिए एक मिनमायज़ेशन प्रॉब्लम वन ओवर m, सम y i गुणा कॉस्ट1, थीटा ट्रान्स्पोज़ x i, प्लस वन माइनस y i गुणा कॉस्ट 0 थीटा ट्रान्स्पोज़ x i, और फिर मेरा हमेशा का रेगुलराइज़ेशन पेरामिटर. ऐसे. अब, कन्वेन्शन के अनुसार, सपोर्ट वेक्टर मशीन के लिए, हम वास्तव में लिखेंगे चीज़ें थोड़ा अलग ढंग से. हम दोबारा पेरमिटर्स देंगे इसे केवल थोड़ा अलग ढंग से. पहले हम हटाएँगे 1 ओवर m टर्म, और यह है केवल थोड़ी भिन्न कन्वेन्शन जो लोग इस्तेमाल करते हैं सपोर्ट वेक्टर मशीन के लिए तुलना में लॉजिस्टिक रेग्रेशन के. लेकिन यहाँ है कि मेरा क्या मतलब है. आपके पास है एक तरीक़ा करने का इसे, हम सिर्फ़ हटाएँगे ये वन ओवर m टर्म्ज़ और इसे हमें देना चाहिए वही ओप्टिमम वैल्यू थीटा की, ठीक है? क्योंकि 1 ओवर m सिर्फ़ एक कॉन्स्टंट है इसलिए चाहे मैं हल करूँ यह मिनमायज़ेशन प्रॉब्लम जिसमें वन ओवर m है सामने या नहीं, मुझे मिलनी चाहिए वही ओप्टिमम वैल्यू थीटा की. मेरा मतलब ऐसे है, आपको एक उदाहरण देने के लिए, मान लो मेरे पास थी एक मिनमायज़ेशन प्रॉब्लम. मिनमायज़ करें एक नम्बर U ऑफ़ U माइनस पाँच स्क्वेर्ड प्लस वन. ठीक, मिनिमम इसका होता है U बराबर पाँच. अब यदि मुझे लेना होता यह अब्जेक्टिव फ़ंक्शन और गुणा करना होता इसे 10 से. तो यहाँ मेरी मिनमायज़ेशन प्रॉब्लम हैं मिन U, 10 (U - 5)स्क्वेर्ड +10. ठीक है, वैल्यू U की जो मिनमायज़ करती है इसे अभी भी है U बराबर पाँच, सही? तो गुणा करने से किसी चीज़ को जिस पर आप मिनमायज़ कर रहे हैं, किसी कॉन्स्टंट से, इस केस में 10 से, यह नहीं बदलता है वैल्यू U की जो देता है हमें, जो मिनमायज़ करता हैं इस फ़ंक्शन को. तो उसी प्रकार, मैंने क्या किया है कि निकाल देने से m मैं सिर्फ़ क्या कर रहा हूँ कि गुणा कर रहा हूँ मेरे अब्जेक्टिव फ़ंक्शन को किसी कॉन्स्टंट m से और उससे नहीं बदलती थीटा की वैल्यू. उससे प्राप्त होता है मिनिमम. दूसरा परिवर्तन नोटेशन का, जो है सिर्फ़, फिर से, अधिक स्टैंडर्ड कन्वेन्शन जब इस्तेमाल करे रहे हैं SVM, बजाय लॉजिस्टिक रेग्रेशन, है इस प्रकार. लॉजिसिटिक रेग्रेशन के लिए, हम जोड़ते हैं दो टर्म्ज़ अब्जेक्टिव फ़ंक्शन में. पहली है यह टर्म, जो है कॉस्ट जो आती है ट्रेनिंग सेट से और दूसरी है यह टर्म, जो है रेगुलराइज़ेशन टर्म. और हमारे पास क्या था, हमारे पास था A, हम नियंत्रित करते हैं ट्रेड ऑफ़ इन दोनो के बीच इस तरह कि हमें क्या चाहिए है A प्लस और फिर मेरा रेगुलराइज़ेशन पेरामिटर लैम्डा. और फिर आती है कोई दूसरी टर्म B, जहाँ मुझे लगता है मैं ले रहा हूँ A डिनोट करने के लिए यह पहली टर्म, और मैं ले रहा हूँ B डिनोट करने के लिए दूसरी टर्म, शायद लैम्डा के बिना. और बजाय प्राथमिकता देने के इसे A प्लस लैम्डा B, और इसलिए हमने क्या किया था कि सेट करने से भिन्न वैल्यूज़ इस रेगुलराइज़ेशन पेरामिटर लैम्डा की, हम कर पाए ट्रेड-ऑफ़ वेट के अनुपात में दोनो के बीच कि कितना हमें चाहिए ट्रेनिंग सेट, वह है, मिनमायज़ करना A को, और कितनी छोटी हमें रखनी हैं पेरमिटर्स की वैल्यूज़, तो वह होगा, पेरामिटर है B सपोर्ट वेक्टर मशीन के लिए, कन्वेन्शन से, हम इस्तेमाल करेंगे एक भिन्न पेरामिटर. तो बजाय इस्तेमाल करने के लैम्डा यहाँ, नियंत्रित करने के लिए अनुपात वेट्स का पहली और दूसरी टर्म्ज़ में. हम इसके स्थान पर लेंगें एक भिन्न पेरामिटर जिसे कन्वेन्शन से कहते हैं C और इसे सेट करते हैं C * A + B. तो लॉजिस्टिक रेग्रेशन के लिए, यदि हम सेट करते हैं एक बड़ी वैल्यू लैम्डा की, उसका मतलब होगा आप देंगे B को एक अधिक वेट. यहाँ है यदि हम सेट करते हैं C को एक बहुत छोटी वैल्यू, तब वह कॉरेस्पॉंड करता है देने से B को बहुत बड़ा वेट C की अपेक्षा, A की अपेक्षा. तो यह है सिर्फ़ एक भिन्न ढंग नियंत्रित करने का ट्रेड-ऑफ़, यह है सिर्फ़ भिन्न ढंग प्राथमिकता देने के लिए कि कितना ऑप्टिमायज़ करना है पहली टर्म को, या कितना ऑप्टिमायज़ करना है दूसरी टर्म को. और यदि आप चाहें आप सोच सकते हैं इसे पेरामिटर C जैसे जो अदा करता है समान भूमिका जैसे 1 ओवर लैम्डा की. और ऐसा नहीं है कि ये दो इक्वेज़न या ये दो इक्स्प्रेशन होंगे बराबर. यह होगा बराबर 1 ओवर लैम्डा के, वह केस नहीं है. बल्कि यह है कि यदि C बराबर है 1 ओवर लैम्डा, तब ये दो ऑप्टिमायज़ेशन अब्जेक्टिव्स देने चाहिए आपको समान वैल्यू, वही वैल्यू थीटा के लिए तो हम सिर्फ़ डालते हैं उसे यहाँ, मैं क्रॉस करता हूँ लैम्डा यहाँ और लिखता हूँ कॉन्स्टंट C वहाँ. तो वह देता है हमें हमारा पूरा ऑप्टिमायज़ेशन अब्जेक्टिव फ़ंक्शन सपोर्ट वेक्टर मशीन के लिए. और यदि आप न्यूनतम / मिनमायज़ करते हैं उस फ़ंक्शन को, तब आपके पास हैं पेरमिटर्स लर्न किए गए SVM से. अंत में, लॉजिस्टिक रेग्रेशन के विपरीत, सपोर्ट वेक्टर मशीन आउट्पुट नहीं करती प्रॉबबिलिटी कि हमारे पास क्या है हमारे पास है यह कॉस्ट फ़ंक्शन, जिसे हम मिनमायज़ करते हैं पाने के लिए पेरमिटर्स थीटा, और एक सपोर्ट वेक्टर मशीन क्या करती है यह सिर्फ़ करती है प्रिडिक्शन कि y है एक या ज़ीरो. तो हायपॉथिसस प्रिडिक्ट करेगी एक यदि थीटा ट्रान्स्पोज़ x है बड़ा या बराबर ज़ीरो के, और यह प्रिडिक्ट करेगी ज़ीरो अन्यथा, और इसलिए लर्न कर लेने से पेरामिटर्स थीटा, यह है फ़ॉर्म हायपॉथिसस की सपोर्ट वेक्टर मशीन के लिए. तो वह थी एक गणितीय परिभाषा कि सपोर्ट वेक्टर मशीन क्या करती है. अगले कुछ वीडियो में, मैं आप को एक बेहतर अनुभव देने की कोशिश करूँगा कि क्या उद्देश्य है इस ऑप्टिमायज़ेशन अब्जेक्टिव का और क्या यह हायपॉथिसस SVM की, लर्न करेगी और हम बात करेंगे इसे थोड़ा बदलने की भी जटिल नॉन-लिनीअर फ़ंक्शन्स के लिए.