1
00:00:00,690 --> 00:00:03,738
अब तक आपने देखी है एक रेंज विभिन्न लर्निंग अल्गोरिद्म्स की.

2
00:00:03,738 --> 00:00:08,029
सूपर्वायज़्ड लर्निंग में,पर्फ़ॉर्मन्स बहुत से सूपर्वायज़्ड लर्निंग अल्गोरिद्म्स की

3
00:00:08,029 --> 00:00:11,782
होगी काफ़ी समान, और जो कम मायने रखता है अक्सर होता है या आप इस्तेमाल करें

4
00:00:11,782 --> 00:00:14,345
लर्निंग अल्गोरिद्म a और लर्निंग अल्गोरिद्म b, लेकिन

5
00:00:14,345 --> 00:00:17,920
जो ज़्यादा मायने रखता है होगा चीज़ें जैसे कितने डेटा पर आप बनाते हैं

6
00:00:17,920 --> 00:00:21,703
ये अल्गोरिद्म्स, तथा आपका कौशल अप्लाई करने में इन अल्गोरिद्म्स को.

7
00:00:21,703 --> 00:00:25,922
चीज़ें जैसे चुनाव आपके फ़ीचर्ज़ के डिज़ाइन का देने के लिए लर्निंग

8
00:00:25,922 --> 00:00:29,795
अल्गोरिद्म को, और आप चुनाव करते हैं रेगुलराइज़ेशन पेरामिटर, और

9
00:00:29,795 --> 00:00:30,920
वैसी चीज़ें.

10
00:00:30,920 --> 00:00:36,470
लेकिन, एक अन्य अल्गोरिद्म है जो बहुत प्रभावशाली है और इस्तेमाल होता है बहुत अधिक

11
00:00:36,470 --> 00:00:42,370
दोनो इंडस्ट्री और शिक्षा के क्षेत्र में, और उसे कहते हैं सपोर्ट वेक्टर मशीन.

12
00:00:42,370 --> 00:00:46,410
और तुलना में दोनो लॉजिस्टिक रेग्रेशन और न्यूरल नेटवर्क्स के,

13
00:00:46,410 --> 00:00:50,970
सपोर्ट वेक्टर मशीन या SVM कभी-कभी देती है एक बेहतर, और

14
00:00:50,970 --> 00:00:55,070
कभी-कभी ज़्यादा प्रभावशाली ढंग लर्न करने के लिए जटिल नॉन-लिनीअर फ़ंक्शन्स.

15
00:00:55,070 --> 00:00:59,930
तो चलो बात करते हैं उस बारे में अगले वीडियो में.

16
00:00:59,930 --> 00:01:03,240
बाद में इस कोर्स में, मैं करूँगा एक तुरत सर्वे / सर्वेक्षण एक रेंज का

17
00:01:03,240 --> 00:01:07,460
विभिन्न सूपर्वायज़्ड अल्गोरिद्म्स का सिर्फ़ मैं उन्हें बहुत संक्षेप में बताऊँगा.

18
00:01:07,460 --> 00:01:11,630
लेकिन सपोर्ट वेक्टर मशीन, देखते हुए इसकी लोकप्रियता और कितना प्रभावशाली है यह,

19
00:01:11,630 --> 00:01:16,320
यह होगा आख़िरी सूपर्वायज़्ड लर्निंग अल्गोरिद्म जिस पर मैं व्यतीत करूँगा काफ़ी

20
00:01:16,320 --> 00:01:21,240
समय इस कोर्स में. जैसे बनाने में हमारे अन्य लर्निंग अल्गोरिद्म्स,

21
00:01:21,240 --> 00:01:24,710
हम शुरू करेंगे ऑप्टिमायज़ेशन अब्जेक्टिव से.

22
00:01:24,710 --> 00:01:27,008
तो, चलो शुरू करते हैं इस अल्गोरिद्म के बारे में.

23
00:01:29,121 --> 00:01:33,461
वर्णन करने के लिए सपोर्ट वेक्टर मशीन का, मैं वास्तव में शुरू करूँगा

24
00:01:33,461 --> 00:01:36,685
लॉजिस्टिक रेग्रेशन से, और दिखाऊँगा कि कैसे हम बदल सकते हैं इसे थोड़ा, और

25
00:01:36,685 --> 00:01:40,240
पा सकते हैं जो अनिवार्यत: सपोर्ट वेक्टर मशीन है.

26
00:01:40,240 --> 00:01:46,030
तो लॉजिस्टिक रेग्रेशन में, हमारे पास है हमारी परिचित फ़ॉर्म हायपॉथिसस की और

27
00:01:46,030 --> 00:01:48,880
सिग्मोईड ऐक्टिवेशन फ़ंक्शन दिखाया हुआ दाईं तरफ़.

28
00:01:50,430 --> 00:01:52,570
और समझाने के थोड़ा गणित,

29
00:01:52,570 --> 00:01:56,130
मैं लूँगा z डिनोट करने के लिए थीटा ट्रान्स्पोज़ x.

30
00:01:57,690 --> 00:02:01,260
अब चलो सोचते हैं हम क्या चाहते हैं लॉजिस्टिक रेग्रेशन से करवाना.

31
00:02:01,260 --> 00:02:06,150
यदि हमारे पास है एक इग्ज़ाम्पल्ज़ जिसमें y बराबर है एक और उससे मेरा मतलब है एक इग्ज़ाम्पल

32
00:02:06,150 --> 00:02:10,185
या ट्रेनिंग सेट में, या टेस्ट सेट में या क्रॉस वैलिडेशन सेट में, लेकिन

33
00:02:10,185 --> 00:02:15,200
जब y है बराबर एक तब हम एक तरह से उम्मीद कर रहे हैं कि h ऑफ़ x होगा एक के लगभग.

34
00:02:15,200 --> 00:02:18,520
ठीक है, हम उम्मीद कर रहे हैं सही क्लैसिफ़ाई करने की उस इग्ज़ाम्पल को.

35
00:02:18,520 --> 00:02:20,260
और

36
00:02:20,260 --> 00:02:24,620
उसका क्या मतलब है कि थीटा ट्रान्स्पोज़ x होना चाहिए 0 से बड़ा.

37
00:02:24,620 --> 00:02:29,460
तो वहाँ है ग्रेटर दैन साइन, ग्रेटर दैन साइन उसका मतलब है बहुत बहुत बड़ा 0 से.

38
00:02:29,460 --> 00:02:33,600
और वह है क्योंकि यह है z, थीटा

39
00:02:33,600 --> 00:02:38,670
ट्रान्स्पोज़ x, जब z है काफ़ी बड़ा 0 से, ये बहुत दूर 0 से दाईं तरफ़.

40
00:02:38,670 --> 00:02:42,670
तब आउट्पुट लॉजिस्टिक रेग्रेशन की होती है लगभग एक.

41
00:02:44,570 --> 00:02:49,250
इसके विपरीत, यदि हमारे पास है एक इग्ज़ाम्पल जहाँ y बराबर है ज़ीरो, तब हम क्या उम्मीद कर रहे हैं

42
00:02:49,250 --> 00:02:52,530
कि हायपॉथिसस आउट्पुट करेगी एक वैल्यू लगभग ज़ीरो.

43
00:02:52,530 --> 00:02:57,460
और वह मेल खाता है थीटा ट्रान्स्पोज़ x ऑफ़ z का होना 0 से काफ़ी कम से क्योंकि

44
00:02:57,460 --> 00:03:01,150
वह मेल खाता है कि एक हायपॉथिसस आउट्पुट करेगी एक वैल्यू लगभग ज़ीरो.

45
00:03:02,850 --> 00:03:06,340
यदि आप देखें कॉस्ट फ़ंक्शन को लॉजिस्टिक रेग्रेशन के,

46
00:03:06,340 --> 00:03:10,310
आपको क्या मिलेगा कि प्रत्येक इग्ज़ाम्पल (x, y) योगदान देता है

47
00:03:10,310 --> 00:03:13,070
एक टर्म इस तरह की पूरे कॉस्ट फ़ंक्शन को, सही?

48
00:03:14,290 --> 00:03:19,080
तो पूरे कॉस्ट फ़ंक्शन के लिए, हमारे पास होगा एक सम/ योग सभी

49
00:03:19,080 --> 00:03:24,150
ट्रेनिंग इग्ज़ाम्पल्ज़ पर और 1 ओवर m टर्म, जो यह इक्स्प्रेशन है यहाँ,

50
00:03:24,150 --> 00:03:28,490
वह है टर्म जो एक ही ट्रेनिंग इग्ज़ाम्पल्ज़ योगदान देता है

51
00:03:28,490 --> 00:03:31,700
पूरे अब्जेक्टिव फ़ंक्शन को तो हम उन्हें सिर्फ़ जोड़ सकते हैं.

52
00:03:32,970 --> 00:03:37,390
अब यदि मैं लेता हूँ परिभाषा मेरी हायपॉथिसस की और

53
00:03:37,390 --> 00:03:41,470
प्लग करता हूँ यहाँ, तब मुझे क्या मिलता है कि प्रत्येक ट्रेनिंग

54
00:03:41,470 --> 00:03:46,270
इग्ज़ाम्पल योगदान देता है इस टर्म का, अनदेखा करते हुए 1 ओवर m लेकिन

55
00:03:46,270 --> 00:03:50,620
यह देता है वह टर्म मेरे पूरे कॉस्ट फ़ंक्शन को लॉजिस्टिक रेग्रेशन के लिए.

56
00:03:51,810 --> 00:03:57,450
अब लेते हैं दो केस जब y है बराबर एक के और जब y है बराबर ज़ीरो के.

57
00:03:57,450 --> 00:04:01,280
पहले केस में, मान लो कि y है बराबर 1.

58
00:04:01,280 --> 00:04:05,648
उस केस में, केवल पहली टर्म मायने रखती है अब्जेक्टिव में,

59
00:04:05,648 --> 00:04:10,612
क्योंकि यह वन माइनस y टर्म होगी ज़ीरो यदि y है बराबर एक.

60
00:04:13,200 --> 00:04:17,045
तो जब y है एक, जब हमारे इग्ज़ाम्पल x, y में,

61
00:04:17,045 --> 00:04:20,344
जब y है 1, हमें जो मिलता है यह टर्म.

62
00:04:20,344 --> 00:04:25,200
माइनस लॉग वन ओवर वन, प्लस e की पॉवर नेगेटिव z जहाँ समान पिछली

63
00:04:25,200 --> 00:04:30,940
लाइन के, मैं इस्तेमाल कर रहा हूँ z डिनोट करने के लिए थीटा ट्रान्स्पोज़ x और निश्चय ही एक कॉस्ट फ़ंक्शन में

64
00:04:30,940 --> 00:04:35,060
मेरे पास होना चाहिए यह माइनस लाइन जो हमारे पास अभी थी यदि y है एक तो वह है बराबर

65
00:04:35,060 --> 00:04:40,169
एक, मैं सिर्फ़ सरल करता हूँ एक तरीक़े से इक्स्प्रेशन में जो मैंने लिखा है नीचे यहाँ.

66
00:04:41,970 --> 00:04:47,450
और यदि हम प्लॉट करते हैं इस फ़ंक्शन को z के फ़ंक्शन की तरह, आप पाते हैं कि आपको मिलता है यह

67
00:04:47,450 --> 00:04:51,100
कर्व जो दिखाया है नीचे बाईं तरफ़ स्लाइड पर.

68
00:04:51,100 --> 00:04:54,850
और इसलिए, हम देखते भी हैं कि जब z बहुत बड़ा है, मतलब,

69
00:04:54,850 --> 00:05:00,380
जब थीटा ट्रान्स्पोज़ x बड़ा है, वह कॉरेस्पॉंड करता है z की एक वैल्यू से जो देती हैं हमें

70
00:05:00,380 --> 00:05:06,020
एक काफ़ी छोटी वैल्यू, एक बहुत ही छोटा योगदान कॉस्ट फ़ंक्शन को.

71
00:05:06,020 --> 00:05:10,680
और यह एक तरह से स्पष्ट करता है कि क्यों, जब लॉजिसिटिक रेग्रेशन देखता हैं एक पॉज़िटिव इग्ज़ाम्पल,

72
00:05:10,680 --> 00:05:15,620
जब y=1, यह सेट करता हैं थीटा ट्रान्स्पोज़ x को बहुत बड़ा

73
00:05:15,620 --> 00:05:21,090
क्योंकि वह कॉरेस्पॉंड करता है इस टर्म से, कॉस्ट फ़ंक्शन में, छोटा होने की वजह से.

74
00:05:21,090 --> 00:05:23,670
अब बनाने के लिए सपोर्ट वेक्टर मशीन, यह है जो हम करेंगे.

75
00:05:23,670 --> 00:05:28,310
हम लेंगे यह कॉस्ट फ़ंक्शन, यह माइनस लॉग 1 ओवर 1 प्लस e की पॉवर नेगेटिव z,

76
00:05:28,310 --> 00:05:31,370
और बदलाव करेंगे उसमें थोड़ा.

77
00:05:31,370 --> 00:05:35,140
मैं लेता हूँ यह पोईँट 1 यहाँ पर, और

78
00:05:35,140 --> 00:05:37,950
बनाता हूँ कॉस्ट फ़ंक्शन जो आप इस्तेमाल करेंगे.

79
00:05:37,950 --> 00:05:42,240
यह नया कॉस्ट फ़ंक्शन हो सकता है समतल यहाँ से बाहर की तरफ़, और

80
00:05:42,240 --> 00:05:46,626
और फिर हम बनाते हैं कुछ जो जाता है एक सीधी लाइन जैसे,

81
00:05:46,626 --> 00:05:50,280
लॉजिस्टिक रिग्रेशन के समान.

82
00:05:50,280 --> 00:05:53,850
लेकिन यह होगा एक सीधी लाइन इस हिस्से में.

83
00:05:53,850 --> 00:05:58,080
तो जो कर्व मैंने अभी बनाया मजेंटा में, और कर्व जो मैं अभी बनाया बैंगनी और

84
00:05:58,080 --> 00:06:02,130
मजेंटा में, तो यदि यह है एक लगभग सही अनुमान

85
00:06:02,130 --> 00:06:04,470
कॉस्ट फ़ंक्शन का लॉजिस्टिक रेग्रेशन में.

86
00:06:04,470 --> 00:06:09,090
सिवाय इसके कि अब यह बना है दो खंडो से, वहाँ है यह समतल खंड

87
00:06:09,090 --> 00:06:14,180
दाईं तरफ़, और फिर है यह सीधी लाइन का खंड बाईं तरफ़.

88
00:06:14,180 --> 00:06:17,770
और ज़्यादा चिंता न करें स्लोप की सीधी लाइन के खंड में.

89
00:06:17,770 --> 00:06:20,020
इससे ज़्यादा फर्क नहीं पड़ता.

90
00:06:20,020 --> 00:06:24,490
लेकिन वह है नया कॉस्ट फ़ंक्शन जो हम इस्तेमाल करेंगे जब y है एक,

91
00:06:24,490 --> 00:06:28,285
और आप सोच सकते हैं यह होना चाहिए कुछ, काफ़ी समान लॉजिसिटक रेग्रेशन के.

92
00:06:28,285 --> 00:06:31,970
लेकिन ऐसा होता है, कि यह देगा सपोर्ट वेक्टर मशीन को

93
00:06:31,970 --> 00:06:36,590
कॉम्प्यूटेशनल फ़ायदा और देता है हमें, बाद में, एक आसान ऑप्टिमायज़ेशन प्रॉब्लम

94
00:06:38,100 --> 00:06:41,080
जो होगी आसान हल करने के लिए सॉफ़्टवेयर से.

95
00:06:41,080 --> 00:06:43,120
हमने अभी बात की केस y बराबर एक की.

96
00:06:43,120 --> 00:06:45,588
दूसरा केस है यदि y बराबर है ज़ीरो.

97
00:06:45,588 --> 00:06:48,131
उस केस में, यदि आप देखते हैं कॉस्ट,

98
00:06:48,131 --> 00:06:53,390
तब सिर्फ़ दूसरी टर्म अप्लाई होगी क्योंकि पहली टर्म ज़ीरो हो जाती है, ठीक है?

99
00:06:53,390 --> 00:06:55,810
यदि y ज़ीरो के बराबर है, तब आपको मिलता है एक ज़ीरो यहाँ, तो

100
00:06:55,810 --> 00:06:59,140
आपके पास रह जाती है दूसरी टर्म इस इक्स्प्रेशन की.

101
00:06:59,140 --> 00:07:01,620
और इसलिए एक इग्ज़ाम्पल की कॉस्ट, या

102
00:07:01,620 --> 00:07:06,380
कॉस्ट फ़ंक्शन को योगदान, दिया जाएगा इस टर्म से यहाँ पर.

103
00:07:06,380 --> 00:07:08,430
और यदि आप प्लॉट करते हैं उसे z के एक फ़ंक्शन की तरह,

104
00:07:08,430 --> 00:07:13,180
रखते हुए z हॉरिज़ॉंटल ऐक्सिस पर, आपको मिलता है यह.

105
00:07:13,180 --> 00:07:15,190
और सपोर्ट वेक्टर मशीन के लिए, एक बार फ़िर,

106
00:07:15,190 --> 00:07:18,834
हम बदलेंगे इस नीली लाइन को कुछ समान चीज़ से और

107
00:07:18,834 --> 00:07:24,780
बदलेंगे इसे भी एक नई कॉस्ट से, यह समतल यहाँ, यह 0 यहाँ.

108
00:07:24,780 --> 00:07:29,020
और वह तब जाता है एक सीधी लाइन जैसे, इस तरह.

109
00:07:29,020 --> 00:07:32,696
तो मैं देता हूँ नाम इन दो फ़ंक्शन्स को.

110
00:07:32,696 --> 00:07:37,582
यह फ़ंक्शन बाईं तरफ़, मैं कहूँगा इसे कॉस्ट सबस्क्रिप्ट 1 ऑफ़ z,

111
00:07:37,582 --> 00:07:42,660
और यह फ़ंक्शन दाईं तरफ़, मैं कहूँगा इसे कॉस्ट सबस्क्रिप्ट 0 ऑफ़ z.

112
00:07:42,660 --> 00:07:47,652
और सब्स्क्रिप्ट सिर्फ़ बताती है कॉस्ट को जब y है 1,

113
00:07:47,652 --> 00:07:49,990
और जब y है ज़ीरो.

114
00:07:49,990 --> 00:07:53,820
इन परिभाषाओं के साथ, हम अब तैयार हैं बनाने के लिए एक सपोर्ट वेक्टर मशीन.

115
00:07:53,820 --> 00:07:58,360
यहाँ है कॉस्ट फ़ंक्शन, J ऑफ़ थीटा, जो हमारे पास है लॉजिसिटिक रेग्रेशन के लिए.

116
00:07:58,360 --> 00:08:02,560
यदि यह इक्वेज़न दिखती है थोड़ी अपरिचित, वह इसलिए क्योंकि पहले हमारे पास था

117
00:08:02,560 --> 00:08:07,140
एक माइनस साइन बाहर, लेकिन यहाँ मैंने क्या किया कि मैं इसके स्थान पर कर दिया माइनस

118
00:08:07,140 --> 00:08:10,529
साइन इन इक्स्प्रेशन्स के अंदर, तो इससे यह थोड़ा भिन्न दिखता हैं.

119
00:08:12,790 --> 00:08:17,670
सपोर्ट वेक्टर मशीन के लिए हम क्या करेंगे कि अनिवार्यत: लेंगे इसे और

120
00:08:17,670 --> 00:08:25,070
बदल देंगे इसे कॉस्ट 1 ऑफ़ z से, वह है कॉस्ट 1 ऑफ़ थीटा ट्रान्स्पोज़ x.

121
00:08:25,070 --> 00:08:30,210
और हम लेंगे इसे और बदल देंगे इसे कॉस्ट0 ऑफ़ z से,

122
00:08:30,210 --> 00:08:34,120
वह है कॉस्ट0 ऑफ़ थीटा ट्रान्स्पोज़ x.

123
00:08:34,120 --> 00:08:36,730
जहाँ कॉस्ट1 फ़ंक्शन

124
00:08:36,730 --> 00:08:39,920
है जो हमारे पास थे पिछली स्लाइड पर जो ऐसा दिखता हैं.

125
00:08:39,920 --> 00:08:44,470
और कॉस्ट 0 फ़ंक्शन, फिर से जो हमारे पास था पिछली स्लाइड पर, और

126
00:08:44,470 --> 00:08:46,130
जो ऐसा दिखता है.

127
00:08:46,130 --> 00:08:52,082
तो क्या है हमारे पास सपोर्ट वेक्टर मशीन के लिए

128
00:08:52,082 --> 00:08:57,406
एक मिनमायज़ेशन प्रॉब्लम वन ओवर m,

129
00:08:57,406 --> 00:09:01,163
सम y i गुणा कॉस्ट1,

130
00:09:01,163 --> 00:09:06,172
थीटा ट्रान्स्पोज़ x i, प्लस वन माइनस y i

131
00:09:06,172 --> 00:09:11,495
गुणा कॉस्ट 0 थीटा ट्रान्स्पोज़ x i,

132
00:09:11,495 --> 00:09:18,258
और फिर मेरा हमेशा का रेगुलराइज़ेशन पेरामिटर.

133
00:09:21,253 --> 00:09:23,459
ऐसे.

134
00:09:23,459 --> 00:09:26,448
अब, कन्वेन्शन के अनुसार, सपोर्ट वेक्टर मशीन के लिए,

135
00:09:26,448 --> 00:09:29,132
हम वास्तव में लिखेंगे चीज़ें थोड़ा अलग ढंग से.

136
00:09:29,132 --> 00:09:32,180
हम दोबारा पेरमिटर्स देंगे इसे केवल थोड़ा अलग ढंग से.

137
00:09:33,320 --> 00:09:36,870
पहले हम हटाएँगे 1 ओवर m टर्म, और

138
00:09:36,870 --> 00:09:41,170
यह है केवल थोड़ी भिन्न कन्वेन्शन जो लोग इस्तेमाल करते हैं

139
00:09:41,170 --> 00:09:44,690
सपोर्ट वेक्टर मशीन के लिए तुलना में लॉजिस्टिक रेग्रेशन के.

140
00:09:44,690 --> 00:09:46,190
लेकिन यहाँ है कि मेरा क्या मतलब है.

141
00:09:46,190 --> 00:09:50,173
आपके पास है एक तरीक़ा करने का इसे, हम सिर्फ़ हटाएँगे ये वन ओवर m टर्म्ज़

142
00:09:50,173 --> 00:09:53,546
और इसे हमें देना चाहिए वही ओप्टिमम वैल्यू थीटा की, ठीक है?

143
00:09:53,546 --> 00:09:56,030
क्योंकि 1 ओवर m सिर्फ़ एक कॉन्स्टंट है इसलिए

144
00:09:56,030 --> 00:10:00,793
चाहे मैं हल करूँ यह मिनमायज़ेशन प्रॉब्लम जिसमें वन ओवर m है सामने या नहीं,

145
00:10:00,793 --> 00:10:04,750
मुझे मिलनी चाहिए वही ओप्टिमम वैल्यू थीटा की.

146
00:10:04,750 --> 00:10:05,740
मेरा मतलब ऐसे है,

147
00:10:05,740 --> 00:10:10,380
आपको एक उदाहरण देने के लिए, मान लो मेरे पास थी एक मिनमायज़ेशन प्रॉब्लम.

148
00:10:10,380 --> 00:10:18,340
मिनमायज़ करें एक नम्बर U ऑफ़ U माइनस पाँच स्क्वेर्ड प्लस वन.

149
00:10:18,340 --> 00:10:22,110
ठीक, मिनिमम इसका होता है U बराबर पाँच.

150
00:10:23,130 --> 00:10:28,500
अब यदि मुझे लेना होता यह अब्जेक्टिव फ़ंक्शन और गुणा करना होता इसे 10 से.

151
00:10:28,500 --> 00:10:36,050
तो यहाँ मेरी मिनमायज़ेशन प्रॉब्लम हैं मिन U, 10 (U - 5)स्क्वेर्ड +10.

152
00:10:36,050 --> 00:10:40,910
ठीक है, वैल्यू U की जो मिनमायज़ करती है इसे अभी भी है U बराबर पाँच, सही?

153
00:10:40,910 --> 00:10:45,190
तो गुणा करने से किसी चीज़ को जिस पर आप मिनमायज़ कर रहे हैं, किसी कॉन्स्टंट से,

154
00:10:45,190 --> 00:10:50,470
इस केस में 10 से, यह नहीं बदलता है वैल्यू U की जो देता है हमें,

155
00:10:50,470 --> 00:10:52,650
जो मिनमायज़ करता हैं इस फ़ंक्शन को.

156
00:10:52,650 --> 00:10:56,350
तो उसी प्रकार, मैंने क्या किया है कि निकाल देने से m

157
00:10:56,350 --> 00:11:01,080
मैं सिर्फ़ क्या कर रहा हूँ कि गुणा कर रहा हूँ मेरे अब्जेक्टिव फ़ंक्शन को किसी कॉन्स्टंट m से और

158
00:11:01,080 --> 00:11:03,350
उससे नहीं बदलती थीटा की वैल्यू.

159
00:11:03,350 --> 00:11:05,470
उससे प्राप्त होता है मिनिमम.

160
00:11:05,470 --> 00:11:09,170
दूसरा परिवर्तन नोटेशन का, जो है सिर्फ़, फिर से, अधिक स्टैंडर्ड

161
00:11:09,170 --> 00:11:14,250
कन्वेन्शन जब इस्तेमाल करे रहे हैं SVM, बजाय लॉजिस्टिक रेग्रेशन, है इस प्रकार.

162
00:11:14,250 --> 00:11:19,370
लॉजिसिटिक रेग्रेशन के लिए, हम जोड़ते हैं दो टर्म्ज़ अब्जेक्टिव फ़ंक्शन में.

163
00:11:19,370 --> 00:11:23,920
पहली है यह टर्म, जो है कॉस्ट जो आती है ट्रेनिंग सेट से और

164
00:11:23,920 --> 00:11:26,530
दूसरी है यह टर्म, जो है रेगुलराइज़ेशन टर्म.

165
00:11:27,540 --> 00:11:32,710
और हमारे पास क्या था, हमारे पास था A, हम नियंत्रित करते हैं ट्रेड ऑफ़ इन दोनो के बीच इस तरह कि

166
00:11:32,710 --> 00:11:39,370
हमें क्या चाहिए है A प्लस और फिर मेरा रेगुलराइज़ेशन पेरामिटर लैम्डा.

167
00:11:39,370 --> 00:11:44,950
और फिर आती है कोई दूसरी टर्म B, जहाँ मुझे लगता है मैं ले रहा हूँ A डिनोट करने के लिए

168
00:11:44,950 --> 00:11:50,080
यह पहली टर्म, और मैं ले रहा हूँ B डिनोट करने के लिए दूसरी टर्म, शायद लैम्डा के बिना.

169
00:11:51,130 --> 00:11:57,330
और बजाय प्राथमिकता देने के इसे A प्लस लैम्डा B,

170
00:11:57,330 --> 00:12:00,880
और इसलिए हमने क्या किया था कि सेट करने से भिन्न वैल्यूज़

171
00:12:00,880 --> 00:12:05,010
इस रेगुलराइज़ेशन पेरामिटर लैम्डा की, हम कर पाए ट्रेड-ऑफ़ वेट के अनुपात में

172
00:12:05,010 --> 00:12:09,273
दोनो के बीच कि कितना हमें चाहिए ट्रेनिंग सेट, वह है, मिनमायज़ करना A को,

173
00:12:09,273 --> 00:12:13,630
और कितनी छोटी हमें रखनी हैं पेरमिटर्स की वैल्यूज़, तो

174
00:12:13,630 --> 00:12:17,230
वह होगा, पेरामिटर है B सपोर्ट वेक्टर मशीन के लिए,

175
00:12:17,230 --> 00:12:20,300
कन्वेन्शन से, हम इस्तेमाल करेंगे एक भिन्न पेरामिटर.

176
00:12:20,300 --> 00:12:25,200
तो बजाय इस्तेमाल करने के लैम्डा यहाँ, नियंत्रित करने के लिए अनुपात वेट्स का पहली और

177
00:12:25,200 --> 00:12:26,160
दूसरी टर्म्ज़ में.

178
00:12:26,160 --> 00:12:31,530
हम इसके स्थान पर लेंगें एक भिन्न पेरामिटर जिसे कन्वेन्शन से कहते हैं C

179
00:12:31,530 --> 00:12:37,550
और इसे सेट करते हैं C * A + B.

180
00:12:37,550 --> 00:12:43,260
तो लॉजिस्टिक रेग्रेशन के लिए, यदि हम सेट करते हैं एक बड़ी वैल्यू लैम्डा की,

181
00:12:43,260 --> 00:12:46,040
उसका मतलब होगा आप देंगे B को एक अधिक वेट.

182
00:12:46,040 --> 00:12:49,762
यहाँ है यदि हम सेट करते हैं C को एक बहुत छोटी वैल्यू,

183
00:12:49,762 --> 00:12:54,600
तब वह कॉरेस्पॉंड करता है देने से B को बहुत बड़ा वेट C की अपेक्षा, A की अपेक्षा.

184
00:12:54,600 --> 00:12:58,070
तो यह है सिर्फ़ एक भिन्न ढंग नियंत्रित करने का ट्रेड-ऑफ़, यह है सिर्फ़

185
00:12:58,070 --> 00:13:02,450
भिन्न ढंग प्राथमिकता देने के लिए कि कितना ऑप्टिमायज़ करना है पहली टर्म को,

186
00:13:02,450 --> 00:13:05,650
या कितना ऑप्टिमायज़ करना है दूसरी टर्म को.

187
00:13:05,650 --> 00:13:10,050
और यदि आप चाहें आप सोच सकते हैं इसे पेरामिटर C जैसे

188
00:13:10,050 --> 00:13:13,551
जो अदा करता है समान भूमिका जैसे 1 ओवर लैम्डा की.

189
00:13:13,551 --> 00:13:18,429
और ऐसा नहीं है कि ये दो इक्वेज़न या ये दो इक्स्प्रेशन होंगे बराबर.

190
00:13:18,429 --> 00:13:20,736
यह होगा बराबर 1 ओवर लैम्डा के, वह केस नहीं है.

191
00:13:20,736 --> 00:13:25,511
बल्कि यह है कि यदि C बराबर है 1 ओवर लैम्डा, तब ये दो ऑप्टिमायज़ेशन

192
00:13:25,511 --> 00:13:30,211
अब्जेक्टिव्स देने चाहिए आपको समान वैल्यू, वही वैल्यू थीटा के लिए तो

193
00:13:30,211 --> 00:13:33,810
हम सिर्फ़ डालते हैं उसे यहाँ, मैं क्रॉस करता हूँ लैम्डा यहाँ और

194
00:13:33,810 --> 00:13:35,740
लिखता हूँ कॉन्स्टंट C वहाँ.

195
00:13:37,290 --> 00:13:41,598
तो वह देता है हमें हमारा पूरा ऑप्टिमायज़ेशन अब्जेक्टिव फ़ंक्शन

196
00:13:41,598 --> 00:13:43,564
सपोर्ट वेक्टर मशीन के लिए.

197
00:13:43,564 --> 00:13:45,948
और यदि आप न्यूनतम / मिनमायज़ करते हैं उस फ़ंक्शन को,

198
00:13:45,948 --> 00:13:49,690
तब आपके पास हैं पेरमिटर्स लर्न किए गए SVM से.

199
00:13:51,966 --> 00:13:56,748
अंत में, लॉजिस्टिक रेग्रेशन के विपरीत, सपोर्ट वेक्टर मशीन आउट्पुट नहीं करती

200
00:13:56,748 --> 00:14:00,570
प्रॉबबिलिटी कि हमारे पास क्या है हमारे पास है यह कॉस्ट फ़ंक्शन,

201
00:14:00,570 --> 00:14:05,213
जिसे हम मिनमायज़ करते हैं पाने के लिए पेरमिटर्स थीटा, और एक सपोर्ट वेक्टर मशीन क्या

202
00:14:05,213 --> 00:14:09,650
करती है यह सिर्फ़ करती है प्रिडिक्शन कि y है एक या ज़ीरो.

203
00:14:09,650 --> 00:14:12,350
तो हायपॉथिसस प्रिडिक्ट करेगी एक

204
00:14:13,400 --> 00:14:17,670
यदि थीटा ट्रान्स्पोज़ x है बड़ा या बराबर ज़ीरो के, और

205
00:14:17,670 --> 00:14:22,690
यह प्रिडिक्ट करेगी ज़ीरो अन्यथा, और इसलिए लर्न कर लेने से पेरामिटर्स थीटा,

206
00:14:22,690 --> 00:14:26,850
यह है फ़ॉर्म हायपॉथिसस की सपोर्ट वेक्टर मशीन के लिए.

207
00:14:26,850 --> 00:14:31,730
तो वह थी एक गणितीय परिभाषा कि सपोर्ट वेक्टर मशीन क्या करती है.

208
00:14:31,730 --> 00:14:35,390
अगले कुछ वीडियो में, मैं आप को एक बेहतर अनुभव देने की कोशिश करूँगा कि

209
00:14:35,390 --> 00:14:37,800
क्या उद्देश्य है इस ऑप्टिमायज़ेशन अब्जेक्टिव का और

210
00:14:37,800 --> 00:14:42,530
क्या यह हायपॉथिसस SVM की, लर्न करेगी और हम बात करेंगे

211
00:14:42,530 --> 00:14:46,870
इसे थोड़ा बदलने की भी जटिल नॉन-लिनीअर फ़ंक्शन्स के लिए.