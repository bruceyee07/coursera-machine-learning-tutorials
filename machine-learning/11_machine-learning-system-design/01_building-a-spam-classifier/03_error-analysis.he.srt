1
00:00:00,220 --> 00:00:04,610
בסרטון האחרון דיברתי על איך, כאשר מתמודדים עם בעיה של למידת מכונה,

2
00:00:04,610 --> 00:00:08,320
יש הרבה רעיונות שונים איך לשפר את האלגוריתם.

3
00:00:08,320 --> 00:00:12,280
בסרטון הזה, בואו נדבר על הרעיון של ניתוח שגיאות.

4
00:00:12,280 --> 00:00:15,293
כשבתקווה זה ייתן לכם דרך יותר שיטתית לעשות כמה

5
00:00:15,293 --> 00:00:16,120
מההחלטות האלה.

6
00:00:17,530 --> 00:00:21,030
אם אתה מתחיל לעבוד על בעיה בלמידה חישובית,

7
00:00:21,030 --> 00:00:22,705
או בונה אפליקציה ללמידה חישובית.

8
00:00:22,705 --> 00:00:26,600
בדרך כלל זה יהיה רעיון טוב מאוד לא להתחיל

9
00:00:26,600 --> 00:00:31,460
בבניית מערכת מסובכת מאוד עם המון תכונות מורכבות וכן הלאה.

10
00:00:31,460 --> 00:00:35,560
אלא במקום זה להתחיל על ידי בנייה של אלגוריתם פשוט מאוד

11
00:00:35,560 --> 00:00:37,220
שאפשר ליישם אותו במהירות.

12
00:00:37,220 --> 00:00:40,930
וכאשר אני מתחיל עם בעייה של למידה חישובית מה שאני עושה בדרך כלל

13
00:00:40,930 --> 00:00:41,930
הוא לבלות לכל היותר יום אחד,

14
00:00:41,930 --> 00:00:46,990
ממש לכל היותר 24 שעות, כדי לנסות לבנות משהו ממש מהיר ומכוער.

15
00:00:46,990 --> 00:00:50,520
ברצינות ממש לא מערכת מתוחכמת אלא לבנות משהו ממש מהיר

16
00:00:50,520 --> 00:00:55,920
ומלוכלך ועובד, ליישם אותו ואז לבדוק אותו על נתוני האימות הצולב.

17
00:00:55,920 --> 00:00:59,424
אחרי שעושים את זה אפשר לשרטט עקומות למידה,

18
00:00:59,424 --> 00:01:02,940
הדבר הזה שדיברנו עליו בקבוצה הקודמת של קטעי וידאו.

19
00:01:02,940 --> 00:01:05,368
שרטוט של עקומת למידה של שגיאות אימון, אימות

20
00:01:05,368 --> 00:01:09,962
ומבחן ולנסות להבין אם האלגוריתם סובל אולי

21
00:01:09,962 --> 00:01:13,160
מהטיה גבוהה או משונות גבוהה או ממשהו.

22
00:01:13,160 --> 00:01:16,100
ולהשתמש בזה כדי לנסות להחליט אם הוספת נתונים,

23
00:01:16,100 --> 00:01:18,700
או תכונות נוספות, וכן הלאה עשויים לעזור.

24
00:01:18,700 --> 00:01:22,440
והסיבה לכך שזוהי גישה טובה היא כי הרבה פעמים כשאתה מתחיל

25
00:01:22,440 --> 00:01:26,490
לעבוד על בעיה בלמידה חישובית, אין באמת שום דרך לדעת מראש

26
00:01:26,490 --> 00:01:29,990
האם אתה תצטרך תכונות מורכבות יותר, או אולי אתה זקוק לעוד נתונים,

27
00:01:29,990 --> 00:01:31,310
או משהו אחר.

28
00:01:31,310 --> 00:01:33,910
וקשה מאוד לדעת את זה מראש

29
00:01:33,910 --> 00:01:38,795
בהעדר ראיות, כלומר - לפני שראינו עקומת למידה.

30
00:01:38,795 --> 00:01:41,380
זה פשוט קשה מאוד להחליט

31
00:01:41,380 --> 00:01:43,770
במה כדאי להשקיע את הזמן שלך.

32
00:01:43,770 --> 00:01:47,730
ולעתים קרובות על ידי יישום, אפילו יישום מאוד מאוד מהיר ומלוכלך

33
00:01:47,730 --> 00:01:52,400
ועל ידי שרטוט של עקומות למידה, זה מה שיעזור לך לקבל את ההחלטות האלה.

34
00:01:52,400 --> 00:01:56,789
אז אם תרצה אתה יכול לחשוב על זה כעל דרך להימנע ממה שמכונה לעתים

35
00:01:56,789 --> 00:01:59,730
אופטימיזציה מוקדמת מדי בתכנות מחשבים.

36
00:01:59,730 --> 00:02:05,037
והרעיון הזה אומר שאנחנו צריכים לתת לראיות לכוון את ההחלטות שלנו

37
00:02:05,037 --> 00:02:10,980
בקשר לאיפה כדאי להשקיע את הזמן שלנו ולא להשתמש בתחושות בטן,
שהן לעתים קרובות שגויות.

38
00:02:10,980 --> 00:02:13,070
בנוסף לשרטוט של עקומות למידה,

39
00:02:13,070 --> 00:02:18,080
יש עוד דבר אחד שהוא מאוד שימושי במקרים רבים והוא מה שנקרא ניתוח שגיאות.

40
00:02:18,080 --> 00:02:21,940
ומה שאני מתכוון הוא שכאשר אנחנו בונים נניח מסווג של דואר זבל

41
00:02:21,940 --> 00:02:25,684
אני הרבה פעמים מסתכל על סדרת האימות הצולב שלי

42
00:02:25,684 --> 00:02:31,170
ממש בעין, מסתכל על אותן הודעות דוא"ל שבהם האלגוריתם שלי שגה.

43
00:02:31,170 --> 00:02:33,000
כדאי להסתכל על דוא"ל

44
00:02:33,000 --> 00:02:37,850
שהוא דואר זבל ועל דוא"ל שאינו דואר זבל שאותם האלגוריתם סיווג לא נכון,

45
00:02:37,850 --> 00:02:43,000
ולראות אם אתה מצליח לזהות איזה היגיון בשיגעון -
באיזה סוג של דוגמאות הוא מסווג לא נכון.

46
00:02:43,000 --> 00:02:44,833
ולעתים קרובות

47
00:02:44,833 --> 00:02:49,230
הדבר הזה יכוון אותך לעיצוב של תכונות חדשות.

48
00:02:49,230 --> 00:02:51,897
או שהם יגלו מהם הדברים הנוכחיים

49
00:02:51,897 --> 00:02:53,940
או החסרונות הנוכחיים של המערכת.

50
00:02:53,940 --> 00:02:58,620
ויתנו לך את ההשראה שחסרה לך כדי למצוא לה שיפורים.

51
00:02:58,620 --> 00:03:01,350
באופן קונקרטי, הנה דוגמה ספציפית.

52
00:03:01,350 --> 00:03:05,770
נניח שבנית מסווג דואר זבל

53
00:03:05,770 --> 00:03:09,690
ויש לך 500 דוגמאות בקבוצת האימות הצולב שלך.

54
00:03:09,690 --> 00:03:13,690
ונניח בדוגמה זו שלאלגוריתם יש שיעור שגיאה גבוה מאוד.

55
00:03:13,690 --> 00:03:17,810
והוא מסווג בטעות 100 מתוך דוגמאות האימות הצולב האלה.

56
00:03:18,810 --> 00:03:24,490
אז מה שאני עושה הוא לבדוק באופן ידני את 100 השגיאות
ומסווג אותם באופן ידני.

57
00:03:24,490 --> 00:03:28,010
בהסתמך על דברים כמו איזה סוג של אימייל זה, אילו מאפיינים

58
00:03:28,010 --> 00:03:32,470
או תכונות אתה חושב שאולי היו עוזרים לאלגוריתם לסווג אותם כראוי.

59
00:03:32,470 --> 00:03:38,469
באופן ספציפי, לפי סוג הדואר האלקטרוני,
אם אני מסתכל על כל ה-100 שגיאות האלה,

60
00:03:38,469 --> 00:03:43,007
אני עשוי לגלות שאולי הסוגים הנפוצים ביותר של הודעות דואר זבל

61
00:03:43,007 --> 00:03:48,910
שהמסווג טעה בהם הם אולי הודעות דוא"ל על תרופות או בתי מרקחת,
הודעות שמנסות למכור חומרים.

62
00:03:48,910 --> 00:03:53,080
או אולי מיילים שמנסים למכור זיופים שונים כגון שעונים מזויפים,

63
00:03:53,080 --> 00:04:00,340
כל מיני דברים מזויפים, ואולי הודעות דוא"ל שמנסות לגנוב סיסמאות.

64
00:04:00,340 --> 00:04:04,693
הסוג הזה נקרא גם הודעות דוא"ל מתחזות, זו עוד קטגוריה גדולה של הודעות דוא"ל,

65
00:04:04,693 --> 00:04:06,030
ואולי קטגוריות אחרות.

66
00:04:06,030 --> 00:04:09,249
אז במטרה לסווג את ההודעות האלה של דואר אלקטרוני,

67
00:04:09,249 --> 00:04:14,030
הייתי ממש עובר וממיין את מאה ההודעות האלה.

68
00:04:14,030 --> 00:04:19,460
אולי אני אגלה ש-12 מהם הן הודעות דוא"ל של תרופות, או בית מרקחת וירטואלי,

69
00:04:19,460 --> 00:04:23,700
ואולי 4 מהם הם נסיונות למכור עותקים משוכפלים כמו שעונים מזויפים או משהו כזה.

70
00:04:23,700 --> 00:04:29,000
ואולי אני אגלה ש-53 מהם הן מה שנקרא התחזות או פישינג,

71
00:04:29,000 --> 00:04:32,660
הודעות דוא"ל שמנסות לשכנע אותך לגלות להם את הסיסמה שלך.

72
00:04:32,660 --> 00:04:35,330
ו-31 הודעות דוא"ל הם סוגים אחרים של הודעות דוא"ל.

73
00:04:35,330 --> 00:04:37,860
ועל ידי הספירה של מספר

74
00:04:37,860 --> 00:04:41,370
הודעות הדוא"ל בכל אחת מהקטגוריות השונות האלה, שאתה עשוי לגלות, למשל,

75
00:04:41,370 --> 00:04:43,015
שהאלגוריתם הוא באמת

76
00:04:43,015 --> 00:04:47,170
גרוע במיוחד על הודעות דוא"ל שמנסות לגנוב סיסמאות.

77
00:04:47,170 --> 00:04:50,310
מה שעשוי להציע לך שזה עשוי להיות שווה להשקיע

78
00:04:50,310 --> 00:04:53,120
ולהסתכל יותר בעיון על הסוג הזה של דוא"ל

79
00:04:53,120 --> 00:04:56,540
ולראות אם יש לך רעיון לתכונות טובות יותר כדי לסווג אותם כראוי.

80
00:04:57,550 --> 00:05:01,100
מה שאני עוד יכול לעשות הוא להסתכל על אילו רמזים

81
00:05:01,100 --> 00:05:05,830
או אילו תכונות נוספות אולי תעזורנה לאלגוריתם לסווג את הודעות הדוא"ל האלה בצורה נכונה.

82
00:05:05,830 --> 00:05:09,830
נניח שחלק מההשערות שלנו לגבי דברים

83
00:05:09,830 --> 00:05:13,280
או תכונות שעשויים לעזור לנו לסווג הודעות דוא"ל בצורה טובה יותר

84
00:05:13,280 --> 00:05:17,751
מנסות לזהות שגיאות כתיב מכוונות, או ניתוב דואר יוצא דופן

85
00:05:17,751 --> 00:05:21,150
או סימני פיסוק חריגים.

86
00:05:21,150 --> 00:05:23,700
כגון אם אנשים משתמשים בהרבה סימני קריאה.

87
00:05:23,700 --> 00:05:28,885
ושוב הייתי עובר ידנית ונניח שאני מוצא חמישה מקרים של זה

88
00:05:28,885 --> 00:05:34,760
ו-16 של זה ו-32 של זה וחוץ מזה עוד קבוצה של סוגים אחרים של הודעות.

89
00:05:34,760 --> 00:05:39,550
אם זה מה שאתה מקבל על קבוצת האימות הצולב שלך, אז זה בעצם אומר לך

90
00:05:39,550 --> 00:05:43,906
שאולי שגיאות איות מכוונות הן תופעה נדירה למדי,

91
00:05:43,906 --> 00:05:49,530
ואולי לא שווה לך לכתוב אלגוריתמים לזהות את זה.

92
00:05:49,530 --> 00:05:54,320
אבל אם אתה מגלה שהרבה שולחי דואר זבל משתמשים בפיסוק יוצא דופן,

93
00:05:54,320 --> 00:05:58,760
אז אולי זה סימן חזק שזה באמת כן עשוי להיות משתלם לך

94
00:05:58,760 --> 00:06:03,350
להשקיע את הזמן לפתח תכונות מתוחכמות יותר המבוססות על פיסוק.

95
00:06:03,350 --> 00:06:07,580
אז סוג כזה של ניתוח שגיאות, שהוא בעצם תהליך

96
00:06:07,580 --> 00:06:11,560
בדיקה ידנית של השגיאות של האלגוריתם,

97
00:06:11,560 --> 00:06:16,000
יכול הרבה פעמים לעזור להנחות אותך לכיוונים הכי מבטיחים להמשיך בהם.

98
00:06:16,000 --> 00:06:19,738
וזה גם מסביר מדוע אני בדרך כלל ממליץ לבנות יישום מהיר

99
00:06:19,738 --> 00:06:21,940
ומכוער של אלגוריתם.

100
00:06:21,940 --> 00:06:26,210
מה שאנחנו באמת רוצים לעשות הוא להבין מהן הדוגמאות הקשות ביותר

101
00:06:26,210 --> 00:06:27,730
עבור אלגוריתם לסווג.

102
00:06:27,730 --> 00:06:32,502
בהמון מקרים, לאלגוריתמים שונים, לאלגוריתמי למידה שונים

103
00:06:32,502 --> 00:06:37,000
לעתים קרובות מאוד יהיו קשיים בסיווג של אותן קטגוריות.

104
00:06:37,000 --> 00:06:38,100
ובניית יישום מהיר

105
00:06:38,100 --> 00:06:42,940
ומלוכלך היא בדרך כלל דרך מהירה לעזור לך לזהות את השגיאות

106
00:06:42,940 --> 00:06:45,970
ולזהות במהירות מהן הדוגמאות הקשות לאלגוריתם.

107
00:06:45,970 --> 00:06:48,160
ואז תוכל למקד את המאמצים שלך בדוגמאות האלה.

108
00:06:49,240 --> 00:06:54,280
עוד עניין, כאשר מפתחים אלגוריתמים של למידה, טיפ שימושי נוסף הוא

109
00:06:54,280 --> 00:07:00,150
לוודא שיש לך הערכה כמותית או מספרית של אלגוריתם הלמידה שלך.

110
00:07:01,915 --> 00:07:05,560
מה שאני מתכוון זה שאם אתה מפתח אלגוריתם למידה,

111
00:07:05,560 --> 00:07:08,090
זה יהיה בדרך כלל מאוד מועיל

112
00:07:08,090 --> 00:07:11,300
אם יש לך דרך מספרית ולא רק איכותית להעריך את אלגוריתם הלמידה שלך,

113
00:07:11,300 --> 00:07:15,670
משהו שנותן לך מספר ממשי אחד, רמת הדיוק, או אולי רמת השגיאה.

114
00:07:15,670 --> 00:07:20,330
אבל מספר ממשי אחד שאומר לך עד כמה טוב אלגוריתם הלמידה שלך.

115
00:07:20,330 --> 00:07:23,870
אני אדבר יותר על הרעיון הספציפי הזה בסרטונים מאוחרים יותר, אבל

116
00:07:23,870 --> 00:07:25,810
הנה דוגמה ספציפית.

117
00:07:25,810 --> 00:07:29,127
נניח שאנחנו מנסים להחליט אם אנחנו צריכים לטפל במילים כמו

118
00:07:29,127 --> 00:07:32,320
הנחה, הנחות, בהנחה, ההנחה כמילה אחת או לא.

119
00:07:32,320 --> 00:07:36,420
אז אולי אתם יודעים שאחת הדרכים לעשות זאת היא להסתכל

120
00:07:37,630 --> 00:07:39,680
רק על אותיות השורש של המילה,

121
00:07:39,680 --> 00:07:43,250
אם אתה מסתכל רק על אותיות השורש של מילה, אז אתה

122
00:07:44,600 --> 00:07:48,640
מבין שאולי בעצם לכל המילים האלה יש בערך משמעות דומה.

123
00:07:50,500 --> 00:07:54,585
בעיבוד שפה טבעית, האופן שבו זה נעשה הוא בעצם באמצעות סוג

124
00:07:54,585 --> 00:07:56,610
של תוכנה הנקראת תוכנת שורשים.

125
00:07:56,610 --> 00:08:00,462
ואם אתם רוצים לממש את זה בעצמכם, התחילו בחיפוש במנוע חיפוש באינטרנט

126
00:08:00,462 --> 00:08:04,314
את Porter Stemmer, זוהי תוכנה די סבירה

127
00:08:04,314 --> 00:08:07,984
שעושה את זה ומוצאת שורשים, מה שיאפשר לכם לטפל בכל המילים האלה,

128
00:08:07,984 --> 00:08:10,760
הנחה, הנחות , וכן הלאה, כמילה אחת.

129
00:08:13,990 --> 00:08:18,610
אבל שימוש בתוכנת שורשים שבעצם מסתכל רק על חלק

130
00:08:18,610 --> 00:08:22,260
מהאותיות של מילה פחות או יותר, זה יכול לעזור אבל זה יכול גם להזיק.

131
00:08:22,260 --> 00:08:25,920
זה יכול להזיק כי למשל, התוכנה עלולה לטעות

132
00:08:25,920 --> 00:08:30,670
ולחשוב ש"כדור" ו"דורה" הם בעלי אותו שורש ולכן אותה מילה.

133
00:08:30,670 --> 00:08:34,900
כי לשתי המילים האלה יש אותן אותיות שורש.

134
00:08:37,320 --> 00:08:42,642
אז כשאתם מנסים להחליט אם להשתמש בתוכנת שורשים כזו

135
00:08:42,642 --> 00:08:46,360
עבור מסווג דואר זבל, זה לא תמיד קל לדעת.

136
00:08:46,360 --> 00:08:51,190
ובמיוחד, ניתוח שגיאות עשוי לא להועיל באמת

137
00:08:51,190 --> 00:08:55,610
בהחלטה האם סוג כזה של רעיון הוא רעיון טוב.

138
00:08:55,610 --> 00:09:00,129
וזו דוגמה לסיבה בגללה הדרך הטובה ביותר להבין האם תוכנת שורשים כזו

139
00:09:00,129 --> 00:09:04,424
אכן תסייע לסיווג שלכם היא לבנות תוכנת סיווג שלדית ומהירה ואז פשוט

140
00:09:04,424 --> 00:09:05,480
לנסות את זה מהר מאוד ולראות אם זה עובד.

141
00:09:08,400 --> 00:09:09,903
וכדי לעשות זאת,

142
00:09:09,903 --> 00:09:15,990
דרך להעריך באופן מספרי את האלגוריתם שלך תהיה מאוד מועילה.

143
00:09:15,990 --> 00:09:20,980
באופן קונקרטי, אולי הדבר הטבעי ביותר לעשות הוא להסתכל על שגיאת האימות הצולב

144
00:09:20,980 --> 00:09:24,690
של ביצועי האלגוריתם עם השוואת שורשים ובלעדיה.

145
00:09:24,690 --> 00:09:27,250
אז אם אתה מפעיל את האלגוריתם שלך בלי שורשים

146
00:09:27,250 --> 00:09:31,250
ומקבל שגיאת סיווג של 5 אחוזים.

147
00:09:31,250 --> 00:09:32,670
ואז אתה מריץ אותו שוב עם שורשים

148
00:09:32,670 --> 00:09:37,700
ואתה מקבל שגיאת סיווג של רק 3 אחוזים, אז הירידה בשגיאה

149
00:09:37,700 --> 00:09:43,140
מאפשרת לך להחליט בקלות שזה נראה כאילו השורשים זה רעיון טוב.

150
00:09:43,140 --> 00:09:46,570
עבור הבעיה הזו ספציפית יש הערכה מספרית

151
00:09:46,570 --> 00:09:50,960
מאוד טבעית, יחידה ומדויקת, שהיא שגיאת האימות הצולב.

152
00:09:50,960 --> 00:09:54,790
אנו נראה יותר מאוחר דוגמאות שבהם להגיע לסוג זה של ערך מספרי בודד,

153
00:09:54,790 --> 00:09:58,840
הערכה אמיתית, נצטרך לעבוד יותר קשה.

154
00:09:58,840 --> 00:10:03,230
אבל כפי שנראה בסרטון מאוחר יותר, זה גם יאפשר לנו

155
00:10:03,230 --> 00:10:06,660
לקבל החלטות כאלה הרבה יותר מהר, כגון אם להשתמש בשורשים או לא.

156
00:10:08,180 --> 00:10:13,010
ורק כעוד דוגמה קצרה אחת, נניח שאתה גם מנסה להחליט

157
00:10:13,010 --> 00:10:15,970
אם להבחין בין כתיב מלא וכתיב חסר, או לא.

158
00:10:15,970 --> 00:10:20,480
לדוגמא, כמו המילה אמא בכתיב חסר, לעומת אימא בכתיב מלא,

159
00:10:20,480 --> 00:10:24,090
האם זה יטופל כאותה מילה או כשתי מילים שונות?

160
00:10:24,090 --> 00:10:26,609
האם יש להתייחס אליהן כאל תכונה זהה, או כתכונות שונות?

161
00:10:27,610 --> 00:10:31,110
אז שוב, מכיוון שיש לנו דרך להעריך את האלגוריתם שלנו.

162
00:10:31,110 --> 00:10:35,300
אם ננסה את זה כאן, אם אני לא מבדיל בין כתיב מלא וחסר,

163
00:10:35,300 --> 00:10:39,280
אולי אני מקבל 3.2 אחוזים של שגיאה.

164
00:10:39,280 --> 00:10:44,270
זאת אומרת שאני מוצא שזה יותר גרוע מאשר אם אני רק משתמש בשורשים.

165
00:10:44,270 --> 00:10:48,850
אז זה גורם לי להחליט מייד

166
00:10:48,850 --> 00:10:52,190
שכדאי לי דווקא כן להבחין בין כתיב מלא וחסר.

167
00:10:52,190 --> 00:10:56,590
כשאתה מפתח אלגוריתם למידה, לעתים קרובות אתה מנסה

168
00:10:56,590 --> 00:11:00,990
הרבה רעיונות חדשים והרבה גרסאות חדשות של אלגוריתם הלמידה שלך.

169
00:11:00,990 --> 00:11:04,370
אם בכל פעם שאתה מנסה רעיון חדש, אם בסופו של דבר

170
00:11:04,370 --> 00:11:07,810
אתה בודק קבוצה של דוגמאות שוב ושוב כדי לראות אם זה השתפר או הורע,

171
00:11:07,810 --> 00:11:11,530
זה יהיה לך די קשה לקבל החלטות.

172
00:11:11,530 --> 00:11:12,630
האם אתה משתמש בשורשים או לא?

173
00:11:12,630 --> 00:11:15,220
האם אתה מבדיל בין כתיב מלא וחסר או לא?

174
00:11:15,220 --> 00:11:18,470
אבל אם יש לך ערך מספרי ממשי שנותן לך הערכה אמיתית,

175
00:11:18,470 --> 00:11:21,850
אז אתה יכול פשוט להסתכל ולראות, האם הסמן שלך עלה או ירד?

176
00:11:21,850 --> 00:11:27,430
ואתה יכול להשתמש במספר הזה כדי לנסות רעיונות חדשים מהר יותר

177
00:11:27,430 --> 00:11:31,370
ולדעת כמעט מיד אם הרעיון החדש שלך שיפר

178
00:11:31,370 --> 00:11:34,100
או הרע את הביצועים של אלגוריתם הלמידה.

179
00:11:34,100 --> 00:11:38,190
וזה יאפשר לך בדרך כלל התקדמות מהירה יותר.

180
00:11:38,190 --> 00:11:42,410
אז הדרך המומלצת, הממש מומלצת בחום לעשות ניתוח שגיאה

181
00:11:42,410 --> 00:11:45,530
הוא על סדרת האימות הצולב ולא על סדרת המבחן.

182
00:11:45,530 --> 00:11:49,500
אבל יש אנשים שכן יעשו את זה על סדרת המבחן, למרות

183
00:11:49,500 --> 00:11:54,590
שמתמטית זה דבר שבהחלט פחות מתאים ובהחלט פחות מומלץ לעשות,

184
00:11:54,590 --> 00:11:58,640
מאשר לעשות ניתוח שגיאות על סדרת האימות הצולב.

185
00:11:58,640 --> 00:12:03,390
אז כדי לסכם את הוידאו הזה, כאשר מתחילים לעבוד על בעיה חדשה בלמידה ממוחשבת,

186
00:12:03,390 --> 00:12:07,070
מה שאני כמעט תמיד ממליץ לעשות הוא לכתוב יישום

187
00:12:07,070 --> 00:12:10,120
מהיר ומכוער של אלגוריתם הלמידה.

188
00:12:10,120 --> 00:12:15,170
ואני כמעט אף פעם לא ראיתי מישהו שבילה פחות מדי זמן

189
00:12:15,170 --> 00:12:16,500
על היישום המהיר והמלוכלך הזה.

190
00:12:16,500 --> 00:12:22,420
בדרך כלל אני רואה אנשים שמבלים הרבה יותר מדי זמן

191
00:12:22,420 --> 00:12:26,550
בבניית היישום המהיר והמלוכלך הראשון הזה שלהם.

192
00:12:26,550 --> 00:12:29,810
אז באמת, אל תדאגו שזה נראה מהיר מדי,

193
00:12:29,810 --> 00:12:32,080
ואל תדאגו שזה מלוכלך מדי.

194
00:12:32,080 --> 00:12:35,120
מה שכדאי לעשות הוא ליישם משהו הכי מהר שתוכלו.

195
00:12:35,120 --> 00:12:37,560
ברגע שיהיה לכם את היישום הראשוני הזה,

196
00:12:37,560 --> 00:12:41,170
יש לכם כלי רב עוצמה כדי להחליט היכן להמשיך ולהשקיע את הזמן.

197
00:12:41,170 --> 00:12:43,674
כי קודם כל אתם יכולים להסתכל על השגיאות של התכנית

198
00:12:43,674 --> 00:12:46,958
ולעשות סוג של ניתוח שגיאות לראות אילו טעויות אחרות הוא עושה,

199
00:12:46,958 --> 00:12:49,500
ולהשתמש בזה כדי לכוון את המשך הפיתוח.

200
00:12:49,500 --> 00:12:51,390
ושנית, בהנחה שהיישום המהיר והמלוכלך שלכם

201
00:12:51,390 --> 00:12:55,710
מסוגל לתת הערכה מספרית אובייקטיבית אחת

202
00:12:55,710 --> 00:12:59,970
זה יכול להיות כלי בשבילכם כדי לנסות במהירות רעיונות שונים

203
00:12:59,970 --> 00:13:03,880
כדי לראות אם הרעיונות השונים שאתם מנסים משפרים את הביצועים

204
00:13:03,880 --> 00:13:04,990
של האלגוריתם שלכם.

205
00:13:04,990 --> 00:13:08,470
וכך המדד מאפשר לכם לקבל החלטות מהר יותר

206
00:13:08,470 --> 00:13:11,835
על אילו דברים לזרוק ואילו דברים לשלב באלגוריתם הלמידה שלך.