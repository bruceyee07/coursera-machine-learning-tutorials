1
00:00:00,280 --> 00:00:02,820
이제 Octave로 데이타를 어떻게 로드하고 저장하는지 알게 되었으니,

2
00:00:02,820 --> 00:00:05,100
데이터를 행렬에 넣어보는 등의 작업을 해봅시다.

3
00:00:05,100 --> 00:00:10,028
이 비디오에서는 데이터를 컴퓨터로 작업하는 방법을 설명하겠습니다.

4
00:00:10,028 --> 00:00:14,880
나중에 우리가 만들 학습 알고리즘을 구현하기 위해

5
00:00:14,880 --> 00:00:15,870
여기에서 배운 작업 소스들을 사용할 겁니다.

6
00:00:17,130 --> 00:00:17,810
이제 시작하죠.

7
00:00:19,650 --> 00:00:21,040
제 Octave 실행창이 여기 있습니다.

8
00:00:21,040 --> 00:00:25,900
우리가 배울 예제에서 사용할 변수들을 
간단히 초기설정하겠습니다.

9
00:00:25,900 --> 00:00:33,470
A는 3 x 2 행렬이라 놓고, 
B도 3 x 2 행렬로 설정합니다.

10
00:00:33,470 --> 00:00:37,855
그리고 C는 2 x 2행렬이라 합시다.

11
00:00:39,195 --> 00:00:42,235
이제 두 개의 행렬을 곱하려고 합니다.

12
00:00:42,235 --> 00:00:47,195
그래서 제가 A * C를 계산하고 싶어서, 
그냥 A * C를 입력했습니다.

13
00:00:47,195 --> 00:00:52,215
A는 3 x 2 행렬이고 B는 2 x 2 행렬이므로 
A * C는 3 x 2 행렬이 되겠죠.

14
00:00:52,215 --> 00:00:57,145
행렬의 곱셈을 각 원소에서 할 수도 있습니다. A .* B 라고 입력하면

15
00:00:57,145 --> 00:01:02,580
A의 각 원소는 각각 대응하는 B의 원소와 곱해집니다.

16
00:01:02,580 --> 00:01:06,208
이것이 A, 이것이 B, 그리고 이것이 A*B 입니다.

17
00:01:06,208 --> 00:01:11,230
가령 첫번째 원소의 경우 1 * 11 은 11 이 되고

18
00:01:11,230 --> 00:01:17,140
두번째 원소는 2 * 12 은 24 가 되고, 이런 식으로요.

19
00:01:17,140 --> 00:01:20,840
이것이 두 행렬 간의 원소 단위 곱셈입니다.

20
00:01:20,840 --> 00:01:23,200
일반적으로, Octave 에서 점(.) 은

21
00:01:23,200 --> 00:01:27,440
원소 단위의 연산을 의미합니다.

22
00:01:27,440 --> 00:01:31,494
여기 행렬 A가 있고, 만약 A.^2 를 실행하면

23
00:01:31,494 --> 00:01:36,500
A의 각 원소 값은 제곱이 됩니다.

24
00:01:36,500 --> 00:01:39,440
1의 제곱은 1, 2의 제곱은 4, 이런 식이죠.

25
00:01:41,100 --> 00:01:42,560
이제 벡터 v를 하나 생성합시다.

26
00:01:42,560 --> 00:01:46,230
v에 1,2,3 을 주어 열 벡터를 생성합니다.

27
00:01:46,230 --> 00:01:52,010
또한 1 ./ v 라고 쓰면 v의 각 원소를 
역수로 만든 벡터를 얻을 수 있습니다.

28
00:01:52,010 --> 00:01:56,040
즉 1/1, 1/2, 1/3 가 됩니다. 이걸 행렬에 적용해

29
00:01:56,040 --> 00:02:00,610
1 ./ A 를 실행하면 A의 각 원소의 역수가 구해집니다.

30
00:02:02,760 --> 00:02:08,173
다시 말해, 점(.)은 원소 단위로 연산을 실행합니다.

31
00:02:08,173 --> 00:02:15,080
log(v) 를 실행하면, v의 
각 원소 단위 로그값을 계산합니다.

32
00:02:15,080 --> 00:02:20,300
exp(v)는 밑이 e(오일러의 수)이고 
v의 원소로 각각 거듭제곱한 값을 계산합니다.

33
00:02:20,300 --> 00:02:25,600
그래서 e의 1승, e의 2승, e의 3승이 됩니다. 
왜냐하면 원래 v값이 1 2 3이었으니까요.

34
00:02:25,600 --> 00:02:31,040
또한, abs(v)는 v의 원소 단위 절대값을 구할 수 있습니다.

35
00:02:31,040 --> 00:02:36,660
v는 원래 양수였으니까,
 abs([-1; 2;-3]) 를 입력하면

36
00:02:36,660 --> 00:02:42,973
음수값들에 대해서도 
원소 단위로 절대값이 얻어집니다.

37
00:02:42,973 --> 00:02:45,930
-v 는 v의 각 값들에 대한 음수값을 얻습니다.

38
00:02:45,930 --> 00:02:48,720
이것은 -1 * v 와 같지만,

39
00:02:48,720 --> 00:02:54,024
보통은 -1 * v 대신에 -v 를 씁니다.

40
00:02:54,024 --> 00:02:56,050
또 어떤 것들이 가능할까요?

41
00:02:56,050 --> 00:02:57,240
여기에 또다른 유용한 방법이 있습니다.

42
00:02:57,240 --> 00:02:58,360
자, 봅시다.

43
00:02:58,360 --> 00:03:01,700
v의 각 원소들을 1씩 증가한 값을
 계산하고 싶다고 합시다.

44
00:03:01,700 --> 00:03:06,590
한가지 방법은, 
모든 원소가 1인 3 X 1 행렬을 만들고,

45
00:03:06,590 --> 00:03:11,430
그것을 v에 더하는 것입니다.

46
00:03:11,430 --> 00:03:14,590
이렇게 하면, v의 값은 1,2,3 에서 2,3,4가 됩니다.

47
00:03:14,590 --> 00:03:21,520
제가 한 것은, length(v)가 3이므로,

48
00:03:21,520 --> 00:03:27,260
ones(length(v),1)는 
ones(3,1)이 되고,

49
00:03:27,260 --> 00:03:33,620
ones(3,1)은 우측에 있게 되므로,
 따라서 v + ones(3,1)

50
00:03:33,620 --> 00:03:38,950
즉 행렬 v에 ones를 더하면 
각 원소는 1씩 증가합니다

51
00:03:40,000 --> 00:03:44,190
또다른 방법으로는 
v + 1 을 실행합니다.

52
00:03:44,190 --> 00:03:45,450
즉 v 가 주어질 때,

53
00:03:45,450 --> 00:03:50,840
v + 1 이 의미하는 것은
v의 각 원소 단위로 1을 더하는 것입니다.

54
00:03:52,470 --> 00:03:55,490
이제, 다른 연산에 대해 알아봅시다.

55
00:03:55,490 --> 00:03:59,520
행렬 A가 주어질 때, 
A의 전치행렬을 구하는 방법은

56
00:03:59,520 --> 00:04:03,720
A' 라고 입력하고, 여기서 ' 는 
시작할 때 쓰는 왼쪽 작은따옴표입니다.

57
00:04:03,720 --> 00:04:08,350
키보드에 왼쪽 작은따옴표와 
오른쪽 작은따옴표가 있죠

58
00:04:08,350 --> 00:04:11,260
이게 일반적인 표기 방법입니다.

59
00:04:11,260 --> 00:04:18,330
그냥 A' 라고 치면 
A의 전치행렬을 구해줍니다.

60
00:04:18,330 --> 00:04:19,700
물론, A의 전치행렬을

61
00:04:19,700 --> 00:04:22,970
다시 전치시키면, 
원래의 행렬 A가 얻어지겠죠.

62
00:04:25,160 --> 00:04:27,570
또 다른 몇 가지 유용한 함수들이 있습니다.

63
00:04:27,570 --> 00:04:34,300
소문자 a를 1, 15, 2, 0.5 라는 
 1x4 행렬이라고 하고

64
00:04:34,300 --> 00:04:38,880
val = max(A) 라고 치면
최대값을 구해 줍니다.

65
00:04:38,880 --> 00:04:42,970
여기서는 15 이구요,

66
00:04:42,970 --> 00:04:48,430
[val, ind] = max(a) 라고 치면

67
00:04:48,430 --> 00:04:52,940
A의 최대값인 15와 
그것의 인덱스 값도 구해줍니다.

68
00:04:52,940 --> 00:04:58,790
여기서는 A의 두번째 원소이므로 
2가 인덱스 값이 됩니다.

69
00:04:58,790 --> 00:05:03,230
주의할 점은, 행렬 A에 대해 max(A)를 구할 때,

70
00:05:03,230 --> 00:05:07,920
열 단위로 최대값을 구한다는 것입니다.

71
00:05:07,920 --> 00:05:09,860
이제 다른 연산을 알아봅시다.

72
00:05:11,610 --> 00:05:14,760
지금 정의한 a를 예로 들어 설명하겠습니다.

73
00:05:14,760 --> 00:05:19,630
a < 3 를 치면,
이건 원소 단위 연산입니다.

74
00:05:19,630 --> 00:05:24,030
원소 단위로 비교해서,
a의 첫번째 원소가 3보다 작으면

75
00:05:24,030 --> 00:05:24,970
진실을 나타내는 1이 되지요.

76
00:05:24,970 --> 00:05:29,970
a의 두번째 원소는 3보다 작지 않으므로
거짓인 0이 됩니다.

77
00:05:29,970 --> 00:05:36,590
a의 3번째와 4번째 원소는 3보다 작으므로,
각각 1 1 이 됩니다.

78
00:05:36,590 --> 00:05:42,970
이것이 a < 3 에 대한 
원소 단위 비교 방법입니다.

79
00:05:42,970 --> 00:05:47,440
3보다 작은지 아닌지에 따라 
참 또는 거짓을 반환합니다.

80
00:05:47,440 --> 00:05:53,615
이제, find (a < 3)를 실행하면,
a의 원소들 중

81
00:05:53,615 --> 00:05:55,235
3보다 작은 원소들이 무엇인지 알려줍니다.

82
00:05:55,235 --> 00:05:59,545
여기서는 1번째 3번째 및 4번째 원소가 
3보다 작음을 뜻합니다.

83
00:05:59,545 --> 00:06:05,205
다음 예제로,
 A = magic(3)를 실행합니다.

84
00:06:05,205 --> 00:06:08,985
magic 함수의 결과값은, 
help magic 이라고 쳐봅시다.

85
00:06:08,985 --> 00:06:15,370
magic 함수는 
마방진 (magic squares) 행렬을 생성합니다.

86
00:06:15,370 --> 00:06:20,830
마방진의 수학적인 성질은,

87
00:06:20,830 --> 00:06:23,690
모든 행과 열, 대각선의 합계가 같다는 것입니다.

88
00:06:23,690 --> 00:06:28,830
아시다시피, 기계 학습에서는 쓸모가 없지만

89
00:06:28,830 --> 00:06:34,450
저는 이것을 3 X 3 행렬을 
간편하게 생성하는 방법으로 씁니다.

90
00:06:34,450 --> 00:06:38,788
마방진은 각 행과, 열,

91
00:06:38,788 --> 00:06:41,751
대각선의 합이 모두 같기 때문에,

92
00:06:41,751 --> 00:06:44,300
일종의 수학적인 생성 방법 중
 하나로 볼수 있습니다.

93
00:06:44,300 --> 00:06:48,820
저는 magic 함수를 설명할 때나
 octave를 가르칠 때만 사용하고

94
00:06:48,820 --> 00:06:53,760
기계 학습에서 실제로 응용할 때에는 
사실 사용하지 않습니다.

95
00:06:53,760 --> 00:06:58,886
이제 여기서 [r.c] = find (A >= 7) 이라고 치면,

96
00:06:58,886 --> 00:07:04,231
A의 모든 원소들 중 
7보다 크거나 같은 원소를 구합니다.

97
00:07:04,231 --> 00:07:07,740
r, c 는 각각 행(row), 열(column)을 뜻합니다.

98
00:07:07,740 --> 00:07:11,750
여기서는 1,1 원소와, 3,2 원소,

99
00:07:11,750 --> 00:07:13,270
2,3 원소가 7보다 큽니다.

100
00:07:13,270 --> 00:07:14,360
자, 봅시다.

101
00:07:14,360 --> 00:07:17,740
2,3 원소, 즉 A(2,3) 은

102
00:07:17,740 --> 00:07:24,270
여기 있는 7이고,
7보다 크거나 같다고 할수 있죠.

103
00:07:24,270 --> 00:07:28,820
그건 그렇고, 사실 저는 사용법을 일일이 
기억하지 않아요. 이런 find 함수가 뭘 하는지,

104
00:07:28,820 --> 00:07:30,220
이러한 것들이 다 어떤 역할을 하는지 같은거요.

105
00:07:30,220 --> 00:07:34,180
find함수를 사용하려고 할때,
정확한 사용방법이 기억나지 않으면

106
00:07:34,180 --> 00:07:38,020
help find를 쳐서 도움말을 봅니다.

107
00:07:38,020 --> 00:07:40,130
자, 이제 2가지만 더 알아봅시다.

108
00:07:40,130 --> 00:07:44,270
하나는 sum함수입니다.
여기에 행렬 a가 주어져 있고, sum(a)라고 치면

109
00:07:44,270 --> 00:07:48,140
a의 모든 원소를 다 더합니다.
만약 한꺼번에 곱하고 싶으면

110
00:07:48,140 --> 00:07:50,940
prod(a) 라고 치면,

111
00:07:50,940 --> 00:07:54,225
a의 모든 원소를 곱한 값을 구해 줍니다.

112
00:07:54,225 --> 00:08:01,630
floor(a) 는 a의 각 원소값을 끝자리 버림하고,
즉 0.5를 버림하면 0이 되죠.

113
00:08:01,630 --> 00:08:06,600
ceil 또는 ceiling(a)는 끝자리를 올림하여
가장 가까운 정수를 구합니다.

114
00:08:06,600 --> 00:08:10,900
그래서 0.5를 올림하면 1이 되지요.

115
00:08:10,900 --> 00:08:13,330
또한, 이런 것도 있는데요,

116
00:08:13,330 --> 00:08:16,720
rand(3)라고 치면, 난수(랜덤한 숫자)값을 
갖는 3 X 3 행렬을 생성합니다.

117
00:08:16,720 --> 00:08:21,790
max(rand(3),rand(3)) 이라고 치면,

118
00:08:21,790 --> 00:08:27,000
랜덤한 3 X 3 행렬에서 원소 단위의 최대값을 반환합니다.

119
00:08:27,000 --> 00:08:30,680
이 숫자들이 약간 큰 값을 갖는 것처럼 보이는 것은

120
00:08:30,680 --> 00:08:33,150
실제로 랜덤하게 생성된 두 행렬의 원소들 중

121
00:08:34,490 --> 00:08:37,515
원소 단위 최대값만 반환된 것이기 때문입니다.

122
00:08:37,515 --> 00:08:38,280
이건 제가 사용하는 매직넘버입니다.

123
00:08:38,280 --> 00:08:43,050
이건 마방진, 3 X 3 행렬 A이구요,

124
00:08:43,050 --> 00:08:48,270
max(A,[],1)이라고 치면,

125
00:08:48,270 --> 00:08:53,580
1이 뭐냐면 열 단위로 
최대값을 구한다는 것입니다.

126
00:08:53,580 --> 00:08:58,260
그러므로 첫번째 열의 최대값인 8, 두번째 열은 9,

127
00:08:58,260 --> 00:08:59,960
3번째 열은 7이 되죠.

128
00:08:59,960 --> 00:09:04,194
1이 의미하는 것은,
8이 해당 열의 원소 중 최대값이라는 뜻입니다.

129
00:09:05,200 --> 00:09:08,780
반대로, 재밌는 표기법이지만 
만약 max(A,[],2) 라고 치면,

130
00:09:08,780 --> 00:09:12,480
여기 2는, 이번에는 각 행의 최대값을 구합니다.

131
00:09:12,480 --> 00:09:17,210
첫번째 행의 최대값은 8, 두번째 행은 7,
세번째 행은 9

132
00:09:17,210 --> 00:09:23,570
이것이 각 행, 또는 각 열의 
최대값을 구하는 방법입니다.

133
00:09:24,760 --> 00:09:30,050
그리고 기억해두세요, dafault는
(아무것도 안 쓰면) 열 단위입니다.

134
00:09:30,050 --> 00:09:34,880
그래서 행렬 A의 모든 원소에 대한 
최대값을 구하고 싶으면

135
00:09:34,880 --> 00:09:39,660
이렇게 max(max(A)) 라고 치면, 9가 얻어집니다.

136
00:09:39,660 --> 00:09:45,130
또는 A를 벡터로 변환하는 A(:)를 사용해서

137
00:09:45,130 --> 00:09:50,160
max(A(:))를 실행함으로써
 해당 벡터에 대한 최대값을 구할수도 있습니다.

138
00:09:52,130 --> 00:09:56,220
마지막으로, A가 9 X 9 마방진 행렬이라고 합시다.

139
00:09:56,220 --> 00:10:00,700
마방진이 모든 행과 열의 
합계가 같다는 성질을 기억하세요.

140
00:10:00,700 --> 00:10:03,650
대각선의 합계도 같죠.

141
00:10:03,650 --> 00:10:06,280
여기 9 X 9 마방진이 있습니다.

142
00:10:06,280 --> 00:10:07,470
한 번 sum(A, 1)을 실행해 보죠.

143
00:10:07,470 --> 00:10:12,050
이러면 열 단위의 합계를 구하므로,

144
00:10:12,050 --> 00:10:15,550
이 9x9행렬에서 각각의 열의 합이

145
00:10:15,550 --> 00:10:20,150
똑같이 369임을 확인할 수 있습니다.

146
00:10:20,150 --> 00:10:21,978
이번에는 행 단위의 총합을 구해 보죠.

147
00:10:21,978 --> 00:10:26,870
sum(A,2)를 치면

148
00:10:26,870 --> 00:10:32,950
A의 각 행의 합을 구할 수 있고 
이것도 다 369입니다.

149
00:10:32,950 --> 00:10:36,110
이제, A의 대각선 원소의 합계를 구해서,

150
00:10:36,110 --> 00:10:39,800
역시 합계가 똑같은지 확인합시다.

151
00:10:39,800 --> 00:10:45,558
이제 할 것은 9 X 9 항등행렬을 만들고, 
eye(9)이죠.

152
00:10:45,558 --> 00:10:52,330
다음으로 행렬 A에 이를 곱셈합니다.
여기 A에다가요.

153
00:10:52,330 --> 00:10:56,290
A .* eye(9) 라고 칩니다.

154
00:10:56,290 --> 00:11:00,970
이러면 2개의 행렬의 각 원소 단위로 곱셈을 수행하고,

155
00:11:00,970 --> 00:11:05,820
그래서 A의 대각선에 위치한 원소 외에 
나머지는 모두 지웁니다.

156
00:11:05,820 --> 00:11:11,130
이제, sum(sum(A.*eye(9)))라고 쳐서

157
00:11:11,130 --> 00:11:17,830
대각선에 위치한 원소들의 합이 
369임을 확인합니다.

158
00:11:17,830 --> 00:11:20,260
반대쪽 대각선도 마찬가지로
 이와 같이 합계를 구할 수 있습니다.

159
00:11:20,260 --> 00:11:22,340
좌측상단에서 우측하단의
대각선의 합계를 구한 것처럼

160
00:11:22,340 --> 00:11:27,410
좌측하단에서 우측상단까지의
 대각선의 합계도 구할 수 있습니다.

161
00:11:27,410 --> 00:11:29,791
이를 위한 명령어는 다소 복잡하지만,

162
00:11:29,791 --> 00:11:31,600
그걸 다 알 필요는 없습니다.

163
00:11:31,600 --> 00:11:34,790
그냥 여러분의 호기심을 위해서
어떻게 하는지 보겠습니다.

164
00:11:34,790 --> 00:11:38,390
한번 봅시다.

165
00:11:38,390 --> 00:11:40,685
flipud함수는 뒤집기(flip up down)를 의미합니다.

166
00:11:40,685 --> 00:11:45,760
이 함수를 실행하면 반대쪽에 있는 
원소들의 합계를 구합니다.

167
00:11:45,760 --> 00:11:50,090
마찬가지로 합계가 369 입니다.

168
00:11:50,090 --> 00:11:52,020
여기 보여드릴게요.

169
00:11:52,020 --> 00:11:54,262
eye(9) 를 쳐서 항등행렬을 구하고,

170
00:11:54,262 --> 00:11:59,470
flipup(eye(9))를 치면 이 항등행렬을

171
00:11:59,470 --> 00:12:02,890
수직으로 뒤집어서, 결과적으로 이렇게 됩니다. 아 잘못쳤다,

172
00:12:02,890 --> 00:12:06,480
flip ud네요, 이렇게 쳐서 
반대쪽 대각선을 구할 수 있습니다.

173
00:12:08,780 --> 00:12:12,750
이제 명령어 하나를 더 배울텐데, 
그게 이 비디오의 마지막입니다.

174
00:12:12,750 --> 00:12:16,820
A를 3 X 3 마방진 행렬로 생성합니다.

175
00:12:16,820 --> 00:12:20,340
만약 역행렬을 구하고 싶으면, pinv(A)라고 칩니다.

176
00:12:20,340 --> 00:12:23,120
보통은 pseudo-inverse 라고 부르는데, 
별로 신경쓰지 마세요.

177
00:12:23,120 --> 00:12:27,830
그냥 기본적인 A의 역행렬이라고 생각하면 됩니다.

178
00:12:27,830 --> 00:12:34,130
이렇게 temp = pinv(A) 라고 치고, temp 와 A를 곱하면

179
00:12:34,130 --> 00:12:38,110
항등행렬이 계산되는데, 각 대각선은 1이고

180
00:12:38,110 --> 00:12:41,650
대각선이 아닌 부분은 실수로 반올림해서 0 입니다.

181
00:12:44,210 --> 00:12:45,596
이것이 행렬과 벡터의 곱셈입니다.

182
00:12:45,596 --> 00:12:50,630
데이터와 행렬 사이에 서로 다른 계산을 
어떻게 수행하는지 살펴보았습니다.

183
00:12:50,630 --> 00:12:55,548
학습 알고리즘을 실행시킨 후, 
결과를 확인할 때

184
00:12:55,548 --> 00:12:59,760
제일 유용한 방법은, 결과를 그래프로
 보는 것(plot 또는 visualize사용)입니다.

185
00:12:59,760 --> 00:13:04,342
다음 비디오에서, Octave를 사용하여 이를 한두 줄의 코드로

186
00:13:04,342 --> 00:13:06,260
어떻게 실행하는지 보여드릴 것입니다.

187
00:13:06,260 --> 00:13:09,255
빠르게 데이터를 가시화 (visualize 또는 plot) 할 수 있고,

188
00:13:09,255 --> 00:13:13,340
학습 알고리즘이 어떻게 동작하는지 좀 더 잘 이해할 수 있을 겁니다.