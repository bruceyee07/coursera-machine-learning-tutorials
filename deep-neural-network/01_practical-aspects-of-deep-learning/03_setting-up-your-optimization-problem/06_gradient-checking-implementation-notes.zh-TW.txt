上一段影片中
您學到了梯度檢查 在這段影片, 我希望分享您
一些實作的技巧或 一些筆記在如何真正
建立梯度檢查在您的神經網路上 首先，不要使用梯度檢查來做訓練
只用在除錯時 我的意思是
當計算 dθ approx i 時 對於所有 i
這是很緩慢的計算 所以當建立梯度下降時
您會用反向傳播來計算 dθ 然後用反向傳播來計算導數 而只有當您除錯時
您會計算這個 來確定它接近於 dθ 但當您做完檢查後
您要關掉梯度檢查 不要在每個梯度下降
的迴圈中執行它 因為它就是很慢 第二, 如果演算法在梯度檢查時失敗了
看一下分量 看每一個分量
試著找出錯誤 我的意思是如果 dθ approx 
 遠離於 dθ 我會看哪一個 i 的值使得 dθ approx 是非常不同於 dθ 的值 舉個例子, 如果您發現
 θ (口誤) 或者 dθ 的值 它們遠離於
相對於 db[l] 在一些層中 但 dw 的分量卻相當接近 記得, 不同 θ 的分量代表
不同分量的 b 跟 w 當您發現如此時
您或許發現這個錯誤是 在您計算 db 時發生
導數相對於參數 b 同樣, 反之亦然, 如果您發現值是非常遠的 dθ approx 的值遠離於 dθ 您發現所有這些分量來自於 dw
或者一些層的 dw 這或許幫助您趨近
錯誤的位置 這不一定總是讓您
馬上找出錯誤 但有時候幫助您給您一些猜測
有關哪裡去追這些錯誤 接下來, 當做梯度檢查時 記得您的正則化 (regularization) 項目
如果您使用正則化的話 所以如果您的成本函數是
 J(θ) 等於 1 除以 m 總和於您的 損失而
加上這個正則化項目 然後總和於 l of wl 平方
那這是 J 的定義 您應該有 dθ 
是 J 的梯度 相對於 θ 
包含這個正則化項目 所以請記得包含這個項目 下一個, 梯度檢查對 dropout 沒有用, 因為在每次迴圈時 dropout 隨機消除了
不同子集的隱藏單元 要計算成本函數 J,
當 dropout 應用在梯度下降時
是很不容易的 實際上 dropout 可視為
一些成本函數 J 的最佳化 但因為成本函數 J 定義為
總和於所有指數大的 節點的子集他們可能
被任何一個迴圈消除 所以成本函數 J 是
很難去計算 因為您會每次取樣於成本函數 在您使用 dropout 時
您會消除不同隨機子集 所以使用梯度檢查
來重複檢查您的 應用 dropout 的計算
是很難的 我通常建立梯度檢查時
不使用 dropout 如果您要的話, 您可以設定
dropout 裡的 keep_prob 為 1.0 然後開啟 dropout 希望
我的 dropout 建置是正確的 有一些方式您可以做
像是固定某種形式的節點消除 利用梯度檢查來測試
這種形式是正確的 但實作時
我通常不這樣用 所以我的建議是先關掉 dropout
使用梯度檢查來檢查 當不使用 dropout 時, 您的演算法是正確的
然後才打開 dropout 最後, 這很微妙 這不是不可能, 或者說
極少發生但不是不可能 您建立梯度下降是正確的
當 w 跟 b 接近於 0 在隨機初始化時 但當您跑梯度下降時
 w 跟 b 越來越大 或許您的反向傳播建置在
w 跟 b 接近於 0 時是正確的 但當 w 跟 b 越來越大時
它變得不正確 您可以做一件事
我通常很少這樣做 但您可以做一件事是
在隨機初始時跑梯度檢查 然後訓練網路一段時間
當 w 跟 b 慢慢從 0 離開
從您小的初始值離開 然後訓練一些迴圈後
再跑一次梯度檢查 所以這是梯度檢查 恭喜您來到這個禮拜
最後的內容 在這一週, 您學習如何
設定您的訓練, 開發及測試集 如何分析偏差及變異
當如果您有高偏差 或高變異時跟
同時高偏差跟高變異時, 怎麼辦 您也學了如何
應用不同種類的正則化 (regularization) 像是 L2 正則化跟
 dropout 在您的神經網路 然後一些技巧來
加快訓練您的神經網路 最後是, 梯度檢查 我想這個禮拜您看了很多內容 您將練習這些觀念在
這個禮拜的程式練習中 祝您幸運 我期望在第二週再遇見您