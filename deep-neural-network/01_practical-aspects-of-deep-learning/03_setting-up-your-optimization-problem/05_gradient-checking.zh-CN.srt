1
00:00:00,400 --> 00:00:04,000
梯度检查省了我大量的时间

2
00:00:04,000 --> 00:00:08,500
还帮我多次找出了反向传播代码中的错误

3
00:00:08,500 --> 00:00:10,890
我将介绍怎么用梯度检查来调试代码

4
00:00:10,890 --> 00:00:14,885
并检验你的反向传播代码

5
00:00:14,885 --> 00:00:20,975
你刚刚写的神经网络里有一些参数
从W1,B1,一直到,WL,bL

6
00:00:20,975 --> 00:00:23,935
要实现梯度检查算法
首先要把你的所有参数

7
00:00:23,935 --> 00:00:28,835
重新拼成一个巨大的参数向量θ

8
00:00:28,835 --> 00:00:34,860
你要把W矩阵转化成一个向量

9
00:00:34,860 --> 00:00:39,850
把所有的W矩阵都转化成向量

10
00:00:39,850 --> 00:00:45,170
然后把他们首尾相接拼在一起

11
00:00:45,170 --> 00:00:47,020
成为一个巨大的参数向量θ

12
00:00:47,020 --> 00:00:52,720
之前代价函数J是所有W和b的函数

13
00:00:52,720 --> 00:00:58,380
经过向量转化后它变成了θ的函数

14
00:00:58,380 --> 00:01:02,160
W和b按照同样的顺序转化后

15
00:01:02,160 --> 00:01:07,740
你也可以把dW[1],dB[1]等等参数都转化成

16
00:01:07,740 --> 00:01:12,200
和θ的维度相同的向量dθ

17
00:01:12,200 --> 00:01:17,210
和之前一样,把dW[1]转化成向量
db[1]已经是向量

18
00:01:17,210 --> 00:01:21,220
把所有的dW矩阵转化成向量

19
00:01:21,220 --> 00:01:24,632
记住dW[1]和W[1]的维度相同

20
00:01:24,632 --> 00:01:27,080
db[1]和b[1]的维度相同

21
00:01:27,080 --> 00:01:31,252
经过相同的矩阵转化和向量拼接之后

22
00:01:31,252 --> 00:01:36,343
你就把所有的微分也转化成
一个参数向量dθ

23
00:01:36,343 --> 00:01:38,750
dθ和θ的维度一样

24
00:01:38,750 --> 00:01:43,780
现在的问题是
θ是代价函数J的梯度

25
00:01:43,780 --> 00:01:47,310
或者斜率吗？

26
00:01:47,310 --> 00:01:49,620
接下来就是如何编写梯度检查算法

27
00:01:49,620 --> 00:01:52,740
梯度检查(Gradient Checking)
经常缩写成(Grad Check)

28
00:01:52,740 --> 00:01:57,690
现在 代价函数J是θ的函数

29
00:01:57,690 --> 00:01:58,277
现在 代价函数J是θ的函数

30
00:01:58,277 --> 00:02:04,750
也就是说
不管这个参数向量θ的维度是多少

31
00:02:06,880 --> 00:02:11,618
代价函数J都是θ1,θ2,θ3
等参数的函数

32
00:02:11,618 --> 00:02:18,519
实现梯度检查算法时
我们首先要写一个循环

33
00:02:18,519 --> 00:02:23,008
对于每个i,取出θ的每个分量θi

34
00:02:23,008 --> 00:02:26,416
计算θi的近似微分

35
00:02:26,416 --> 00:02:28,170
让我们取双向微分

36
00:02:28,170 --> 00:02:30,100
代价函数J的参数是

37
00:02:30,100 --> 00:02:34,440
θ1,θ2,一直到θi

38
00:02:34,440 --> 00:02:38,380
我们给θi加上一个极小数ε

39
00:02:38,380 --> 00:02:42,970
并保持其他的θ分量不变

40
00:02:42,970 --> 00:02:46,164
因为我们要做双向微分

41
00:02:46,164 --> 00:02:51,226
我们把另一边的代价函数J的参数θi减去ε

42
00:02:51,226 --> 00:02:54,520
θ的其他分量不变

43
00:02:54,520 --> 00:02:59,690
然后把两个J相减的结果除以2ε

44
00:02:59,690 --> 00:03:04,772
我们之前讲过

45
00:03:04,772 --> 00:03:10,270
这个结果应该约等于dθi

46
00:03:10,270 --> 00:03:15,609
因为dθi应该是代价函数J
关于θi的偏微分

47
00:03:15,609 --> 00:03:21,320
因为dθi应该是代价函数J
关于θi的偏微分

48
00:03:21,320 --> 00:03:25,130
然后 你要把θ的所有分量θi
都按照这个方法计算一遍

49
00:03:25,130 --> 00:03:28,360
最后 你将得到两个向量

50
00:03:28,360 --> 00:03:31,793
dθ的近似值和dθ

51
00:03:31,793 --> 00:03:35,860
dθ的近似值和dθ的维度相同

52
00:03:35,860 --> 00:03:39,373
他们的维度又和θ一样

53
00:03:39,373 --> 00:03:43,183
你要检查这两个向量是否大致相等

54
00:03:43,183 --> 00:03:44,130
得知植物能闻到彼此时一定很惊讶 而是因为相互怀疑所以我们全副武装

55
00:03:44,130 --> 00:03:47,310
那么 怎样定义两个向量是大致相等呢?

56
00:03:47,310 --> 00:03:50,910
那么 怎样定义两个向量是大致相等呢?

57
00:03:50,910 --> 00:03:52,593
我是这么做的

58
00:03:52,593 --> 00:03:57,297
我计算两个向量的欧几里得距离

59
00:03:57,297 --> 00:04:02,100
dθ的近似 减去dθ
并把结果o2标准化

60
00:04:02,100 --> 00:04:03,851
注意这个式子的右上角没有平方符号

61
00:04:03,851 --> 00:04:06,788
它把两个向量的每个分量的差的平方之和再开方
就是欧几里得距离

62
00:04:06,788 --> 00:04:09,857
它把两个向量的每个分量的差的平方之和再开方
就是欧几里得距离

63
00:04:09,857 --> 00:04:15,512
再把结果根据向量的长度标准化

64
00:04:15,512 --> 00:04:19,150
把它除以向量dθ的近似和向量dθ的
欧几里得长度的和

65
00:04:19,150 --> 00:04:22,620
把它除以向量dθ的近似和向量dθ的
欧几里得长度的和

66
00:04:22,620 --> 00:04:28,044
除以这个分母是为了
防止这两个向量太小或太大

67
00:04:28,044 --> 00:04:32,860
除以分母就把这个式子变成了一个比值

68
00:04:32,860 --> 00:04:35,202
在实际中

69
00:04:35,202 --> 00:04:39,898
我取ε为10的负7次方

70
00:04:39,898 --> 00:04:44,644
这样 如果这个式子的结果

71
00:04:44,644 --> 00:04:49,460
小于10的负7次方 那就认为计算正确

72
00:04:49,460 --> 00:04:53,302
它表示你的微分近似是对的

73
00:04:53,302 --> 00:04:55,330
因为(误差)很小

74
00:04:55,330 --> 00:05:00,790
如果该式的结果在10的负5次方的量级的话

75
00:05:00,790 --> 00:05:02,148
我会很仔细地检查一遍 有可能式子也是对的

76
00:05:02,148 --> 00:05:05,239
但我会再三检查这个向量的每个分量

77
00:05:05,239 --> 00:05:07,862
确定没有某个分量很大

78
00:05:07,862 --> 00:05:10,649
如果某个分量很大的话

79
00:05:10,649 --> 00:05:12,860
那么可能你的式子里有错误了

80
00:05:12,860 --> 00:05:17,719
如果左面的式子在10的负3次方的量级的话

81
00:05:17,719 --> 00:05:21,728
我觉得你一定要检查代码
它很可能有错误

82
00:05:21,728 --> 00:05:25,083
它的结果应该远远小于10的负3次方

83
00:05:25,083 --> 00:05:29,690
如果(某个分量)大于10的负3次方
我很担心你的代码有错误

84
00:05:29,690 --> 00:05:32,970
如果(某个分量)大于10的负3次方
我很担心你的代码有错误

85
00:05:32,970 --> 00:05:37,204
你应该仔细检查数据的每个部分

86
00:05:37,204 --> 00:05:41,799
看看是不是有某个i

87
00:05:41,799 --> 00:05:45,960
使得dθi的近似和dθi很不一样

88
00:05:45,960 --> 00:05:47,867
然后继续跟踪调试,看看

89
00:05:47,867 --> 00:05:51,040
你的求导部分可能有错

90
00:05:51,040 --> 00:05:54,970
调试程序之后 最终这个数字应该很小很小

91
00:05:54,970 --> 00:05:59,820
这样你的代码就是正确的

92
00:05:59,820 --> 00:06:01,320
在写神经网络时

93
00:06:01,320 --> 00:06:04,840
我会经常写正向传播和反向传播算法

94
00:06:04,840 --> 00:06:08,612
梯度检查可能返回一个非常大的值

95
00:06:08,612 --> 00:06:12,460
那么我的程序可能有错,赶紧调试,调试,调试

96
00:06:12,460 --> 00:06:16,310
调试之后 如果我的算法通过了梯度检查

97
00:06:16,310 --> 00:06:20,110
返回了一个小值
那么我可以自信地说我的算法是对的

98
00:06:20,110 --> 00:06:22,310
现在你知道梯度检查是怎么回事了

99
00:06:22,310 --> 00:06:24,850
它找出了我写的神经网络中的很多错误

100
00:06:24,850 --> 00:06:27,330
我希望它也会帮到你

101
00:06:27,330 --> 00:06:29,970
在下一段视频中 我将讲一些

102
00:06:29,970 --> 00:06:33,490
实现梯度检查的小窍门

103
00:06:33,490 --> 00:06:34,640
我们来看下一段视频
GTC字幕组翻译