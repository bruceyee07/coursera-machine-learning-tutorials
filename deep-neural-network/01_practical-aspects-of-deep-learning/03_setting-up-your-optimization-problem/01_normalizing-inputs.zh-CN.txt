训练神经网络时 有一种加速训练过程的方法 那就是对输入进行归一化 我们看看这是什么意思 考虑一个有两个输入特征的训练集 即是输入特征x是二维的 然后这里就是输入的散点图 对输入进行归一化包含两个步骤 第一步是将减去均值 或说将均值归零 所以令μ为所有Xi的和 其中i是由1到M 得到μ向量后 再将训练集中每个样本x都赋值为x-μ 意思就是将训练集进行平移 直到它的均值变为零 接下来第二部就是将方差进行归一化 注意到这里 特征x1的方差比x2的方差大很多 注意到这里 特征x1的方差比x2的方差大很多 所以我们要做的就是 令σ^2等于 Xi**2之和除以m 其中i是从1到m 我想这个符号表示逐元素取平方 那么σ平方就是表示每个特征的方差的向量 注意我们已经减去了均值 所以Xi平方 即逐元素平方 就等于方差 然后把每个样本都除以σ的平方 把结果画在图上就是这样 现在X1和X2这两个特征的方差都等于1 一个提示:如果你用这种方法来对数据进行缩放 那么务必对测试集和训练集都使用同样的μ和σ^2 具体来说 就是不应该用不同的方式去归一化 训练集与测试集 无论这里μ与σ^2各为何值
都把它们以一样的方式代入这两个式子 以将训练集与测试集用一样的方式归一化 而不是对训练集和测试集分别使用不同的μ与σ^2 因为你的所有数据 包括训练和测试样本 都得经过同样的变换 即由同样的μ与σ^2定义的 也就是由训练集数据计算出来的μ与σ^2 那为什么要做这两步呢? 为什么要对输入特征进行归一化呢? 回想一下 像右上方这样的代价函数 你会发现如果使用了未归一化的输入特征 代价函数看起来就会像这样 像一个压扁了的碗 在这个细长的代价函数中 你寻找的最小值可能在那里 但若这是因为你的特征的尺度不一样 例如说 x1的范围是1到1000 而x2只有0到1 那就会导致 神经网络参数w1和w2的比率 或说w1和w2取值的范围会有很大的不同 这两根轴应当是w1和w2 但暂且用w和b代替 那代价函数就可能像那样是一个扁平的碗 如果你把这个函数的等值线画出来 你就会有一个像这样的扁长的函数 而如果你将特征进行归一化后 你的代价函数通常就会看起来更对称 如果你对左图的那种代价函数使用梯度下降法 那可能必须使用非常小的学习率 因为假如从这里开始 梯度下降法需要经历许多步 反复辗转 才能好不容易终于挪到这个最小值 而如果等值线更趋近于圆形 那无论从何开始 梯度下降法几乎都能直接朝向最小值而去 你可以在梯度下降中采用更长的步长 而无需像左图那样来回摇摆缓慢挪动 当然在实践中 w是一个高维向量 把它画在二维空间中可能无法正确传递出高维中的感觉 但大体上的感觉是你的代价函数会更圆 优化过程更容易进行 因为各种特征的尺度会比较接近 不是有的从1到1000 有的却从0到1 而是大多数都处于-1和1之间 大家的方差范围都接近 这些会使得代价函数J优化起来更容易也更快 其实在实践中 假使有特征x1的范围是0到1 而特征x2的范围是-1到1 特征x3是1到2 这些范围都比较接近 所以优化起来也没什么问题 只有当它们的范围有非常大的不同时 譬如一个特征是1到1000 而另一个是0到1 那就会着实地削弱优化算法的表现了 但只要将它们变换 使均值皆为0 方差皆为1 就如前一页那样 就能保证所有的特征尺度都相近 这通常也能让帮助学习算法运行得更快 所以如果你的输入特征的尺度非常不同 比如可能有些特征取值范围是0到1 有些是1到1000
那对输入进行归一化就很重要 而如果输入特征本来尺度就相近
那么这一步就不那么重要 不过因为归一化的步骤几乎从来没有任何害处 所以我无论如何总是进行归一化
尽管我并不确定 它是否会让训练时的计算变得更快 所以对输入特征进行归一化 就讨论到这 接下来我们会继续讨论加速神经网络训练的方法
GTC字幕组翻译