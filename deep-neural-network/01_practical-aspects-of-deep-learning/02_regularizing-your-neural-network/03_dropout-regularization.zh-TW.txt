除了 L2 正則化 有一種有力的正則化技巧稱為 "dropout" 我們來看它如何作用 假設您訓練一個神經網路
像左邊這個是過適的 這是 dropout 的做法 讓我複製一下神經網路 使用 dropout, 我們要做的是通過網路每一層 設定一些機率來消除神經網路的節點 假設對於每一層 我們將對每一個節點 擲一枚硬幣，有 0.5 的機會 保留這個節點, 0.5 機會刪除每一個節點 經過擲硬幣後 我們會決定消除這些節點 我們做的是實際
從這些節點移除所有輸入及輸出 所以我們最終會得到一個小很多 真的裁減很多的網路 然後您做反向傳播訓練 使用一個例子在這裁減很多的網路上 而在不同的例子上 您會再次擲硬幣來用 不同集合的節點然後
丟棄或者去除不同集合的節點 所以對於每一個訓練例子 您會訓練它使用這些縮減網路之一 也許這似乎是一個有點瘋狂的技術 它只是四處隨機剔除節點 但這實際上可行 但您可以想像因為您訓練每一個例子
在比較小的網路上 或者也許給一些感覺
為什麼您最終能夠正則化這個網路 因為這些比較小的網路已經通過訓練了 讓我們來看如何建置 dropout 有一些方式來建置 dropout 我將告訴您最常用的 這種技巧稱為 翻轉 dropout 為了完整描述起見 假設我們用 l = 3 層來描述 所以在程式裡我將寫一堆 3 這只是說明如何去表示 dropout 在單一層裡 我們要做的是設定一個向量 d 而 d3 將是 dropout 向量在第三層 這就是 3 的意思, np.random.rand 而這將跟 a3 同樣的 shape 而我來看看這個是否小於某個數字 我將稱它為 keep_prob 所以, keep_prob 是一個數字 之前是用 0.5 也許我現在用 0.8 在這個例子上 而這是對於一個隱藏單元
要不要保留的機率 所以 keep_prob = 0.8 意思是有 0.2 的機會
去除掉任一個隱藏單元 它的作用是產生一個隨機矩陣 如果您向量化的話也管用 所以 d3 是一個矩陣 所以每個例子的每個隱藏單元 0.8 的機會在相對於 d3 的位置是 1 20% 的機會是 0 所以這個隨機數字小於 0.8
它有0.8的機會為 1 或者說是為真 20% 或者 0.2 機會為偽, 為 0 然後您要做的是
拿您第三層的啟動值 讓我稱之為 a3
在下面這個例子 所以 a3 是您計算的啟動值 您可以設 a3 等於舊的 a3 乘上, 這是ㄧ個逐元素的乘積 或者您可以也寫成 a3 *= d3 這樣做是對於 d3 
每個等於 0 的元素 每個元素有20%機會為 0 用這個乘的運算來
化它為 0 在 d3 相對應的元素 如果您在 python 做這個 技術上 d3 會是一個布林值矩陣
其值會是真或偽 而不是 1 或 0 但用乘法運算一樣可行, 它會 將真跟偽的值
換成 1 跟 0 如果您自己在 python 試一試, 您會了解 最後, 我們將 a3 按比例放大, 利用除以 0.8, 實際上是除以我們的 keep_prob 參數 讓我來解釋
最後這個步驟在做什麼 假設為了方便解釋起見
您有 50 個單元 或者 50 個神經元在第三個隱藏層 所以也許 a3 是一個 50 乘 1 維度或者 如果您向量化, 或許是 50 乘 m 維度 如果您有 80% 機會保留它們，20% 機會去掉它們 這意思是平均來講 您最終會關閉 10 個單元
或者 10 個單元歸零 現在如果您看 z[4] 的值 z[4] 將等於 w[4] * a[3] + b[4] 所以, 期望值 這個會減少 20% 這個的意思是 a3 20%的元素會被歸零 為了不減低 z[4] 的期望值 您要做的是拿這個 將它除以 0.8. 因為 這會更正它或者說
將它提升回您需要的額外的 20% 這樣就不會改變 a3 的期望值 這一行就是稱為
翻轉 dropout 技巧 而它的影響是 不管您設 keep_prob 多少 不管是 0.8, 0.9 甚至是 1 如果設成 1 就不會有 dropout 因為這會保留所有的
不管是 0.5 或其他 這種翻轉 dropout技巧
是除以 keep_prob 來確保 a3 的期望值不變 實際上在測試時 當您試著評估神經網路 我們將在下一張投影片談到 這種翻轉 dropout 這一行用綠色框框起來 這會讓測試時間容易些
因為您減低了比例問題 至今最常用的 dropout 建置 就我所知是翻轉 dropout 我建議您用這種方式建置 但有些早期 dropout 的迭代 少了 除以 keep_prob 這一行 在測試時演算法變得比較複雜 但人們傾向於
不再用其他版本 您做的是您使用 d 向量 您注意到對於不同的訓練例子 您將不同的隱藏單元歸零 實際上, 如果您使用
多次(循環)處理在同一個訓練集上 那在不同的處理資料集時循環時 您應該隨機
將不同的隱藏單元歸零 所以並不是對於一個例子 您一直將同樣的隱藏單元歸零 在第一次梯度下降循環時 您也許將一些隱藏單元歸零 而在第二次梯度下降循環時 當您歷經訓練集第二次時 也許您會將不同樣子的
隱藏單元歸零 而向量 d 或者 d3 對於第三層 是用來決定哪些該歸零 同樣在正向傳播跟反向傳播時 我們這裡只展示正向傳播 現在如果您要在測試時訓練演算法, 您要這樣做 測試時，您會給予一些 x 來做預測 使用我們標準的符號 我將使用 a[0] 第零層的啟動值來記測試例子 x 我們要做的是不使用 dropout 在測試時, 特別是這是合理的 z[1] = w[1]a[0] + b[1] a[1] = g[1](z[1]) z[2] = w[2]a[1] + b[2] a[2] = ... 等等, 直到您到最後一層您做預估 y-hat 但請注意，測試時不使用 dropout, 您不用隨機擲硬幣 您不用擲硬幣來決定
哪一個隱藏單元來去除 而這是因為當您在測試時做預估 您真的不希望您的輸出是隨機的 如果您在測試時使用 dropout 這只會在您的預估中增加雜訊 理論上, 您可以做的是跑預估流程 很多次使用隨機丟棄不同的隱藏單元
然後跨過所有的隱藏單元 但這真的是效率不高的運算
且給您大約類似的結果 相當類似的結果對於這個不同的流程 還有要提醒一下 這種翻轉 dropout 您記得前面投影片我們除以 keep_prob 那個的影響是確認即使當您不做 dropout 在測試時, 比例上 這些啟動值的期望值不會改變 所以您不需要加入
額外的比例參數在測試時 這是跟訓練時不同的地方 所以這是 dropout 當您做這個禮拜的程式練習時 您會得到第一手的經驗 但為什麼它真的可行? 我想在下一段影片中給您 一些比較好的直觀有關於 dropout 真正在做些什麼 讓我們進入下一段影片