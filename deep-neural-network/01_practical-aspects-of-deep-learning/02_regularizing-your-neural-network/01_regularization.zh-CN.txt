如果你怀疑你的神经网络在数据上发生了过拟合 也就是存在高方差问题 你也许需要首先尝试使用正则化 获取更多数据也是解决高方差问题的 一个很可靠的方法 但你并不是总能获取到更多的训练数据 或者获取更多数据的代价太大 但使用正则化通常有助于防止过拟合 并降低网络的误差 下面我们来看看正则化是如何生效的 我们以逻辑回归为例进行阐述 在逻辑回归中 你会尝试最小化代价函数J 该代价函数定义为 每一个训练样本的预测的损失之和 其中w和b是 逻辑回归的参数 因此w是一个x维的参数向量 b是一个实数 要为逻辑回归正则化 你需要 加上这个lambda 它称为正则化参数 我稍后会详细介绍 lambda/2m 再乘以w范数的平方 这里w的范数的平方等于 对于j从1到n_x 求w_j的平方和 也可以写成w的转置乘以w
即参数矢量w的欧几里得范数的平方 这称为L2正则化 因为这里使用的是参数矢量w的 欧几里得范数 也称为L2范数 为什么只对参数w进行正则化呢? 为什么我们不把b的相关项也加进去呢？ 实际上你可以这样做 但我通常会把它省略掉 因为你可以看一下你的参数
w往往是一个非常高维的参数矢量 尤其是在发生高方差问题的情况下 可能w有非常多的参数 你没能很好地拟合所有的参数
而b只是单个数字 几乎所有的参数都集中在w中 而不是b中 即使你加上了最后这一项 实际上也不会起到太大的作用 因为b只是大量参数中的一个参数 在实践中我通常就不费力气去包含它了 但如果你想的话也可以(包含b) L2正则化是最常见的一种正则化方式 你可能也听说过L1正则化 即不使用L2范数 而是使用lambda/m乘以这一项的和 这称为参数矢量w的L1范数 这里有一个数字1的小角标 无论你在分母中使用m还是2m 它只是一个缩放常量 如果你使用L1正则化 w最后会变得稀疏 这意味着w矢量中有很多0 有些人认为这有助于压缩模型 因为有一部分参数是0 只需较少的内存来存储模型 然而我在实践中发现 通过L1正则化让模型变得稀疏 带来的收效甚微 所以我觉得至少在压缩模型的目标上 它的作用不大 在训练网络时 L2正则化使用得频繁得多 抱歉 修改一下这里的标记 最后要说明的是 这里的lambda称为正则化参数 通常使用开发集或hold-out交叉验证 来配置这个参数 通过尝试一系列的值 找出最好的那个 即在训练集上得到较好的结果 和保持参数的L2范数较小以避免过拟合 之间进行取舍 lambda是你需要调优的另一个超参数 顺便一提 在编程练习中 lambda是Python编程语言的保留关键字 所以在编程练习中 我们把它写为lambd 不写a 以避免和Python的保留关键字冲突 我们使用lambd表示正则化参数lambda 以上是在逻辑回归中实现L2正则化的方法 那么在神经网络中呢? 在神经网络中 你有一个代价函数 它是你所有参数的函数 包括w[1] b[1]到w[L] b[L] 这里大写的L是神经网络的层数 因此 代价函数是m个训练样本上 的损失之和 至于正则化 再加上lambda/2m 乘以所有参数W的范数的平方之和 这里W是你的参数矩阵 这里矩阵范数的平方定义为 对于i和j 对矩阵中每一个元素的平方求和 如果你想为这个求和加上索引 这个求和是i从1到n[l-1] j从1到n[l] 因为w是一个n[l-1]列 n[l]行的矩阵 这些是第l-1层和第l层的隐藏单元数量单元数量
或 这个矩阵的范数 称为矩阵的弗罗贝尼乌斯范数 使用角标F标记 由于线性代数中某些神秘的技术原因 这不叫矩阵的L2范数 而是称为矩阵的弗罗贝尼乌斯范数 我知道把它称为矩阵的L2范数会更加自然 但由于某些你不需要了解的神秘原因 习惯上把它称为弗罗贝尼乌斯范数 它表示矩阵中元素的平方和 有了它 现在要如何实现梯度下降呢? 之前我们使用反向传播计算dw 通过反向传播 我们能得到J关于w的偏导数 准确来说是任意给定l的w 之后更新w[l] 为w[l]减去学习速率乘以dw 这是为目标函数添加正则化项之前的步骤 现在我们为目标函数添加了这个正则化项 就需要为这个dw加上lambda/m*w[l] 然后就可以像之前一样计算这个更新 可以证明 这个新的dw[l] 仍然正确地定义了 在添加了额外的正则化项之后 代价函数关于参数的倒数 出于这个原因 L2正则化有时也被称为 权重衰减 如果我把这个dw[l]的定义代入这里 你会发现w[l]的更新是 w[l]乘以学习速率alpha 乘以由反向传播得到的这一项 加上lambda/m*w[l] 在这里加上减号 这等于 [如图所示] [如图所示] 这一项表示无论矩阵w[l]是多少 你都会让它变得稍小一点 实际上 这相当于在矩阵w上乘以 1-alpha*lambda/m 你实际上是让矩阵w
减去alpha*lambda/m乘以它本身 就像让矩阵w乘以这个 略小于1的数字 这就是L2范数正则化又被称为权重衰减的原因 因为它就像普通的梯度下降 更新w为w减去alpha乘以从反向传播得到的原梯度 但现在你还会让w乘以这个 略小于1的项 因此L2正则化又称为权重衰减 我不会使用那个名称 它被称为权重衰减的原因是第一项等于这个 你只是让权重矩阵乘以了一个略小于1的数字 以上就是在神经网络中实现L2正则化的方式 可能有人会问 嘿Andrew 为什么正则化能够防止过拟合? 让我们继续看下一个视频 其中介绍了正则化能防止过拟合的原因