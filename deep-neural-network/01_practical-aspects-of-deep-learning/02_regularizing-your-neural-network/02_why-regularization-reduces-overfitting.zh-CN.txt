为什么正则化能够防止过拟合呢? 为什么它有助于减少方差问题? 我们通过几个例子来直观地体会一下 请回忆一下 左边是高偏差 右边是高方差 中间的是恰好的情况 我在之前的视频中画过这几张图 现在 来看一下这个庞大的深度神经网络的拟合情况 我知道画出来的这个网络还不够大 也不够深 但是你可以认为这就是过拟合的神经网络 图中就是我们的代价函数J 包含了参数W和B 并且J是一些损失项的总和 所以我所做的正则化就是添加一些 额外的项目 来避免权重矩阵过大 这就是弗罗贝尼乌斯范数 那么为什么通过压缩L-2范式或者 弗罗贝尼乌斯范数 或者参数项就能减轻过拟合情况呢? 关于这个问题的一个直观理解就是 如果你把正则项λ设置的很大 权重矩阵W就会被设置为 非常接近0的值 因此这个直观理解就是
把很多隐藏单元的权重 设置的太接近0了而导致 这些隐藏单元的影响被消除了 如果是这种情况 那么就会使这个大大简化的神经网络变成一个很小的神经网络 事实上 这种情况与逻辑回归单元很像 但很可能是网络的深度更大了 因此这就会使 这个过拟合网络带到更加接近左边高偏差的状态 但是λ存在一个中间值 能够得到一个更加接近中间这个刚刚好的状态 直观理解就是把λ值设的足够高的话 它就会使W接近0 但实际中并不会发生这种情况 我们可以想象成通过把隐藏单元的值归零 来削减了隐藏单元的影响 最终导致这个网络变成了一个更加简单的网络 这个神经网络越来越接近逻辑回归 我们直觉上认为这些隐藏单元的影响被完全消除了
其实并不完全正确 实际上网络仍在使用所有的隐藏单元 但每个隐藏单元的影响变得非常小了 但最终你得到的这个简单的网络 看起来就像一个不容易过拟合的小型的网络 这种直觉在你通过编程练习 实现正则化时对你理解是很有帮助的 你实际上看到了一些方差变小的结果 现在通过另一个例子直观理解一下 为什么正则化可以帮助防止过拟合 在这个例子中 假设我们使用的 tanh激活函数是图中这样的 使用g(z)表示tanh(z) 因此这种情况下 可以发现只要Z的值很小 比如Z只涉及很小范围的参数 也许就像图中这个范围所示<br />那么你其实是在使用tanh函数的线性的条件部分 只有Z的值被允许取到更大的值或者像这种小一点的值的时候 激活函数才开始展现出它的非线性的能力 因此直觉就是 如果λ值 即正则化参数被设置的很大的话 那么激活函数的参数实际上会变小 因为代价函数的参数会被不能过大 并且如果W很小那么由于 Z等于W这项再加上b 但如果W非常非常小 那么Z也会非常小 特别是如果Z的值相对都很小时 就在图中这样的范围内取值的话 那么g(z)函数就会接近于线性函数 因此 每一层都几乎是线性的 就像线性回归一样 就像我们第一课中讲过的那样 如果每层都是线性的那么你的整个网络就是线性网络 因此即使一个很深的神经网络 如果使用线性激活函数 最终也只能计算线性的函数 因此就不能拟合那些很复杂的决策函数 也不过度拟合那些 数据集的非线性决策平面 就像我们在上张幻灯片中看到的过拟合高方差的情况 总结一下 如果正则化变得非常大 而参数W很小 那么Z就会相对很小 此时先暂时忽略b的影响 Z会相对变小 即Z只在小范围内取值 那么激活函数如果是tanh的话 这个激活函数就会呈现相对线性 那么你的整个神经网络就只能计算一些 离线性函数很近的值 也就是相对比较简单的函数 而不能计算 很复杂的非线性函数 因此就不大容易过拟合了 再重申一遍
当你在编程练习作业中实现正则化的时候 你就能亲眼看到这里所说的情况 在总结关于正则化的讨论之前 我想给大家一个实现程序时的小建议 在程序中增加正则项的时候 我们根据代价函数J的定义 加入这个额外的惩罚项来防止权重过大 如果你使用梯度下降方法 调试程序的一个步骤就是画出代价函数J关于 梯度下降的迭代次数的图像 可以看到的是每次迭代后代价函数J都会单调递减 如果你实现了正则化部分 那么请记住J现在有了新的定义 如果你仍然使用原来定义的J 就像这里的第一项 你可能看不到单调递减的函数图像 所以为了调试梯度下降程序请确保你画的图像 是利用这个新定义的J函数
它包含了这里第二个项 否则J不会在每次迭代后都单调递减 以上就是L2正则化 也是我训练深度模型的时候最常用的正则化技巧 在深度学习中也常会碰到另一个时常会用到的正则化技巧 被称作dropout正则化 我们就在下一个视频中看看它是怎么工作的吧
GTC字幕组翻译