如果您懷疑您的神經網路
過適於您的資料 也就是您有高變異問題 您第一件事情應該
要試著做的也許是正則化 另一種方式來解決高變異 是得到更多的資料
這也是相當可靠的方式 但您不可能永遠獲得
更多的資料, 或者 獲得更多的資料可能很貴 但加入正則化通常會
幫助您避免過適問題 或者減低您網路的錯誤 所以讓我們來看正則化如何作用 讓我們用羅吉斯迴歸分析
來發展這個觀念 記得在羅吉斯迴歸分析中
您試著最小化成本函數 J 定義成這個成本函數 總和您的訓練例子的
個別預估值損失在 不同的例子上
您記得 w 跟 b 在羅吉斯迴歸分析中
是參數 所以 w 是 nx 維度參數向量
 b 是一個實數 要加上正則化到
羅吉斯迴歸分析, 您要做的是 這件事, lambda, 
稱為正則化參數 我們等一下會談到 lambda / 2m 乘上 w 的範數平方 這裡
w 範數平方等於 從 j 等於 1 到 nx 總和 wj 平方
或者這也可以寫成 w 轉置 w, 
這只是參數 w 向量的歐氏範數平方 而這稱為 L2 正則化 因為這裡
您使用的是歐氏範數, 也是稱為 L2 範數
對於參數向量 w 為什麼您只有正則化參數 w 為什麼我們不把 b 也加進去？ 實作時, 您可以這樣做
但我通常省略它 因為如果您看您的參數
w 通常是很高維度 參數向量
特別是高變異問題 也許 w 就是有很多參數 所以您無法配適所有的參數
而 b 只是一個數 幾乎所有的參數
在 w 而不在 b 而如果您加上最後一項
實作上 它不會造成多大不同 因為 b 只是很大數目的參數之一 實作上
我通常不去包含它 但如果您要加的話也可以 所以 L2 正則化是
最常見的正則化 您也許也聽過人們談到 L1 正則化 也就是當您加的時候
與其加這個 L2 範數 您取而代之用這個項
lambda/m 總和這個 這也是稱為 L1 範數的參數向量 w 所以這裡有小小下標 1
對吧? 我猜不管您放 m 或者 2m 在分母
都只是一個比例常數 如果您用 L1 正則化
那 w 會變得比較稀疏 這個意思是 w  
向量會有很多的 0 在裡面 有些人說這樣可以
壓縮這個模型， 因為 很多參數為 0 時
您可以用比較少的記憶體來儲存這個模型 雖然我發現， 實作時
 L1 正規化讓您的模型稀疏 只會幫助一點點 所以我並不常用它
至少不會 為了壓縮您的模型用它 而當人們訓練網路時 L2 正則化就是
用的多很多 抱歉, 更正一些記號 最後一點細節 這裡的 lambda 是稱為正則化參數 通常您使用開發集
來設定這個 使用交叉驗證集 當您試著不同的值
看哪一個作用最好 權衡了在訓練集作用得很好
以及 設定了 您參數的L2 範數較小 這樣會避免過適 所以 lambda 是另一個超參數
您必須調整 順便說一下
對於程式作業 lambda 是一個保留關鍵字
在 Python 程式語言 所以在程式練習中
我們用 lambd 少了一個 a, 
為了不跟 Python 保留關鍵字衝突 所以我們用 lambd 來代表
lambda 正則化參數 這是您如何使用
L2 正則化在羅吉斯迴歸分析上 如何用在神經網路上 ？ 在神經網路上, 您有一個
成本函數是一個函數 用所有的參數, w[1]
b[1] 直到 w[L], b[L] 而大寫 L 是您神經網路的層數 所以成本函數是這個
對於損失做總和 您 m 個訓練例子的總和 而要加入正規化
您加入 lambda 除以 2m of 總和對於所有您個參數 W
您的參數矩陣 w 我們也稱為範數平方 而矩陣的範數
也就是 範數平方定義為
i 總和 j 總和 所有矩陣的元素平方 如果您要這個總和的索引 這一個是總和從 i = 1 到 n[l-1] 總和從 j=1 到 n[l] 因為 w 是一個 n[l-1] 乘
n[l] 維度向量 而這些數字是
 l - 1 層跟 l 層的單元數目 這個矩陣範數
實際上也稱為弗比尼斯 範數在矩陣上
記一個 F 在下標 為了神秘的線性代數
技術上的原因 這不稱為矩陣 L2 範數 而是稱為
矩陣弗比尼斯範數 我知道聽起來稱它為
矩陣 L2 範數比較自然 但為了神秘的理由
您不需要知道 按照慣例，這就稱為弗比尼斯範數 它只是對於
矩陣元素平方的總和 所以您如何用它
來建置梯度下降 之前, 我們會用
反向傳播來完成 dw 而反向傳播
會給我們偏導數 of J 相對於 w
或者應該說 w 對於任何 [l] 然後您更新 w[l]
為 w[l] 減學習率乘上 d 所以這是加上額外的正則化項目之前的目標 現在我們加入這個
正則化項目到這個目標 您要做的是拿 dw 
加入這個 lambda /m 乘 w 而然後您只要計算這個更新值
像之前一樣 實際上有了這個
新的 dw[l] 定義 這個新的 dw[l] 仍然是
正確的導數定義 對於您的成本函數
相對於您的參數 即使您現在在後面加入這個
額外的正則化項目 而為了這個原因
L2 正規化有時候也 稱為權重衰減 如果我拿這個 dw[l] 的定義
然後代入這個公式 然後您會看到這個更新是
 w[l] = w[l] 乘上(應該是減) 學習率 alpha 乘
這個從反向傳播來的東西 加 lambda / m 乘上 w[l] 丟一個減號在這裡 所以這等於 w[l] 減 alpha lambda / m 乘 w[l] 減 alpha 乘 您從反向傳播來的東西 而這一項表示
不管 w[l] 矩陣為何 您將會讓它
小一點點, 對吧? 這個實際上是如果您
拿這個矩陣 w 你將它乘以 1- alpha lambda/m 您其實是拿這個矩陣 w 
減去 alpha lambda /m 乘上這個 像是您用這個數字乘上矩陣 w 這會是比 1 小一點點 所以這是為什麼 L2 範數正則化
也稱為權重衰減 因為它像一般
梯度下降, 而您更新 w 用減去 alpha 乘上
從反向傳播得到的一般梯度 但現在您也將
w 乘上這個東西 這個會比 1 小一點 所以另外一個名稱給
 L2 正則化是權重衰減 我將不會使用這個名稱
但直觀上而言 為什麼稱為權重衰減是
因為第一個項目等於這個 所以您將這個權重矩陣
乘上一個數子比 1 稍小一點 所以這是您如何建置
L2 正則化在神經網路 現在一個問題是
嗨, Andrew 為什麼正則化
能夠避免過適 讓我們來看下一段影片 來得到一些直觀
正則化如何避免過適