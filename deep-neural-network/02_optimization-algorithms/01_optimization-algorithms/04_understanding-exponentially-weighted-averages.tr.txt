Son videoda, üssel ağırlıklı ortalamalar hakkında konuştuk. Bu, anahtar bir bileşen olarak ortaya çıkacak. sinir ağlarınızı eğitmek için kullandığınız birkaç optimizasyon algoritması. Yani, bu videoda, biraz daha derine inmek istiyorum Bu algoritmanın gerçekten ne yaptığına dair sezgiler. Bu, katlanarak ağırlıklı ortalamaları uygulamak için temel bir denklem olduğunu hatırlayın. Ve, eğer beta 0,9'a eşitse, kırmızı çizgiye sahipsin. Bire daha yakın olsaydı, Eğer 0.98 olsaydı, yeşil çizgiyi alırdın. Ve daha küçük olursa, ve bunu sarı olarak çizgeye çizince Şimdi anlamak için biraz daha fazla bakalım Bu, günlük sıcaklığın ortalamalarını hesaplamaktır. İşte bu denklem tekrar, ve beta'yı 0,9 olarak ayarlayalım ve bunun denk olduğu birkaç denklem yazalım. Yani, uygularken, sizde T var sıfırdan bire, ikiye üçe, T. değerlerini arttırmak Bunu T değerini azaltarak yazdım. Ve bu devam ediyor. O zaman buradaki ilk denklemi alalım. ve V100'ün gerçekte ne olduğunu anlayın. Yani V100 olacak, Bu iki terimi tersine çevireyim o 0.1 kat theta 100 olacak, Bir önceki günde değeri ne olursa olsun 0,9 kat. Şimdi, ama V99 nedir? Eh, biz sadece bu denklemden bağlayacağız. Yani bu sadece 0.1 kat 99 te olacak. ve yine bu iki terimi tersine çevirdim artı 0,9 kat V98. Ama sonra V98 nedir? Eh, sen sadece buradan al. Yani buraya sadece takılabilirsin. 0,1 kat 98. artı 0.9 kat V97 vb. Ve eğer tüm bu terimleri çoğaltırsanız, V100'ün 0.1 kat theta 100 artı olduğunu gösterebilirsiniz. Şimdi, 99'un katsayısına bakalım. 99'UN 0,1 KATI, 99 KATI OLACAK. Şimdi, 98 te katsayıya bakalım. 0,1, 0,9, 0,9. Yani Cebir'i genişletirsek, Bu 0,1 kez 0,1 kare olur, 98 kez. Ve eğer bunu genişletmeye devam ederseniz, Bunun 0,1 kat 0,9 küp olduğunu fark ettiniz. theta 97 artı 0.1, 0,9'dan dördüncüye, theta 96, artı nokta nokta nokta. Yani bu gerçekten özetlemenin bir yoludur ve bu 100 theta'nın ağırlıklı ortalamasıdır. şu anki günlerin sıcaklığı ve aradığımız şey Yılın 100. gününde hesapladığınız bir V100 perspektifi. Ama bunlar theta 100'ün toplamı. Theta 99, Theta 98, theta 97, theta 96, vb. Yani resimlerde çizmenin bir yolu, eğer Diyelim ki, birkaç gün sıcaklığa sahibiz. Yani bu theta ve bu da T.. Yani 100 te toplam değer olacak. o zaman theta 99, toplam değer olacaktır. Theta 98, yani bunlar yani bu 100'e eşittir, 99, 98 vb. Sıcaklık günlerinin toplam sayısının oranı. Ve sahip olduğumuz şey, üstel olarak çürüyen bir işlevdir. Yani 0,1'den 0,9'a kadar 0,1 ila 0,9 kare çarpı 0,1, vb. Yani bu üssel olarak çürüyen işlevi var. Ve V100'ü hesapladığınız yol, Bu iki fonksiyon arasında elementi ele geçirip özetliyor musunuz? Yani bu değeri alırsınız, theta 100 kere 0.1, theta bu değerin 99 katı 0,1 kat, 0,9 kat, Bu ikinci dönem ve böyle devam ediyor. Yani gerçekten günlük sıcaklığı alıyor, Bu üssel olarak çürüyen işlevle çarpın ve sonra toplayın. Ve bu senin V100'ün olur. Şekline dönüştü, daha sonra detaylara kadar. Ama bütün bu katsayılar, birine ekleyin veya birine çok yakın ekleyin, Bir sonraki videoda konuşacağımız ön yargı düzeltme adı verilen bir detay kadar. Ama bunun nedeni, bu gerçekten katlanarak ağırlıklı bir ortalama. Sonunda merak edebilirsin, Bu, ortalama kaç gündür. Şey, o 0,9'un gücü 10'a çıkıyor. yaklaşık 0.35 ve bu E üzerinde bir tane olduğu ortaya çıkıyor, doğal algoritmaların temellerinden biri. Ve daha genel olarak, bir eksi epsilon varsa, bu örnekte, epsilon 0.1 olurdu, Bu 0,9 ise, epsilon üzerinde bir eksi epsilon. Bu E üzerinde bir tane, Bu yaklaşık 0,34, 0,35. Ve başka bir deyişle, Bunun yüksekliği için yaklaşık 10 gün sürer zirveden E'nin 1 / 3'üne kadar çürüyor. Yani bunun sebebi beta 0,9'a eşit olduğu zaman, bu bilgisayar gibi çalışıyorsun Son 10 gün sıcaklığına odaklanan katlanarak ağırlıklı bir ortalama. Çünkü 10 gün sonra kilo azalır Mevcut günün ağırlığının üçte birinden azına. Oysa, aksine, beta 0.98'e eşitse, Öyleyse, peki, bunun gerçekten küçük olması için 0.98'in gücüne ne ihtiyacın var? Bunun 0.98'inin gücünün yaklaşık 50 olacağı ortaya çıkıyor. E üzerinde bir eşittir. Yani güzel olmanın yolu İlk 50 gün boyunca büyük bir E'den büyük olacak, ve sonra bunun üzerinde oldukça hızlı bir şekilde çürümeye gidecekler. Sezgisel olarak, bu zor ve hızlı şey, Bunu yaklaşık 50 gün boyunca ortalama olarak düşünebilirsiniz. Çünkü, bu örnekte, gösterimi solda kullanmak için epsilon 0,02'ye eşitse, epsilon üzerinde bir kişi 50'dir. Ve bu, bu arada, formülü nasıl aldık? bir eksi beta veya daha fazla gün boyunca bir ortalamanın üzerinde olduğunu tahmin ediyoruz. Tam burada, epsilon 1 eksi beta dizisinin yerini alacak. Bu size, neredeyse sabit bir şekilde nasıl olduğunu söyler. Birçok gün sıcaklık, bunu ortalama olarak düşünmelisiniz. Ama bu, bunun hakkında düşünmek için sadece bir kuraldır. ve resmi bir matematiksel ifade değildir. Son olarak, bunu nasıl uyguladığınız hakkında konuşalım. Sıfır olarak başlatılan V0 üzerinden başlayacağımızı hatırlayın, daha sonra ilk günü V'yi hesaplayın, V2, vb. Şimdi, algoritmayı açıklamak, V0’ı yazmak faydalı oldu V1, V2, vb. Değişken değişkenler. Ama bunu pratikte uyguluyorsanız, Yaptığınız şey bu: V'yi sıfırlamak için V'yi başlatırsanız, ve sonra birincisinde, V eşittir beta'yı ayarlarsınız V, artı bir eksi beta, teta biri. Ve sonra ertesi gün, güncelleme V eklediniz beta V çağrılacak artı 1 eksi beta, theta 2, vb. Ve bazılarını göstermek için not etme V subscript theta kullanır V, bu katsayıya ait theta parametresinin üssel olarak ağırlıklı ortalamasını hesaplamaktadır. Yani bunu tekrar söylemek ama yeni bir format için V theta'yı sıfır olarak ayarladığınızda ve sonra, tekrar tekrar, her gün bir tane var, Sonraki T a, sonra da V’e theta beta olarak güncellendi V theta'nın eski değerini artı bir eksi beta, V theta'nın geçerli değeri. Bu üssel olarak ağırlıklı ortalama formülün avantajlarından biri, bu çok az hafıza gerektiriyor mu. Bilgisayar hafızasında sadece bir satır numarası tutmanız yeterli. ve sahip olduğunuz en son değerlere dayanarak bu formülün üzerine yazmaya devam edersiniz. Ve gerçekten bu sebep, verimlilik, sadece bir satır kod temel alır ve sadece depolama ve bellek Bu üssel ağırlıklı ortalama hesaplamak için tek bir satır numarası. Bu gerçekten en iyi yol değil, Bir ortalama hesaplamak için en doğru yol değil. Hareket eden bir pencereyi hesaplayacak olsaydınız, Son 10 gün içinde açıkça topladığınız yer, son 50 gün sıcaklık ve sadece 10 ile bölmek veya 50 ile bölmek, Bu genellikle size daha iyi bir tahmin verir. Ama bunun dezavantajı, tüm sıcaklıkları açık bir şekilde tutmak ve Son 10 günün toplamı daha fazla hafıza gerektiriyor. ve uygulamak için sadece daha karmaşık ve hesaplama daha pahalı. Bu yüzden, birkaç video için birkaç örnek göreceğiz. Çok sayıda değişkenin ortalamalarını hesaplamanız gereken yer. Bu, hem hesaplamadan hem de bunu yapmak için çok verimli bir yoldur ve hafıza verimliliği açısından çok fazla makine öğreniminde kullanılmasının nedeni budur. Sadece bir satır kodun söz konusu olduğu söylenemez, belki başka bir avantajdır. Yani, şimdi, katlanarak ağırlıklı ortalamaları nasıl uygulayacağınızı biliyorsunuz. Bilmen için bir daha teknik detay var. denilen bias(unıt ek girdi) düzeltme hakkında. Bir sonraki videoda görelim, ondan sonra Bunu yapmak için kullanacaksın düz ileriye doğru daha iyi bir optimizasyon algoritması oluşturmak