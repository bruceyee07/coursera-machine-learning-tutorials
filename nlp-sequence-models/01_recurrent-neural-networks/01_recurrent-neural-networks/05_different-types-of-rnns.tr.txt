Bu zamana kadar gördüğünüz RNN mimarisinde girişlerin sayısı, Tx, çıkışların sayısına yani Ty'ye eşitti. Görülen o ki, başka uygulamalar için, Tx ve Ty her zaman aynı olmayabilir, ve bu videoda, daha geniş RNN mimarileri göreceksiniz. Bu sunumu, bu haftanın ilk videosundan hatırlıyor olabilirsiniz. Burada x girişi ve y çıkışı farklı tiplerde olabiliyordu. Ve her zaman Tx'in Ty ile eşit olması gerekmiyor. Özel olarak bu örnekte, Tx bir uzunluklu olabileceği gibi, boş da olabilir. Ve, film değerlendirme sınıflandırması gibi bir örnekte, y çıkışı sadece 1'den 5'e kadar bir tamsayı olabilirdi. Giriş bir dizi olmasına rağmen... Ve varlık ismi tanımlama (name entity recognition) için kullandığımız örnekte, giriş uzunluğu ve çıkış uzunluğu aynı olacak şekildedir. Giriş uzunluğu ve çıkış uzunluğunun farklı olduğu hallerde bazı problemler yaşanabilmektedir. Bunların hepsi bizim dizilerimiz ancak uzunlukları farklı durumda... Bu, Fransızca bir cümlenin İngilizce bir cümle ile iki farklı sayıda kelimeye sahip olup aynı şeyi anlatan bir makine çevirisi gibidir. Bu durumda yapabileceğimiz şey, temel RNN mimarisi ile tüm bu problemlere çözüm bulmaktır. Bu videodaki sunumda, Andrej Karpathy'nin Tekrarlı Sinir Ağlarının Anlamsız Etkenliği (The Unreasonable Effectiveness of Recurrent Neural Networks) başlıklı blog yazısından esinlenilmiştir. Bazı örnekler üzerinde konuyu inceleyelim. Bu zamana kadar gördüğünüz örnekte Tx, Ty'ye eşitti. Burada bir giriş dizisi x(1), x(2), .... , x(Tx) elemanlarına sahip olup, bir tekrarlayan sinir ağı (recurrent neural network) mevcuttur. Bu ağ şu şekilde çalışmaktadır: x(1) girişimiz ile birlikte y şapka (1), y şapka (2) ve bunun gibi y(Ty)'ye kadar devam. Bundan önceki diyagramlarda, nöronları göstermek için çemberler çiziyordum, ancak bu videonun büyük kısmında bu küçük çemberleri kullanacağım. Bu, gösterimi daha basit bir hale getirmektedir. Buna çoktan çoğa (many-to-many) mimarisi diyebilirsiniz. Çünkü giriş dizisinde bir çok giriş vardır, ve çıkış dizisinde bir çok çıkış bulunmaktadır. Şimdi, farklı bir örneği inceleyelim. Diyelim ki, bir duygu sınıflandırmasını adreslemek istiyorsunuz. Burada, x bir metin parçası olabilir. Bu, bir film değerlendirmesi olabilir ve diyebilir ki, "Bu filmde beğenilecek hiç bir şey yok." Bu durumda x, dizi haline gelecek, ve y, 1'den 5'e kadar bir sayı olacaktır. 0 veya 1 de olabilir. Bu, pozitif bir değerlendirme veya negatif bir değerlendirmedir. Veya 1-5 arasında bir sayı da olabilir. Sizce bu film bir yıldız mı alır, iki yıldız mı, üç, dört veya beş yıldız mı alır? Yani bu durumda, sinir ağı mimarisini aşağıdaki şekilde basitleştirebiliriz. x(1) ve x(2)'yi giriş olarak alacağım. Bu sayede kelimeleri bir seferde girmiş olacağım. Böylece girilen metin şu olsaydı, "There is nothing to like in this movie." Bu şekilde giriş, "There is nothing to like in this movie." olacaktı. Ve her bir zaman biriminde bir çıkış kullanmak gerekiyor olması yerine, RNN'nin tüm cümleyi okumasını ve tüm cümleyi almış olduğundan çıkışı son zaman biriminde y olarak vermesini sağlayabiliriz. Böylece, bu sinir ağı, bir çoktan-bire (many to one) mimari olabilirdi. Çünkü çok girişli bir sistemde, bir çok kelime girişi olmasına rağmen, tek bir çıkış olmaktadır. Bütünlüğü sağlamak adına, birden-bire (one to one) mimari de mevcuttur. Bu durum için daha az ilgi çekici diyebiliriz. Standart sinir ağı ne kadar küçük olursa, bir kaç x girişi ile sadece bir kaç y çıkışı alabiliyoruz. Ve bu bahsettiğimiz sinir ağı tipleri, bu dizide ilk iki derste bahsedecek olduklarımızdır. Şimdi, çoktan bire'ye ek olarak, birden çoğa mimarisi de mevcuttur. Birden çoğa sinir ağı mimarisinin bir örneği, müzik oluşumudur. Ve gerçekte, bunu kendiniz bu ders için temel örnekte bulunlardan birisi gibi, bir sinir ağı, ve bu nota seti çıktıları ile bir müzik parçasına karşılık gelecek şekilde uygulamanız gerekecektir.. Ve x girişi, sadece bir tamsayı olabilecektir. Bu, bize ne çeşit bir müzik istediğinizi veya istediğiniz müzik parçasının ilk notasının ne olacağını gösterecektir. ve bir giriş olsun istemiyorsanız, x boş bir giriş de olabilir, hepsi sıfır vektörlerden de oluşabilir. Bunun için, sinir ağı mimarisi, sizin x girişiniz olacaktır. Ve RNN çıkışınız olacaktır. İlk değer, ve sonra, daha fazla giriş ve çıkış olmayacaktır. İkinci değer ve çıkışa kadar devam. Üçüncü değer ve bu şekilde, müzik parçasının son notalarını oluşturana kadar gider. İsterseniz, bu girişi a(0) olarak da alabilirsiniz. Bir sonraki videoda göreceğiniz bir teknik konu da şudur: Gerçekten diziler oluştururken, genellikle bu ilk oluşan çıkışı alıp bir sonraki katmana giriş olarak kullanırsınız. Böylece, ağ mimarisi bu şekle dönüşür. Çoktan çoka ile ilgili çok konuştuk. Çoktan bire, birden çoğa ve birden bire için de aynı şekilde... Burada bahsedilmesi gereken ve ilginç olan bir çoktan çoğa örneği daha mevcuttur. O da, giriş ve çıkış uzunluklarının farklı olması durumudur. Çoktan çoğa örneğinde, biraz önce görmüştünüz, giriş uzunluğu ve çıkış uzunluğu tam olarak aynı olmak zorundaydı. Makine çevirisi gibi bir uygulama için, giriş cümlesindeki kelime sayısı, diyelim ki Fransızca bir cümle olsun, ve çıkış cümlesindeki kalime sayısı, diyelim ki tercüme İngilizce'ye yapılsın, bu cümleler farklı uzunluklarda olabilecektir. Bu durumda, bir sinir ağı oluşturabileceğiniz alternatif yeni bir ağ mimarisi vardır. İlk olarak cümleyi okursunuz. Yani ilk olarak girişi okursunuz, diyelim ki İngilizce'ye çevirmek istediğiniz Fransız cümleyi... Ve bunu yaptıktan sonra, çevirinin sinir ağı çıktısına sahip olursunuz. y'nin tüm (Ty) şapkalı halleri gibi... Ve bu şekilde, bu mimari ile birlikte, Tx ve Ty farklı uzunluklarda olabilir. Ve yine, a(0) üzerine çizebilirsiniz [duyulmaz]. Ve böylece, bu kolineer ağ mimarisinin iki ayrı parçası bulunacaktır. Girişi kabul eden kodlayıcı mevcut olacaktır, giriş Fransızca bir cümle olsun diyelim, bir kod çözücü olacaktır, bu çözücü cümleyi okuyacak ve tercümeyi farklı bir ilde çıkış olarak verecektir. Bu, çoktan çoka mimari için bir örnektir. Böylece, bu haftanın sonunda, bu tip mimariler oluşturmak için gereken tüm bileşenleri öğrenmiş oluyorsunuz. Ve teknik olarak, sadece dördüncü hafta bahsedecek olduğumuz diğer bir mimari de mevcuttur. Bu da dikkat tabanlı (attention-based) mimaridir. Bu konu, bu zamana kadar yaptığımız çizimlerde tam olarak kapsanmamış olabilir. Son olarak geniş RNN mimari çeşitlerini özetlemek gerekirse, birden bire vardır. Birden bire olsa bile, ona bunu verebilirdik, bu, sadece standart bir sinir ağıdır. Aslında bunun için bir RNN'ye ihtiyacınız yoktur. Ancak birden çoğa mimari mevcuttur. Buna örnek olarak müzik oluşturma veya dizi oluşturmayı göstermiştik. Ve sonra, çoktan bire mimari vardır. Buna örnek, değerlendirmelerin sınıflandırmasıydı. Burada, tüm metni bir film değerlendirmesi ile okumak isteyebilirsiniz. Sonra, filmi beğenip beğenmediklerini buradan çıkartmaya çalışırsınız. Çoktan çoğa vardı, isim algılama ve buradaki örnekte Tx, Ty'ye eşitti. Son olarak, çoktan çoğa mimarinin bu diğer versiyonu bulunmaktadır. Bu versiyonda makine çevirisi tarzı uygulamalar mevcut olup, Tx ve Ty'nin birbirine aynı olmasına gerek kalmıyordu. Bu durumda şu anda siz artık yapı taşlarının çoğunu biliyor haldesiniz. Ve işin geneli, bu sinir ağlarından oluşmaktadır. Sadece dizi oluşturma için işin bazı incelikleri hariç... Bu konuyu bir sonraki videoda tartışacağız. Umuyorum ki bu videoda bir RNN'nin temel yapı taşlarını kullanarak bir araya getirebileceğiniz çok geniş yelpazede model bulunduğunu görmüşsünüzdür. Ancak daha önce belirtmiş olduğum gibi, dizi oluşturma için bazı incelikler mevcuttu. Bunları sizin kendiniz halletmeniz gerekiyordu. Bu haftanın ilk örneğindeki gibi bir dil modeli oluşturup sonrasında umuyorum ki bazı eğlenceli diziler veya bazı eğlenceli metin parçaları oluşturacaksınız. Bir sonraki videoda yapmak istediğim şey, dizi oluşturma işinin daha derinlerine girmektir. Detayları bir sonraki videoda göreceğiz.