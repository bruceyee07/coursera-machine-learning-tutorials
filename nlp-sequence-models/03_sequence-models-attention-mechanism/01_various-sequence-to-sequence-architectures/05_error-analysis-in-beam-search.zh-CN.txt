在这一系列五门课程中的第三门课当中
你知道错误分析是如何帮助你， 把你的时间集中在完成对你的项目而言
最有用的工作上。 现在，定向搜索是一个搜索算法， 也称为启发式搜索算法。 所以它并不总是输出最有可能性的句子。 它只跟踪记录 B 等于3或10或100最高可能性。 所以，如果定向搜索产生了错误怎么办？ 在这个视频中, 你将了解错误分析如何与定向搜索相结合, 而且如何找出是否是定向搜索算法的问题， 值不值得花时间在上面。 或者这可不可能是你的RNN模型导致了问题 是否值得花时间。 让我们来看看如何使用定向搜索进行错误分析。 让我们用“Jane visite l'Afrique en septembre”
这句话作为例子。 举例来说，在你的机器翻译的开发集 人类提供了如下翻译 简在九月访问了非洲，
我将称呼这个翻译为Y*。 所以这是一个人写的质量很高的翻译。 比如说，当你在你训练好了的RNN模型上
运行定向搜索时， 也就是说你训练好的翻译模型，
它最终给出这样的翻译， 我们称之为y^, 简去年九月访问了非洲。 这是对那个法语句子是更糟糕的翻译。 它其实改变了本身的含义,
因此它不是一个好的翻译。 现在，你的模型有两个主要的组成部分 有一个神经网络模型,
这个序列到序列的模型。 我们就把这个叫做你的 RNN 模型。 这实际上是一个编码器加一个解码器。 并且你有你的定向搜索算法， 你用一些束宽度 B来运行它。 这将会非常好，如果你能把这个错误， 也就是说这个不是很好的翻译的原因，
归因到这两个组成部分中的一个？ 是 RNN 或者说实际上神经网络, 更有责任, 还是定向搜索算法，有更多的责任呢？ 你在这一序列的第三门课中看到的是, 总是倾向于收集更多的数据不是件坏事。 同样的，总是倾向于增加定向宽度也 不会有问题，或者说几乎不会有问题。 但获得更多的训练数据本身可能并不能 使你获得你想要的（翻译）表现水平。 本例中 我们分秒必争 增加定向宽度本身可能不会使你达成你的目的。 但你如何决定改进搜索算法 是否是对你时间的恰当利用呢？ 这就是你该如何拆分这个问题，并且 弄清什么才是对你时间的恰当利用。 现在，RNN，也就是神经网络， 实际上就是编码器加上解码器。 它计算 P(y|x)。 举例而言，对一个句子，
“Jane visits Africa in September” 你插入“jane”,"visits","africa"。 同样,我现在忽略了大小写的区别,对,继续。 计算 P(y|x)。 所以事实证明,对你现在而言， 最重要的事是用这个模型去计算 P(y*|x) 和计算 P(y^|x)。 然后看这两者中哪一个更大。 因此,左端可能比右端大。 P(y*|x) < P(y^|x)也是有可能的， 实际上小于或等于，对吗？ 根据这两种情况中的哪一个是正确的,你可以更 清楚地把这个特殊的错误,这个特别差的翻译 归因于 RNN 或者定向搜索算法中的一个有更多的问题。 因此,让我们理一理这背后的逻辑。 以下是之前幻灯片中的两个句子。 记住,我们要计算 P(y*|x) 和 P(y^|x),看其中哪个更大。 所以这会有两种情况， 在第一种情况中，P(y*|x) 作为 RNN模型的输出 比P(y^|x)大。 这是什么意思呢这是什么意思呢 定向搜索算法选择了y^,对吗？ 你得到 y^ 因为你有一个在计算 P(y|x) 的RNN。 而定向搜索的任务是试图找到
一个y的值使之给出函数的最大值。 但在这个情况下，y* 其实比 y^ 给出了更高的 P(y|x) 值。 所以, 这让你得出的结论是定向搜索其实并没有 给你最大化 P(y|x) 的那个 y 的值， 因为定向搜索的一个任务
就是找到使得函数值非常大的 y。 但它选择了 y^，而 y* 实际上得到了更高的值。 所以在这个情况下，你可以总结出定向搜索有问题。 那另外一种情况怎么样呢？ 在第二种情况中, P(y*|x) 小于或 等于 P(y^|x), 对吗？ 然后要么这个或者这个一定是对的。 所以要么情况1要么情况2会是对的。 你在情况2中能得出什么结论呢？ 在我们的例子中, 相比于 y^ , y* 是一个更好的翻译。 但根据 RNN, P(y*) 小于 P(y^), 所以说，相比于 y^，y* 是一个
不太可能的输出结果。 因此,在这种情况下,似乎 RNN 模型是 有问题的,而且也许值得花更多的时间在 RNN 上。 这里我掩盖了一些有关 长度归一化的小问题。 这里我掩盖了一些有关 长度归一化的小问题。 如果你进行了一些长度归一化, 相比于评估这些概率，你更应该评估 考虑了长度归一化的优化对象。 但是我们先忽略这一复杂问题,
在这种情况下,这告诉你的是, 虽然 y* 是一个更好的翻译, RNN 给了 y* 比推测出来的翻译的概率更低。 因此,这种情况下, 我会说, RNN 模型是有问题的。 因此,错误分析过程如下所示。 你仔细查看开发集并且 找出算法在开发集中所犯的错误。 在这个例子中, 假设 P(y*|x) 是 2 x 10 到 10, 然而, P(y^|x) 是 1 x 10 到10。 使用上一张幻灯片中的逻辑,在这种情况下, 我们看到 定向搜索实际上选择了 y^,它的概率比 y* 低。 所以我会说定向搜索是错误的。 所以我缩写它为 B。 然后你看第二个错误或 算法给出的第二个错误输出,看看这些概率。 也许第二个例子,你认为模型是错误的。 我将用 R 缩写 RNN 模型。 你遇到更多的例子。 有时束搜索是问题所在,有时模型是问题所在, 等等很多项等等很多项 通过这个过程,你可以通过错误分析来找出 哪一部分问题是束搜索的，
哪一部分是 RNN 模型的。 有这样的错误分析过程,
对于你开发集中的每个示例, 如果算法给出的输出比人类翻译的差得多, 你可以尝试将错误归因于搜索算法或 目标函数,或者生成目标函数的 RNN 模型， 因为定向搜索的目标函数值应该是最大化的。 通过这一方法,
你可以尝试找出这两个组成部分中的哪个 应该承担更多的错误。 只有当你发现定向搜索导致了很多错误时, 也许我们应该努力增加束宽度。 反之,如果你发现 RNN 模型是错误所在, 那你可以做更深的一层或者分析试图找出要不要 加上正则化，或者获取更多的训练数据， 或者尝试一个不同的网络结构等等。 所以你在第三门课程中看到的许多技术， 会在序列这里得到应用 这就是用定向搜索进行误差分析的方法。 我发现这个特殊的错误分析
过程非常有用,每当你有 一种近似优化算法,像定向搜索这样 用来优化某种目标,某种 由一个学习算法输出的代价函数，
例如一个序列到序列的模型 或者我们在讲座中讨论过的序列到序列的RNN。 因此,我希望有了这个方法(错误分析)，
你将能更有效地建立这些类型的模型 或者对你的应用有帮助。