1
00:00:00,210 --> 00:00:05,570
在这一系列五门课程中的第三门课当中
你知道错误分析是如何帮助你，

2
00:00:05,570 --> 00:00:11,110
把你的时间集中在完成对你的项目而言
最有用的工作上。

3
00:00:11,110 --> 00:00:14,122
现在，定向搜索是一个搜索算法，

4
00:00:14,122 --> 00:00:16,500
也称为启发式搜索算法。

5
00:00:16,500 --> 00:00:20,439
所以它并不总是输出最有可能性的句子。

6
00:00:20,439 --> 00:00:26,140
它只跟踪记录 B 等于3或10或100最高可能性。

7
00:00:26,140 --> 00:00:29,180
所以，如果定向搜索产生了错误怎么办？

8
00:00:29,180 --> 00:00:33,888
在这个视频中, 你将了解错误分析如何与定向搜索相结合,

9
00:00:33,888 --> 00:00:38,457
而且如何找出是否是定向搜索算法的问题，

10
00:00:38,457 --> 00:00:40,722
值不值得花时间在上面。

11
00:00:40,722 --> 00:00:44,350
或者这可不可能是你的RNN模型导致了问题

12
00:00:44,350 --> 00:00:46,290
是否值得花时间。

13
00:00:46,290 --> 00:00:50,580
让我们来看看如何使用定向搜索进行错误分析。

14
00:00:50,580 --> 00:00:56,550
让我们用“Jane visite l'Afrique en septembre”
这句话作为例子。

15
00:00:56,550 --> 00:01:00,110
举例来说，在你的机器翻译的开发集

16
00:01:00,110 --> 00:01:04,202
人类提供了如下翻译

17
00:01:04,202 --> 00:01:08,311
简在九月访问了非洲，
我将称呼这个翻译为Y*。

18
00:01:08,311 --> 00:01:11,975
所以这是一个人写的质量很高的翻译。

19
00:01:11,975 --> 00:01:16,367
比如说，当你在你训练好了的RNN模型上
运行定向搜索时，

20
00:01:16,367 --> 00:01:20,545
也就是说你训练好的翻译模型，
它最终给出这样的翻译，

21
00:01:20,545 --> 00:01:24,506
我们称之为y^, 简去年九月访问了非洲。

22
00:01:24,506 --> 00:01:28,262
这是对那个法语句子是更糟糕的翻译。

23
00:01:28,262 --> 00:01:32,682
它其实改变了本身的含义,
因此它不是一个好的翻译。

24
00:01:32,682 --> 00:01:35,981
现在，你的模型有两个主要的组成部分

25
00:01:35,981 --> 00:01:40,833
有一个神经网络模型,
这个序列到序列的模型。

26
00:01:40,833 --> 00:01:43,626
我们就把这个叫做你的 RNN 模型。

27
00:01:43,626 --> 00:01:45,986
这实际上是一个编码器加一个解码器。

28
00:01:45,986 --> 00:01:49,268
并且你有你的定向搜索算法，

29
00:01:49,268 --> 00:01:52,934
你用一些束宽度 B来运行它。

30
00:01:52,934 --> 00:01:56,408
这将会非常好，如果你能把这个错误，

31
00:01:56,408 --> 00:02:00,240
也就是说这个不是很好的翻译的原因，
归因到这两个组成部分中的一个？

32
00:02:00,240 --> 00:02:04,812
是 RNN 或者说实际上神经网络, 更有责任,

33
00:02:04,812 --> 00:02:08,662
还是定向搜索算法，有更多的责任呢？

34
00:02:08,662 --> 00:02:12,246
你在这一序列的第三门课中看到的是,

35
00:02:12,246 --> 00:02:17,170
总是倾向于收集更多的数据不是件坏事。

36
00:02:17,170 --> 00:02:21,665
同样的，总是倾向于增加定向宽度也

37
00:02:21,665 --> 00:02:23,700
不会有问题，或者说几乎不会有问题。

38
00:02:23,700 --> 00:02:28,890
但获得更多的训练数据本身可能并不能

39
00:02:28,890 --> 00:02:31,470
使你获得你想要的（翻译）表现水平。

40
00:02:31,470 --> 00:02:32,490
本例中 我们分秒必争

41
00:02:32,490 --> 00:02:37,540
增加定向宽度本身可能不会使你达成你的目的。

42
00:02:38,570 --> 00:02:40,580
但你如何决定改进搜索算法

43
00:02:40,580 --> 00:02:44,325
是否是对你时间的恰当利用呢？

44
00:02:44,325 --> 00:02:46,917
这就是你该如何拆分这个问题，并且

45
00:02:46,917 --> 00:02:50,012
弄清什么才是对你时间的恰当利用。

46
00:02:50,012 --> 00:02:52,339
现在，RNN，也就是神经网络，

47
00:02:52,339 --> 00:02:56,263
实际上就是编码器加上解码器。

48
00:02:56,263 --> 00:03:02,248
它计算 P(y|x)。

49
00:03:02,248 --> 00:03:07,268
举例而言，对一个句子，
“Jane visits Africa in September”

50
00:03:07,268 --> 00:03:11,850
你插入“jane”,"visits","africa"。

51
00:03:11,850 --> 00:03:15,741
同样,我现在忽略了大小写的区别,对,继续。

52
00:03:15,741 --> 00:03:18,810
计算 P(y|x)。

53
00:03:18,810 --> 00:03:22,965
所以事实证明,对你现在而言，

54
00:03:22,965 --> 00:03:28,804
最重要的事是用这个模型去计算

55
00:03:28,804 --> 00:03:36,840
P(y*|x) 和计算 P(y^|x)。

56
00:03:36,840 --> 00:03:39,570
然后看这两者中哪一个更大。

57
00:03:39,570 --> 00:03:43,120
因此,左端可能比右端大。

58
00:03:43,120 --> 00:03:47,744
P(y*|x) < P(y^|x)也是有可能的，

59
00:03:47,744 --> 00:03:48,776
实际上小于或等于，对吗？

60
00:03:48,776 --> 00:03:53,481
根据这两种情况中的哪一个是正确的,你可以更

61
00:03:53,481 --> 00:03:58,511
清楚地把这个特殊的错误,这个特别差的翻译

62
00:03:58,511 --> 00:04:04,010
归因于 RNN 或者定向搜索算法中的一个有更多的问题。

63
00:04:04,010 --> 00:04:07,252
因此,让我们理一理这背后的逻辑。

64
00:04:07,252 --> 00:04:09,550
以下是之前幻灯片中的两个句子。

65
00:04:09,550 --> 00:04:14,460
记住,我们要计算 P(y*|x) 和

66
00:04:14,460 --> 00:04:19,870
P(y^|x),看其中哪个更大。

67
00:04:19,870 --> 00:04:21,196
所以这会有两种情况，

68
00:04:21,196 --> 00:04:26,184
在第一种情况中，P(y*|x) 作为 RNN模型的输出

69
00:04:26,184 --> 00:04:31,360
比P(y^|x)大。

70
00:04:31,360 --> 00:04:32,140
这是什么意思呢这是什么意思呢

71
00:04:32,140 --> 00:04:37,778
定向搜索算法选择了y^,对吗？

72
00:04:37,778 --> 00:04:44,194
你得到 y^ 因为你有一个在计算 P(y|x) 的RNN。

73
00:04:44,194 --> 00:04:50,390
而定向搜索的任务是试图找到
一个y的值使之给出函数的最大值。

74
00:04:51,500 --> 00:04:57,389
但在这个情况下，y* 其实比 y^

75
00:04:57,389 --> 00:05:00,720
给出了更高的 P(y|x) 值。

76
00:05:00,720 --> 00:05:05,340
所以, 这让你得出的结论是定向搜索其实并没有

77
00:05:05,340 --> 00:05:10,980
给你最大化 P(y|x) 的那个 y 的值，

78
00:05:10,980 --> 00:05:15,850
因为定向搜索的一个任务
就是找到使得函数值非常大的 y。

79
00:05:15,850 --> 00:05:19,660
但它选择了 y^，而 y* 实际上得到了更高的值。

80
00:05:19,660 --> 00:05:23,601
所以在这个情况下，你可以总结出定向搜索有问题。

81
00:05:24,750 --> 00:05:26,219
那另外一种情况怎么样呢？

82
00:05:26,219 --> 00:05:30,438
在第二种情况中, P(y*|x) 小于或

83
00:05:30,438 --> 00:05:34,319
等于 P(y^|x), 对吗？

84
00:05:34,319 --> 00:05:37,410
然后要么这个或者这个一定是对的。

85
00:05:37,410 --> 00:05:40,530
所以要么情况1要么情况2会是对的。

86
00:05:40,530 --> 00:05:43,820
你在情况2中能得出什么结论呢？

87
00:05:43,820 --> 00:05:47,095
在我们的例子中,

88
00:05:47,095 --> 00:05:51,490
相比于 y^ , y* 是一个更好的翻译。

89
00:05:51,490 --> 00:05:57,081
但根据 RNN, P(y*) 小于 P(y^),

90
00:05:57,081 --> 00:06:02,670
所以说，相比于 y^，y* 是一个
不太可能的输出结果。

91
00:06:02,670 --> 00:06:07,810
因此,在这种情况下,似乎 RNN 模型是

92
00:06:07,810 --> 00:06:12,440
有问题的,而且也许值得花更多的时间在 RNN 上。

93
00:06:13,510 --> 00:06:16,310
这里我掩盖了一些有关

94
00:06:16,310 --> 00:06:18,970
长度归一化的小问题。

95
00:06:18,970 --> 00:06:23,487
这里我掩盖了一些有关

96
00:06:23,487 --> 00:06:24,520
长度归一化的小问题。

97
00:06:24,520 --> 00:06:28,330
如果你进行了一些长度归一化,

98
00:06:28,330 --> 00:06:32,880
相比于评估这些概率，你更应该评估

99
00:06:32,880 --> 00:06:36,620
考虑了长度归一化的优化对象。

100
00:06:36,620 --> 00:06:41,048
但是我们先忽略这一复杂问题,
在这种情况下,这告诉你的是,

101
00:06:41,048 --> 00:06:46,830
虽然 y* 是一个更好的翻译,

102
00:06:46,830 --> 00:06:53,142
RNN 给了 y* 比推测出来的翻译的概率更低。

103
00:06:53,142 --> 00:06:57,570
因此,这种情况下, 我会说, RNN 模型是有问题的。

104
00:06:57,570 --> 00:07:01,460
因此,错误分析过程如下所示。

105
00:07:01,460 --> 00:07:03,572
你仔细查看开发集并且

106
00:07:03,572 --> 00:07:07,270
找出算法在开发集中所犯的错误。

107
00:07:08,300 --> 00:07:16,103
在这个例子中, 假设 P(y*|x) 是 2 x 10 到 10,

108
00:07:16,103 --> 00:07:21,610
然而, P(y^|x) 是 1 x 10 到10。

109
00:07:21,610 --> 00:07:26,746
使用上一张幻灯片中的逻辑,在这种情况下, 我们看到

110
00:07:26,746 --> 00:07:32,725
定向搜索实际上选择了 y^,它的概率比 y* 低。

111
00:07:32,725 --> 00:07:35,220
所以我会说定向搜索是错误的。

112
00:07:35,220 --> 00:07:36,348
所以我缩写它为 B。

113
00:07:36,348 --> 00:07:39,440
然后你看第二个错误或

114
00:07:39,440 --> 00:07:43,390
算法给出的第二个错误输出,看看这些概率。

115
00:07:43,390 --> 00:07:47,150
也许第二个例子,你认为模型是错误的。

116
00:07:47,150 --> 00:07:50,045
我将用 R 缩写 RNN 模型。

117
00:07:50,045 --> 00:07:52,253
你遇到更多的例子。

118
00:07:52,253 --> 00:07:57,037
有时束搜索是问题所在,有时模型是问题所在,

119
00:07:57,037 --> 00:07:57,720
等等很多项等等很多项

120
00:07:58,760 --> 00:08:04,530
通过这个过程,你可以通过错误分析来找出

121
00:08:04,530 --> 00:08:10,560
哪一部分问题是束搜索的，
哪一部分是 RNN 模型的。

122
00:08:10,560 --> 00:08:16,660
有这样的错误分析过程,
对于你开发集中的每个示例,

123
00:08:16,660 --> 00:08:23,450
如果算法给出的输出比人类翻译的差得多,

124
00:08:23,450 --> 00:08:28,230
你可以尝试将错误归因于搜索算法或

125
00:08:28,230 --> 00:08:32,350
目标函数,或者生成目标函数的 RNN 模型，

126
00:08:32,350 --> 00:08:37,240
因为定向搜索的目标函数值应该是最大化的。

127
00:08:37,240 --> 00:08:41,340
通过这一方法,
你可以尝试找出这两个组成部分中的哪个

128
00:08:41,340 --> 00:08:43,470
应该承担更多的错误。

129
00:08:43,470 --> 00:08:46,940
只有当你发现定向搜索导致了很多错误时,

130
00:08:46,940 --> 00:08:51,300
也许我们应该努力增加束宽度。

131
00:08:51,300 --> 00:08:55,080
反之,如果你发现 RNN 模型是错误所在,

132
00:08:55,080 --> 00:08:59,350
那你可以做更深的一层或者分析试图找出要不要

133
00:08:59,350 --> 00:09:02,571
加上正则化，或者获取更多的训练数据，

134
00:09:02,571 --> 00:09:06,164
或者尝试一个不同的网络结构等等。

135
00:09:06,164 --> 00:09:10,597
所以你在第三门课程中看到的许多技术，

136
00:09:10,597 --> 00:09:13,505
会在序列这里得到应用

137
00:09:13,505 --> 00:09:17,740
这就是用定向搜索进行误差分析的方法。

138
00:09:17,740 --> 00:09:22,170
我发现这个特殊的错误分析
过程非常有用,每当你有

139
00:09:22,170 --> 00:09:25,870
一种近似优化算法,像定向搜索这样

140
00:09:25,870 --> 00:09:29,690
用来优化某种目标,某种

141
00:09:29,690 --> 00:09:33,120
由一个学习算法输出的代价函数，
例如一个序列到序列的模型

142
00:09:33,120 --> 00:09:37,110
或者我们在讲座中讨论过的序列到序列的RNN。

143
00:09:37,110 --> 00:09:41,840
因此,我希望有了这个方法(错误分析)，
你将能更有效地建立这些类型的模型

144
00:09:41,840 --> 00:09:43,170
或者对你的应用有帮助。