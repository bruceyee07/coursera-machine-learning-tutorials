1
00:00:00,560 --> 00:00:04,440
深度学习算法都希望有大量的训练数据

2
00:00:04,440 --> 00:00:06,970
要使它运转在最佳状态

3
00:00:06,970 --> 00:00:10,294
训练集中要有足量已标记训练数据

4
00:00:10,294 --> 00:00:14,154
这导致很多团队将能找到的任何数据

5
00:00:14,154 --> 00:00:18,120
都塞进训练集<br />只为有更多的训练数据

6
00:00:18,120 --> 00:00:21,720
即使有些 甚至很多这种数据

7
00:00:21,720 --> 00:00:25,870
来自于与开发集和测试集不同的分布

8
00:00:25,870 --> 00:00:30,330
因此在深度学习时代<br />越来越多的团队正在使用的

9
00:00:30,330 --> 00:00:34,325
训练数据并非来自<br />与开发集和测试集相同的分布

10
00:00:34,325 --> 00:00:37,385
针对这种情况

11
00:00:37,385 --> 00:00:41,825
这里有一些需要了解的微妙之处<br />和一些最好的实践方法

12
00:00:41,825 --> 00:00:43,315
让我们一起来看看让我们一起来看看

13
00:00:43,315 --> 00:00:48,630
假设你正在做一个移动应用

14
00:00:48,630 --> 00:00:51,970
用户将从他们的手机上传图片

15
00:00:51,970 --> 00:00:56,470
你想要识别这些图片是不是猫的图片

16
00:00:56,470 --> 00:00:59,580
那么你现在有2个数据源

17
00:00:59,580 --> 00:01:03,940
一个是你真正关心的数据分布

18
00:01:03,940 --> 00:01:07,940
来自于移动应用<br />通常拍摄和构图都不怎么专业

19
00:01:07,940 --> 00:01:12,800
甚至可能是糊的<br />因为他们来自业余用户

20
00:01:12,800 --> 00:01:16,760
另一个数据源是<br />你可以抓取网页 然后下载大量的

21
00:01:16,760 --> 00:01:21,635
在这个例子中是说

22
00:01:21,635 --> 00:01:27,250
你可以下载大量的构图专业的<br />分辨率高的 专业拍摄的猫的图片

23
00:01:27,250 --> 00:01:29,950
假设你的移动应用还没有很多用户

24
00:01:29,950 --> 00:01:35,632
也许你有10,000张<br />从移动应用上传的照片

25
00:01:35,632 --> 00:01:40,320
但是通过网页抓取<br />你能下载海量的猫的图片

26
00:01:40,320 --> 00:01:45,322
也许你有200,000张<br />从网络下载的猫的图片

27
00:01:48,079 --> 00:01:53,296
但是你真正期待的是最终系统

28
00:01:53,296 --> 00:01:58,311
处理移动应用上传的<br />图片的分布的表现

29
00:01:58,311 --> 00:02:01,594
因为最终你的用户<br />将会上传如图右所示的图片

30
00:02:01,594 --> 00:02:04,230
你需要你的分类器<br />在这些图片上表现足够好

31
00:02:04,230 --> 00:02:08,500
但是现在你有些为难

32
00:02:08,500 --> 00:02:12,970
因为你的数据集比较小<br />只有10,000个样例来自这个分布

33
00:02:12,970 --> 00:02:16,754
而大得多的数据集来自于另外的分布

34
00:02:16,754 --> 00:02:19,986
它的图片与你的目标分布<br />看上去并不一样

35
00:02:19,986 --> 00:02:24,505
所以你不希望只用10,000个图片

36
00:02:24,505 --> 00:02:27,330
因为这意味着一个较小的数据集

37
00:02:28,466 --> 00:02:31,724
使用这总共200,000个图片<br />会对这个问题有帮助

38
00:02:31,724 --> 00:02:37,550
两难的是200,000个图片<br />并非来自你的目标分布

39
00:02:37,550 --> 00:02:38,496
那么你能怎么做呢？

40
00:02:38,496 --> 00:02:43,340
这里有个方案

41
00:02:43,340 --> 00:02:47,669
你可以将这些数据集放在一起

42
00:02:47,669 --> 00:02:50,910
这样就有了210,000个图片

43
00:02:50,910 --> 00:02:56,835
然后将这210,000个图片随机混合

44
00:02:56,835 --> 00:03:03,470
得到训练/开发/测试集

45
00:03:03,470 --> 00:03:07,020
为讨论方便 假设你的

46
00:03:07,020 --> 00:03:11,380
开发集和测试集各包含2,500个样例

47
00:03:11,380 --> 00:03:16,360
那么训练集则包含205,000个样例

48
00:03:17,450 --> 00:03:23,520
这样的数据分配有其优点和缺点

49
00:03:23,520 --> 00:03:26,910
优点是这样一来你的训练/开发/测试集

50
00:03:26,910 --> 00:03:30,400
都来自于同一分布 易于管理

51
00:03:30,400 --> 00:03:33,470
而缺点 一个巨大的缺点是

52
00:03:33,470 --> 00:03:38,010
仔细看看你的开发集<br />它有2,500个样例

53
00:03:38,010 --> 00:03:43,570
但是大部分来自网页图片的分布

54
00:03:43,570 --> 00:03:46,660
而不是你真正关心的<br />来自移动应用图片的分布

55
00:03:48,520 --> 00:03:53,150
也就是说210,000个样例中的200,000个

56
00:03:53,150 --> 00:03:57,309
我将200,000简写为200k<br />210,000简写为210k

57
00:03:57,309 --> 00:04:01,169
来自于网页

58
00:04:01,169 --> 00:04:06,951
那么2,500个样例中

59
00:04:06,951 --> 00:04:13,430
来自于网页的数量的期望值是2381

60
00:04:13,430 --> 00:04:17,580
这是期望 确切的数字将取决于

61
00:04:17,580 --> 00:04:20,290
随机混合的结果

62
00:04:20,290 --> 00:04:25,250
但是平均只有119个样例<br />来自于移动应用上传

63
00:04:27,600 --> 00:04:32,630
请记住 设置开发集的目的是

64
00:04:32,630 --> 00:04:33,800
告诉你的团队该往哪里瞄准

65
00:04:33,800 --> 00:04:35,150
现在你正在瞄准的目标

66
00:04:35,150 --> 00:04:38,080
正在花费大量的时间优化的是

67
00:04:38,080 --> 00:04:41,550
网页图片的分布<br />而这其实不是你想要的

68
00:04:42,780 --> 00:04:45,430
所以我建议不要采用方案一

69
00:04:45,430 --> 00:04:50,010
因为它设置的开发集使你的团队致力于

70
00:04:50,010 --> 00:04:53,160
优化一个与你实际关心的目标<br />并不相同的数据分布

71
00:04:54,210 --> 00:04:56,018
与其这样

72
00:04:56,018 --> 00:05:01,704
我建议你改用另一个方案

73
00:05:01,704 --> 00:05:08,487
假设训练集仍然包含205,000个图片

74
00:05:08,487 --> 00:05:15,985
所有来源于网络的<br />200,000个图片都放进训练集

75
00:05:15,985 --> 00:05:21,970
如果你想 还可以加入<br />来自于移动应用的5,000个图片

76
00:05:21,970 --> 00:05:24,344
你的开发集和测试集

77
00:05:24,344 --> 00:05:27,599
则不必依照这个比例

78
00:05:27,599 --> 00:05:34,993
你的开发集和测试集将包含<br />所有的移动应用图片

79
00:05:38,870 --> 00:05:44,405
所以训练集包含200,000个网络图片

80
00:05:44,405 --> 00:05:46,560
和5,000个移动应用图片

81
00:05:46,560 --> 00:05:51,990
开发集包含2,500个移动应用图片

82
00:05:51,990 --> 00:05:58,680
测试集也包含2,500个移动应用图片

83
00:05:58,680 --> 00:06:03,480
按照这种方式划分训练/开发/测试集

84
00:06:03,480 --> 00:06:07,410
其优点是你瞄准的是正确的目标

85
00:06:07,410 --> 00:06:12,930
你在向你的团队表明<br />我的开发集数据来自于移动应用

86
00:06:12,930 --> 00:06:15,570
而这正是你真正关心的图片的分布

87
00:06:15,570 --> 00:06:19,110
让我们来建立一个机器学习系统

88
00:06:19,110 --> 00:06:21,750
它在移动应用图片分布的表现的确很好

89
00:06:21,750 --> 00:06:25,190
当然其缺点就是你的训练集的分布

90
00:06:25,190 --> 00:06:30,870
不同于您的开发和测试集分布

91
00:06:30,870 --> 00:06:34,724
但事实证明这样划分训练/开发/测试集

92
00:06:34,724 --> 00:06:38,227
长期来说性能更好

93
00:06:38,227 --> 00:06:42,475
我们稍后将讨论一些具体的技术来处理

94
00:06:42,475 --> 00:06:47,160
训练集与开发/测试集<br />出自不同分布的问题

95
00:06:47,160 --> 00:06:49,110
我们来看另一个例子

96
00:06:49,110 --> 00:06:53,553
假设你正在打造一个全新的产品

97
00:06:53,553 --> 00:06:58,610
一款语音激活的后视镜

98
00:06:58,610 --> 00:07:01,368
这是中国的一款真实产品

99
00:07:01,368 --> 00:07:05,668
它正在进入其他国家的市场<br />但是你也可以自己做一个

100
00:07:05,668 --> 00:07:10,034
来把这个小东西换掉 这样你就可以跟后视镜说话了

101
00:07:10,034 --> 00:07:13,488
只要对它说 亲爱的后视镜

102
00:07:13,488 --> 00:07:17,760
请帮我导航到最近的加油站<br />它就会帮你导航

103
00:07:19,620 --> 00:07:22,750
所以这是一个真实的产品 现在假设你

104
00:07:22,750 --> 00:07:23,530
想给自己的国家也开发一个

105
00:07:27,160 --> 00:07:31,720
那么你要怎样取得数据

106
00:07:31,720 --> 00:07:32,489
来为这款产品训练语音识别系统呢

107
00:07:32,489 --> 00:07:36,137
也许你已经在语音识别领域<br />工作很长时间了

108
00:07:36,137 --> 00:07:39,785
你有大量来自其他语音识别应用的数据

109
00:07:39,785 --> 00:07:43,185
只是没有来自语音识别后视镜的数据

110
00:07:43,185 --> 00:07:47,164
那么 划分训练集/开发集/测试集<br />的方法是这样的

111
00:07:47,164 --> 00:07:50,780
对于训练集 你可以使用所有

112
00:07:50,780 --> 00:07:54,180
你在过去的语音识别工作中<br />所积累的数据 比如

113
00:07:54,180 --> 00:07:59,060
你多年来从各种语音识别<br />数据供应商处购买的数据

114
00:07:59,060 --> 00:08:03,410
如今你的确可以从供应商那里<br />购买形如(x,y)的数据

115
00:08:03,410 --> 00:08:06,130
其中x是音频 y是文字

116
00:08:06,130 --> 00:08:10,832
也许你有在智能语音激活扬声器<br />领域的工作经验

117
00:08:10,832 --> 00:08:12,990
所以有一些这方面的数据

118
00:08:12,990 --> 00:08:17,040
也许你有语音激活键盘<br />或者其他类似的工作经历

119
00:08:17,040 --> 00:08:21,515
为方便讨论 假设你有500,000个

120
00:08:21,515 --> 00:08:25,330
从这些来源收集的话语(utterance)片段

121
00:08:25,330 --> 00:08:30,078
而你的开发/测试集<br />可能是小得多的数据集

122
00:08:30,078 --> 00:08:33,892
他们来自于语音激活后视镜

123
00:08:34,950 --> 00:08:38,316
因为用户要求导航查询或

124
00:08:38,316 --> 00:08:41,590
试图找到去各种地方的方向

125
00:08:41,590 --> 00:08:46,560
这个数据集将包含<br />更多的街道地址 对吗

126
00:08:46,560 --> 00:08:49,250
请帮我导航到这个街道地址

127
00:08:49,250 --> 00:08:51,980
或请帮我导航到这个加油站

128
00:08:51,980 --> 00:08:56,040
所以这个数据分布和左边的有很大区别

129
00:08:58,140 --> 00:09:01,780
但是这才是你关心的数据<br />因为这才是你需要你的产品

130
00:09:01,780 --> 00:09:08,082
能处理好的数据<br />所以应该由它来组成开发和测试集

131
00:09:08,082 --> 00:09:12,868
那么在这个例子中你要做的是

132
00:09:12,868 --> 00:09:16,960
将训练集设为左边的<br />500,000个话语

133
00:09:16,960 --> 00:09:21,847
而开发集和测试集 简写为D和T

134
00:09:21,847 --> 00:09:26,380
分别包含大约10,000个话语

135
00:09:26,380 --> 00:09:31,064
来自语音激活后视镜的真实话语

136
00:09:31,064 --> 00:09:35,600
或者 如果你认为<br />你不需要把所有来自于

137
00:09:35,600 --> 00:09:38,498
语音激活后视镜的<br />全部20,000个语音样例

138
00:09:38,498 --> 00:09:42,470
都放到开发/测试集<br />也可以分出一半来放到训练集

139
00:09:43,730 --> 00:09:49,085
那么训练集有510,000个话语样例

140
00:09:49,085 --> 00:09:55,662
包括那边的500,000个<br />和来自后视镜的10,000个

141
00:09:58,046 --> 00:10:04,500
而开发/测试集分别包含<br />5,000个话语样例

142
00:10:04,500 --> 00:10:09,934
因此 20,000个话语<br />也许训练集分到10k

143
00:10:09,934 --> 00:10:14,490
开发集和测试集分别分到5k

144
00:10:14,490 --> 00:10:18,870
这是另一种将你的数据分配到训练集

145
00:10:18,870 --> 00:10:20,360
开发集和测试集的合理方案

146
00:10:20,360 --> 00:10:26,258
而且比起单纯的使用<br />语音激活后视镜提供的数据

147
00:10:26,258 --> 00:10:31,297
它提供大得多的训练集<br />有大于500k的话语样例

148
00:10:31,297 --> 00:10:35,880
在这节你看到一系列例子

149
00:10:35,880 --> 00:10:38,790
如果允许训练集和开发/测试集的数据<br />来自不同的分布

150
00:10:38,790 --> 00:10:41,980
那么你将拥有一个大得多的训练集

151
00:10:41,980 --> 00:10:45,990
这些例子中<br />它能使你的算法表现得更好

152
00:10:45,990 --> 00:10:50,100
现在你可能会问一个问题<br />是否应该总是使用所有的数据

153
00:10:50,100 --> 00:10:52,850
答案是微妙的 它并不总是肯定的

154
00:10:52,850 --> 00:10:54,910
我们将在下一节看到一些反例
GTC字幕组翻译