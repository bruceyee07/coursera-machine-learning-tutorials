1
00:00:00,000 --> 00:00:02,700
如果训练集的分布

2
00:00:02,700 --> 00:00:04,135
与你的开发集和测试集的分布不同

3
00:00:04,135 --> 00:00:09,623
并且如果误差分析表明出现了数据不匹配的问题
你该怎么解决？

4
00:00:09,623 --> 00:00:13,105
当然这个问题有系统的解决方案

5
00:00:13,105 --> 00:00:15,520
但是先看看我们怎么尝试解决

6
00:00:15,520 --> 00:00:19,107
如果发现出现了严重的数据不匹配问题

7
00:00:19,107 --> 00:00:23,865
我通常会人工地分析误差

8
00:00:23,865 --> 00:00:31,865
并且试着去理解训练集与开发/测试集之间的差异

9
00:00:31,865 --> 00:00:34,272
为了避免测试集上的过拟合

10
00:00:34,272 --> 00:00:35,800
技术上对误差分析来说

11
00:00:35,800 --> 00:00:40,030
你的关注点应该只是开发集而不是测试集

12
00:00:40,030 --> 00:00:42,040
但举一个具体的例子

13
00:00:42,040 --> 00:00:47,020
当你在构建语音激活后视镜的应用时,

14
00:00:47,020 --> 00:00:50,020
你可以看，但我想这些是语音，

15
00:00:50,020 --> 00:00:53,230
那就去听开发集中的样本

16
00:00:53,230 --> 00:00:56,885
弄明白开发集和你的训练集有什么不同

17
00:00:56,885 --> 00:00:58,890
比如说，你可能发现

18
00:00:58,890 --> 00:01:03,745
开发集中的许多样本的噪声很大
并且有大量的车辆噪音

19
00:01:03,745 --> 00:01:08,485
这是开发集不同于你测试集的一个方面

20
00:01:08,485 --> 00:01:11,350
也许你会发现其他类型的错误

21
00:01:11,350 --> 00:01:17,095
例如,在语音激活后视镜应用中

22
00:01:17,095 --> 00:01:20,650
你会发现它经常错误地识别

23
00:01:20,650 --> 00:01:22,600
街道号码,这是因为

24
00:01:22,600 --> 00:01:25,450
很多的导航查询需要街道地址。

25
00:01:25,450 --> 00:01:28,420
因此,正确地获取街道号码是非常重要的。

26
00:01:28,420 --> 00:01:31,110
当你研究开发集误差的本质时

27
00:01:31,110 --> 00:01:33,960
或当观察开发集

28
00:01:33,960 --> 00:01:37,055
跟训练集相比，存在怎样的差异或者难点时

29
00:01:37,055 --> 00:01:41,645
你所能做的就是想方设法使训练集更为相似

30
00:01:41,645 --> 00:01:47,290
或者也可以收集更多与开发测试集较为相似的数据

31
00:01:47,290 --> 00:01:53,940
比方说，如果你发现
车辆的背景噪声是主要的误差来源

32
00:01:53,940 --> 00:02:00,120
你可以模拟出车载噪声数据

33
00:02:00,120 --> 00:02:03,580
下张幻灯片将阐述更多操作方法

34
00:02:03,580 --> 00:02:06,710
或者当你发现你不能识别街道号码时

35
00:02:06,710 --> 00:02:10,280
也许你可以收集关于说话人数的数据

36
00:02:10,280 --> 00:02:15,150
并收入你的测试集

37
00:02:15,150 --> 00:02:20,555
我认为这张幻灯片可以给你的尝试提供了一个粗略的方案

38
00:02:20,555 --> 00:02:23,525
但这不是一个系统化的过程并且

39
00:02:23,525 --> 00:02:27,720
我认为不能保证你获得所需的见解以取得进展

40
00:02:27,720 --> 00:02:32,045
但是我发现这人为的观察

41
00:02:32,045 --> 00:02:35,870
能使数据在我们所关心的维度上具有更强的相似性

42
00:02:35,870 --> 00:02:39,765
这对很多问题都有帮助

43
00:02:39,765 --> 00:02:46,010
因此，如果你的目标是使训练集与开发集更加相似

44
00:02:46,010 --> 00:02:48,620
这样有什么解决方法呢？

45
00:02:48,620 --> 00:02:50,270
其中一个方法是你可以通过

46
00:02:50,270 --> 00:02:52,970
人工数据合成

47
00:02:52,970 --> 00:02:56,810
让我们在解决汽车噪声问题的背景下讨论这个问题。

48
00:02:56,810 --> 00:02:59,240
构建一个语音识别系统，

49
00:02:59,240 --> 00:03:01,970
你可能没有足够的车载音频数据

50
00:03:01,970 --> 00:03:05,030
伴随车外的背景噪声

51
00:03:05,030 --> 00:03:07,040
高速公路的背景噪声等等

52
00:03:07,040 --> 00:03:09,440
实际上有一种人工合成的方法

53
00:03:09,440 --> 00:03:11,435
所以,假设你已经记录了

54
00:03:11,435 --> 00:03:15,620
大量干净的、没有车辆背景噪声的音频

55
00:03:15,620 --> 00:03:20,400
这个是你的训练集中的一个示例

56
00:03:21,190 --> 00:03:26,340
而且，这个句子经常用在AI测试上

57
00:03:26,340 --> 00:03:30,590
因为这个短句包含了A到Z所有字母

58
00:03:30,590 --> 00:03:32,745
所以你会经常看到这个句子

59
00:03:32,745 --> 00:03:36,540
但是，基于音频“快速的棕色狐狸跳过懒狗”

60
00:03:36,540 --> 00:03:46,455
你也可以得到这样的汽车噪声

61
00:03:46,455 --> 00:03:49,010
这就是汽车内部的声音

62
00:03:49,010 --> 00:03:50,595
如果你安静地开车

63
00:03:50,595 --> 00:03:53,460
如果你把这两个音频剪辑加在一起

64
00:03:53,460 --> 00:03:55,595
你可以合成出

65
00:03:55,595 --> 00:03:58,835
“快速的棕色狐狸跳过懒狗”的声音

66
00:03:58,835 --> 00:04:06,870
如果你在嘈杂的车厢里说这句话
将听起来像这样

67
00:04:06,870 --> 00:04:10,980
因此,这是一个相对简单的音频合成示例

68
00:04:10,980 --> 00:04:14,210
实际上,你可以合成其他音频效果,比如

69
00:04:14,210 --> 00:04:16,370
回响,这是你的声音

70
00:04:16,370 --> 00:04:19,700
在汽车内壁上来回震动

71
00:04:19,700 --> 00:04:22,370
但通过人工合成数据

72
00:04:22,370 --> 00:04:26,900
你可以够快速创建更多的数据

73
00:04:26,900 --> 00:04:32,540
听起来就好比不需要出门收集得到的车载音频

74
00:04:32,540 --> 00:04:34,850
也许数千或数万小时的车内音频数据

75
00:04:34,850 --> 00:04:37,700
是从实际驾车时获取的

76
00:04:37,700 --> 00:04:41,210
因此,如果你的误差分析显示你应该尝试

77
00:04:41,210 --> 00:04:45,050
让你的数据听起来更像是在车里记录的，

78
00:04:45,050 --> 00:04:47,705
那么这个过程能够让你合理地

79
00:04:47,705 --> 00:04:51,310
合成这类型的数据，提供给你的训练算法。

80
00:04:51,310 --> 00:04:54,380
现在有一点关于人工数据合成

81
00:04:54,380 --> 00:04:57,855
我想提出注意的是

82
00:04:57,855 --> 00:05:04,814
比如说，有在安静的背景下
记录的1万小时的数据

83
00:05:04,814 --> 00:05:11,915
并且其中有一个小时伴随着汽车噪声

84
00:05:11,915 --> 00:05:14,940
你可以尝试将这一个小时的

85
00:05:14,940 --> 00:05:17,820
汽车噪声反复循环1万次

86
00:05:17,820 --> 00:05:24,695
目的是叠加这1万个小时在
安静背景的音频数据

87
00:05:24,695 --> 00:05:29,355
如果你这样做，人耳听起来会觉得不错，

88
00:05:29,355 --> 00:05:30,600
但是这里有可能

89
00:05:30,600 --> 00:05:38,790
会使学习算法对这一小时的
汽车噪声造成过度拟合

90
00:05:38,790 --> 00:05:44,325
特别的是,如果这组音频

91
00:05:44,325 --> 00:05:52,460
能够在汽车中收集

92
00:05:52,460 --> 00:05:56,195
或者这组音频的背景噪声是你所能想象的

93
00:05:56,195 --> 00:05:59,285
如果你只有一个小时的汽车噪音背景

94
00:05:59,285 --> 00:06:03,660
你可能只会模拟这其中很小的一个子集

95
00:06:03,660 --> 00:06:09,010
从而只从这个很小的子集进行合成

96
00:06:09,010 --> 00:06:10,870
对于人类的听觉来说

97
00:06:10,870 --> 00:06:13,990
这些音频没有任何问题，因为一小时的汽车噪音

98
00:06:13,990 --> 00:06:18,030
听起来和其他时段的汽车噪音没有区别

99
00:06:18,030 --> 00:06:23,880
但是，有可能从这个很小的子集进行合成

100
00:06:23,880 --> 00:06:25,840
这个神经网络可能

101
00:06:25,840 --> 00:06:30,530
会造成那一个小时的汽车噪音过拟合

102
00:06:30,530 --> 00:06:33,355
我不了解低成本地收集一万小时的

103
00:06:33,355 --> 00:06:37,090
汽车噪声数据的可行性有多大

104
00:06:37,090 --> 00:06:39,310
以便你不用不断地重复一小时的汽车噪音

105
00:06:39,310 --> 00:06:42,550
而是使用1万小时的不重复的

106
00:06:42,550 --> 00:06:48,024
汽车噪声去叠加到1万小时的
安静背景音频。

107
00:06:48,024 --> 00:06:50,900
虽然不能保证可行性

108
00:06:50,900 --> 00:06:56,710
但是确实是有可能去使用
一万小时的汽车噪声而不是那仅仅一小时

109
00:06:56,710 --> 00:07:01,167
这样通过学习算法可以提高性能。

110
00:07:01,167 --> 00:07:05,650
并且对于人类听觉来说
人工数据合成是一个挑战

111
00:07:05,650 --> 00:07:07,340
在你的听觉看来

112
00:07:07,340 --> 00:07:10,850
这一万小时的声音和一小时没有区别

113
00:07:10,850 --> 00:07:13,175
因此你可能就不会再

114
00:07:13,175 --> 00:07:16,310
毫无意识地从更小的子集中

115
00:07:16,310 --> 00:07:19,890
合成数据集

116
00:07:19,890 --> 00:07:23,265
这里是另一个人工数据合成的例子

117
00:07:23,265 --> 00:07:26,495
比方说你在构建自动驾驶车辆

118
00:07:26,495 --> 00:07:31,260
并且你想检测出这样的一辆车并用矩形框圈出

119
00:07:31,260 --> 00:07:34,550
很多人讨论的一个想法是

120
00:07:34,550 --> 00:07:39,070
为什么要用计算机图形学来模拟大量的汽车图片

121
00:07:39,070 --> 00:07:41,045
事实上,这里有几张

122
00:07:41,045 --> 00:07:44,045
由计算机图形学来生成的汽车的图片

123
00:07:44,045 --> 00:07:46,970
我认为这些图形的效果是相当不错的

124
00:07:46,970 --> 00:07:50,210
我能想象，通过合成像这样的图片

125
00:07:50,210 --> 00:07:54,510
你可以训练一个优秀的计算机视觉系统来检测车辆

126
00:07:54,510 --> 00:07:56,570
不幸的是，我在前面幻灯片画出的图片

127
00:07:56,570 --> 00:08:00,740
可以再一次应用到这个设定中

128
00:08:00,740 --> 00:08:05,075
可能这是所有汽车的一个子集并且

129
00:08:05,075 --> 00:08:10,200
如果你对这些汽车中非常小的子集进行合成

130
00:08:10,200 --> 00:08:12,775
那么可能对人眼来说

131
00:08:12,775 --> 00:08:15,145
这些合成的图像看上去没问题

132
00:08:15,145 --> 00:08:18,985
但是可能会对这个子集造成过拟合的问题

133
00:08:18,985 --> 00:08:23,590
特别的是，很多人纷纷提出一个想法

134
00:08:23,590 --> 00:08:26,950
一旦你发现一个电子游戏
具有良好的汽车计算机图形

135
00:08:26,950 --> 00:08:31,115
并捕捉汽车图像
获得一个庞大的汽车图片数据集

136
00:08:31,115 --> 00:08:33,805
事实证明，如果你在看在电子游戏

137
00:08:33,805 --> 00:08:38,065
如果在电子游戏中有20辆各异的汽车

138
00:08:38,065 --> 00:08:39,700
那么电子游戏看起来没问题

139
00:08:39,700 --> 00:08:42,190
因为你在电子游戏中驾驶汽车

140
00:08:42,190 --> 00:08:47,065
同时看到另外20辆汽车
这看起来像一个相当接近现实的模拟

141
00:08:47,065 --> 00:08:51,715
但是现实中的汽车模型远多于20种

142
00:08:51,715 --> 00:08:56,200
并且如果你所合成的训练集中只包含20种汽车

143
00:08:56,200 --> 00:09:00,485
那么你的神经网络可能会对这20种汽车过拟合

144
00:09:00,485 --> 00:09:03,985
即使这些图像看起来很现实

145
00:09:03,985 --> 00:09:06,130
对于一个人来说也很难轻易辨别出来

146
00:09:06,130 --> 00:09:11,780
但实际上，你确实只涵盖了
所有汽车的很小的一部分

147
00:09:11,780 --> 00:09:15,310
因此，总得来说，如果你认为
你遇到了数据不匹配的问题

148
00:09:15,310 --> 00:09:17,640
我推荐你做误差分析

149
00:09:17,640 --> 00:09:18,820
或者观察一下训练集

150
00:09:18,820 --> 00:09:20,785
或者观察一下开发集

151
00:09:20,785 --> 00:09:24,685
以便试图深入了解这两种数据分布的不同所在

152
00:09:24,685 --> 00:09:26,950
你可以设法来获得更多的

153
00:09:26,950 --> 00:09:30,025
看起来更像你的开发集的训练数据

154
00:09:30,025 --> 00:09:33,185
我们所讨论的一种方法是人工数据合成

155
00:09:33,185 --> 00:09:35,515
并且人工数据合成的确能起到作用

156
00:09:35,515 --> 00:09:39,630
在语音识别方面，我已经看到人工数据合成

157
00:09:39,630 --> 00:09:43,870
显着提升了已经非常好的语音识别系统的性能

158
00:09:43,870 --> 00:09:45,505
所以这种方法很好

159
00:09:45,505 --> 00:09:47,675
但如果你使用人工数据合成

160
00:09:47,675 --> 00:09:51,505
你必须小心并且记住，你是否可能意外地

161
00:09:51,505 --> 00:09:57,105
模拟了所有可能样本的子集中的数据

162
00:09:57,105 --> 00:10:01,990
这就是如何处理数据不匹配的问题

163
00:10:01,990 --> 00:10:04,690
接下来，我想与你分享一些想法

164
00:10:04,690 --> 00:10:08,390
关于如何同时从多种类型的数据中学习
GTC字幕组翻译