1
00:00:00,340 --> 00:00:03,520
打造機器學習系統的其中一個挑戰是

2
00:00:03,520 --> 00:00:06,250
有太多選擇可以試，太多事可以調整

3
00:00:06,250 --> 00:00:09,840
例如有很多超參數可以去調。

4
00:00:10,960 --> 00:00:14,210
我發現做機器學習最厲害的那些人

5
00:00:14,210 --> 00:00:17,440
他們很有洞察力，知道要調校什麼

6
00:00:17,440 --> 00:00:20,200
來達到某一個效果。

7
00:00:20,200 --> 00:00:22,842
這種過程我們稱之 "orthogonalization" (正交法)

8
00:00:22,842 --> 00:00:24,120
讓我來解釋一下

9
00:00:25,490 --> 00:00:28,560
這是一個很古老的電視

10
00:00:28,560 --> 00:00:33,820
有很多旋鈕，以不同的方式調整畫面

11
00:00:35,050 --> 00:00:39,880
這種舊電視機，可能有個旋鈕用來調整

12
00:00:39,880 --> 00:00:45,160
畫面高度多高，另一個旋鈕控制多寬

13
00:00:45,160 --> 00:00:49,310
可能有旋鈕調整梯形扭曲

14
00:00:49,310 --> 00:00:52,370
有另個旋鈕把畫面左右移動

15
00:00:52,370 --> 00:00:57,090
還有旋鈕控制旋轉角度，依此類推

16
00:00:58,740 --> 00:01:03,719
設計電視的人花很多時間打造電路

17
00:01:03,719 --> 00:01:06,477
—古早以前還是類比電路—

18
00:01:06,477 --> 00:01:11,170
來確保每個旋鈕的功能可以被解釋

19
00:01:11,170 --> 00:01:15,358
就像一個旋鈕調整這個、另個旋鈕調這個、...

20
00:01:15,358 --> 00:01:15,960
等等

21
00:01:17,840 --> 00:01:24,488
反過來說，想像有一個旋鈕控制 0.1 倍的畫面高度

22
00:01:24,488 --> 00:01:32,002
加上 0.3 倍寬的程度，減 1.7 倍的梯度扭曲

23
00:01:32,002 --> 00:01:39,010
加 0.8 倍水平方向的位置，之類的。

24
00:01:39,010 --> 00:01:42,330
當你轉這一個旋鈕，畫面高度、寬度、

25
00:01:42,330 --> 00:01:46,350
梯度扭曲、平移... 這些都會同時改變。

26
00:01:46,350 --> 00:01:51,211
如果旋鈕像這樣，要把畫面調整到螢幕正中間

27
00:01:51,211 --> 00:01:54,790
這幾乎是不可能的任務。

28
00:01:54,790 --> 00:02:00,569
在這個例子、"orthogonalization" 指的是做電視機的人

29
00:02:00,569 --> 00:02:06,076
要設計旋鈕，讓一個旋鈕只做一件事

30
00:02:06,076 --> 00:02:09,118
這樣調校電視起來比較容易

31
00:02:09,118 --> 00:02:12,712
能照你想要的把畫面置中。

32
00:02:14,032 --> 00:02:17,075
還有另一個 orthogonalization 的例子

33
00:02:17,075 --> 00:02:22,736
想像學開車，車有三種控制器：

34
00:02:22,736 --> 00:02:28,124
方向盤決定往左右多少

35
00:02:28,124 --> 00:02:31,170
還有油門、煞車。

36
00:02:31,170 --> 00:02:35,560
三種控制器，或說是一個控制方向

37
00:02:35,560 --> 00:02:38,810
兩個控制速度

38
00:02:38,810 --> 00:02:42,150
這樣是「可解釋的」

39
00:02:42,150 --> 00:02:46,770
能解釋在各個控制器的行為對車子的影響

40
00:02:46,770 --> 00:02:51,940
不過呢，想像有人發明一台車，有根搖桿

41
00:02:51,940 --> 00:02:56,560
控制 0.3 倍的左右

42
00:02:56,560 --> 00:03:00,910
減掉 0.8 倍的速度

43
00:03:00,910 --> 00:03:05,957
你有另一個控制器控制

44
00:03:05,957 --> 00:03:12,530
2倍的左右 + 0.9倍的車速

45
00:03:12,530 --> 00:03:15,140
理論上，只要調控這兩個，

46
00:03:15,140 --> 00:03:19,072
任何車子的方向和速度，你都能實現

47
00:03:19,072 --> 00:03:22,840
不過這實在太困難了，還不如你有一個控制器

48
00:03:22,840 --> 00:03:26,980
來控制方向，另一個分開的控制器

49
00:03:26,980 --> 00:03:28,750
來控制車速。

50
00:03:28,750 --> 00:03:31,913
所以 orthogonalization 的概念是

51
00:03:31,913 --> 00:03:35,707
如果你想要的一個維度是控制方向

52
00:03:35,707 --> 00:03:39,877
另一個維度是控制速度

53
00:03:39,877 --> 00:03:44,756
那麼，你會想要有一個旋鈕只控制方向

54
00:03:44,756 --> 00:03:49,179
而另一個旋鈕 — 在車的例子是油門、煞車

55
00:03:49,179 --> 00:03:51,634
— 來控制你的速度

56
00:03:51,634 --> 00:03:54,564
但是如果有一個控制器把兩者混在一起

57
00:03:54,564 --> 00:03:59,156
像是這一個，同時影響方向和速度

58
00:03:59,156 --> 00:04:01,752
同時影響兩者的東西

59
00:04:01,752 --> 00:04:06,570
這樣很難隨心所欲，設定想要的方向速度。

60
00:04:06,570 --> 00:04:11,933
而有了 orthogonal (正交/直角) — 意思是互為 90 度

61
00:04:11,933 --> 00:04:16,309
而有了 orthogonal 的控制器，和你想控制的

62
00:04:16,309 --> 00:04:21,251
事情一致，這樣要調整會很容易

63
00:04:21,251 --> 00:04:23,939
來調控方向盤角度、

64
00:04:23,939 --> 00:04:28,813
油門、煞車，想讓車子做啥就做啥。

65
00:04:28,813 --> 00:04:31,090
那麼，這和機器學習有何關？

66
00:04:32,260 --> 00:04:35,980
為了讓監督式的學習系統表現好，

67
00:04:35,980 --> 00:04:40,080
你常要調整系統的「旋鈕」，達到下面四件事

68
00:04:40,080 --> 00:04:43,930
第一，你通常要確保至少在訓練資料上

69
00:04:43,930 --> 00:04:45,210
能夠表現好

70
00:04:45,210 --> 00:04:50,327
在訓練集上的成效必須超過某個門檻

71
00:04:50,327 --> 00:04:52,458
在某些應用

72
00:04:52,458 --> 00:04:57,841
這意味著和人類的表現旗鼓相當

73
00:04:57,841 --> 00:05:00,005
不過這和你的應用有關

74
00:05:00,005 --> 00:05:03,400
下禮拜我們會詳談跟人類水準的比較

75
00:05:04,520 --> 00:05:07,689
總之在訓練資料上表現好，接下來

76
00:05:07,689 --> 00:05:12,281
你會希望在開發集 (dev set) 也表現得好

77
00:05:12,281 --> 00:05:16,520
然後希望在測試集 (test set) 也能表現好

78
00:05:16,520 --> 00:05:20,025
最終，如果在測試集的成本函數表現好

79
00:05:20,025 --> 00:05:23,544
你會希望這能讓你的系統在真實世界也表現好。

80
00:05:23,544 --> 00:05:28,481
例如你會希望

81
00:05:28,481 --> 00:05:32,590
這能讓貓貓App使用者開心。

82
00:05:32,590 --> 00:05:37,990
回到調整電視機的例子，如果畫面

83
00:05:37,990 --> 00:05:43,040
太寬太窄，你需要一個旋鈕來調整

84
00:05:43,040 --> 00:05:45,680
你不想小心翼翼調整五個不同的旋鈕

85
00:05:45,680 --> 00:05:47,720
還可能會搞亂其他方面

86
00:05:47,720 --> 00:05:52,510
你想要一個旋鈕，只會影響電視畫面寬度。

87
00:05:52,510 --> 00:05:57,500
同樣道理，倘若你的演算法在訓練集不夠準

88
00:05:57,500 --> 00:06:02,540
你需要一個旋鈕 — 對，我畫的是顆旋鈕

89
00:06:02,540 --> 00:06:05,540
或者一組特定的旋鈕

90
00:06:05,540 --> 00:06:10,960
讓你能調整你的演算法，在訓練資料上夠準

91
00:06:10,960 --> 00:06:15,560
所以這樣的旋鈕是：訓練一個更大的網路

92
00:06:16,730 --> 00:06:20,740
或者用更好的最佳化演算法

93
00:06:20,740 --> 00:06:24,270
例如 Adam 優化法，等等等

94
00:06:24,270 --> 00:06:27,410
這周和下週我們會談到更多方法。

95
00:06:28,440 --> 00:06:33,588
相反地，如果發現你在開發資料上不夠準

96
00:06:33,588 --> 00:06:36,251
那你會有另一組的旋鈕

97
00:06:36,251 --> 00:06:40,976
— 對，這旋鈕不怎麼美

98
00:06:40,976 --> 00:06:44,465
你會想要有不同的旋鈕來實驗

99
00:06:44,465 --> 00:06:49,196
所以假設，你的演算法在開發資料表現差；

100
00:06:49,196 --> 00:06:53,455
在訓練集好，但在開發集不好，那麼這邊的旋鈕是

101
00:06:53,455 --> 00:06:57,938
正則化，你能用這個滿足第二個條件

102
00:06:57,938 --> 00:07:01,786
打個比方，你已經調好電視的畫面寬度

103
00:07:01,786 --> 00:07:04,467
如果畫面的高度還不大對

104
00:07:04,467 --> 00:07:08,680
你會想要有另一個旋鈕調整高度

105
00:07:08,680 --> 00:07:13,429
你希望這樣做不會影響電視畫面的寬度

106
00:07:13,429 --> 00:07:14,563
太多。

107
00:07:14,563 --> 00:07:20,655
蒐集更多訓練資料，這會是另個可能的旋鈕

108
00:07:20,655 --> 00:07:26,758
希望你的演算法能更通用 (generalize)，在開發集表現好。

109
00:07:26,758 --> 00:07:30,248
那現在，電視的寬度高度都調好了

110
00:07:30,248 --> 00:07:32,587
如果第三個條件沒滿足呢？

111
00:07:32,587 --> 00:07:36,880
在開發集表現好，但在測試集 (test set) 表現差，怎麼辦？

112
00:07:36,880 --> 00:07:37,840
如果這樣

113
00:07:37,840 --> 00:07:42,880
那這邊的旋鈕是，你會想要蒐集更多開發資料

114
00:07:42,880 --> 00:07:47,452
因為如果在開發集表現好，但在測試集不是這樣

115
00:07:47,452 --> 00:07:51,010
有可能你為了開發集調整太過火，所以要回頭
使用更多的開發資料

116
00:07:52,590 --> 00:07:57,630
最後，如果在測試集表現好，但是

117
00:07:57,630 --> 00:08:04,020
app使用者不開心，這意味著該回頭看看

118
00:08:04,020 --> 00:08:10,270
改變開發集，或是改變成本函數

119
00:08:13,600 --> 00:08:18,230
因為如果根據成本函數，宣稱測試集表現好

120
00:08:18,230 --> 00:08:21,870
而現實世界的表現並不符合

121
00:08:21,870 --> 00:08:27,260
這代表你的開發/訓練集的分佈不對

122
00:08:27,260 --> 00:08:30,230
或是你的成本函數衡量了錯誤的指標。

123
00:08:30,230 --> 00:08:34,260
我知道我講得很快，不過在這禮拜和下禮拜

124
00:08:34,260 --> 00:08:39,770
我們會探討更多這些旋鈕的細節

125
00:08:39,770 --> 00:08:42,870
所以現在跟不上也不打緊，不用擔心

126
00:08:42,870 --> 00:08:46,429
我想給你的是這種「正交」(orthogonalization) 程序的概念

127
00:08:46,429 --> 00:08:50,184
你要很清楚這四項議題

128
00:08:50,184 --> 00:08:53,569
這各式各樣可以調整的東西，每一個代表什麼

129
00:08:53,569 --> 00:08:57,809
當我訓練神經網路，我不大想用 early stopping (提前停止)

130
00:08:57,809 --> 00:09:00,845
這方法不壞，很多人都用

131
00:09:00,845 --> 00:09:04,450
不過我個人覺得 early stopping 不好理解

132
00:09:04,450 --> 00:09:09,530
因為這個行為同時影響你在訓練資料上多準

133
00:09:09,530 --> 00:09:13,370
因為你提前停止，還不夠適應訓練集

134
00:09:13,370 --> 00:09:18,610
而這行為也同時常用來改善開發集上的表現

135
00:09:18,610 --> 00:09:21,973
所以這顆旋鈕不夠「正交」

136
00:09:21,973 --> 00:09:25,343
因為他同時影響兩件事

137
00:09:25,343 --> 00:09:28,691
就像是一個旋鈕同時影響電視畫面的

138
00:09:28,691 --> 00:09:30,900
寬度和高度

139
00:09:30,900 --> 00:09:34,285
這不表示這很爛，不要用，你想的話也可以用

140
00:09:34,285 --> 00:09:37,400
只是如果你有更「正交」的控制

141
00:09:37,400 --> 00:09:40,020
就像我這邊列的

142
00:09:40,020 --> 00:09:44,260
這讓調整神經網路更加簡單

143
00:09:44,260 --> 00:09:47,655
那麼，我希望這給了你「正交」(orthogonalization) 的概念

144
00:09:47,655 --> 00:09:51,645
就好比當你看著電視畫面，你可以說

145
00:09:51,645 --> 00:09:55,343
喔我的畫面太寬，待我轉這顆旋鈕，或是這太高，

146
00:09:55,343 --> 00:09:59,390
所以我來調這顆旋鈕，或者太扭曲，所以要調這顆

147
00:09:59,390 --> 00:10:01,710
在機器學習，如果能這樣就很棒：看一下系統

148
00:10:01,710 --> 00:10:03,430
就說這個部份有問題

149
00:10:03,430 --> 00:10:06,088
在訓練集不好、在開發集不好、

150
00:10:06,088 --> 00:10:08,702
在測試集不好、或者在測試集很好，但是在

151
00:10:08,702 --> 00:10:09,720
現實中不好

152
00:10:09,720 --> 00:10:13,309
弄清哪裡不好以後，能有一顆旋鈕

153
00:10:13,309 --> 00:10:17,310
或是一組特定的旋鈕，來幫助你

154
00:10:17,310 --> 00:10:20,770
解決這個影響系統表現的問題。

155
00:10:20,770 --> 00:10:24,643
所以這周和下周，我們會解釋

156
00:10:24,643 --> 00:10:28,025
怎麼去診斷你系統成效的瓶頸

157
00:10:28,025 --> 00:10:32,386
還有確認你能用怎麼樣的旋鈕，調整系統

158
00:10:32,386 --> 00:10:34,715
改善那方面的成效

159
00:10:34,715 --> 00:10:37,900
就讓我們來更深入探討之