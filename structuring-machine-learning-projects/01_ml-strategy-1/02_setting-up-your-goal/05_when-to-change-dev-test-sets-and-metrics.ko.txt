dev set와 평가 매트릭 지표를 세팅하는 것은 팀이 특정 목표를 지향할 수 있도록 방향성을 제시하는 것과 같습니다. 하지만 프로젝트 진행도중에 잘못된 방향이었다는 것을 뒤늦게 깨닫는 경우도 있죠. 이런 경우엔, 목표를 이동시켜야 합니다. 예시를 함께 보시죠. 고양이 인식 프로그램을 만든다고 해봅시다. 고양이 관련 많은 사진을 찾아서 고양이를 좋아하는 유저들에게 보여주고 매트릭은 classification error 라는 것을 사용한다고 해봅시다. A 알고리즘과 B 알고리즘은 각각, 3퍼센트 오류와 5퍼센트 오류를 범하고 있습니다. 겉으로 보기엔 A 알고리즘이 더 낫다고 평가할 수 있죠. 하지만 여러분이 직접 시현해봤을 때 어떤 이유에서인지, A 알고리즘이 포르노 이미지를 많이 허용하는 것입니다. 그렇게 해서 A 알고리즘을 사용하면 물론 유저들은 더 많은 고양이 사진을 3퍼센트의 낮은 인식오류로 볼 수 있지만 이와 함께, 포르노 이미지를 보게 될 수도 있는 것인데, 이것은 2개의 회사에서 모두 용납할 수 없는 오류입니다. 물론 당연히 유저에게도 말이죠. 반대로, B 알고리즘은 5퍼센트의 오류를 범하고, 더 적은 수의 이미지를 분류하지만 포르노 이미지가 없습니다. 이렇게 되면 기업입장과 유저에서 허용하는 정도를 생각해보았을 때, B 알고리즘이 더 훌륭한 알고리즘이라고 볼 수 있겠죠. 포르노 이미지를 걸러내기 때문입니다. 이번 사례로 보면, A 알고리즘은 평가 매트릭에서 더 잘하고 있습니다. 3퍼센트의 오류이긴 하지만 알고리즘이 좋다고 할 수 없죠. 이런 경우, 평가 매트릭 플러스 dev set는 A 알고리즘을 선호합니다. 그 이유는 A 알고리즘이 오류 수치가 너 낮고 지금 현재 사용하고 있는 매트릭이기 때문이죠. 그리고 유저들은 B 알고리즘을 선호할 것입니다. 포르노 사진을 걸러낼 수 있기 때문이죠. 이런 경우가 발생할 경우, 평가 매트릭이 더 이상 올바르게 알고리즘의 선호도 순서를 랭킹할 수 없을 때, A 알고리즘이 더 좋은 것이고 틀리게 평가를 하는 경우, 여러분이 아마도 평가 매트릭을 바꿔야 하거나 dev set나 테스트세트를 바꿔야 하는 신호일 수 있습니다. 올바르지 않게 분류하는 매트릭이 사용되면 이런 것은 이렇게 쓰일 수 있는데요. 이것 나누기 m, dev set에 있는 예시의 개수, 곱하기 1에서 mdev까지의 합 dev set에서의 예시개수에서 prediction example i 가 실제 label i와 틀린 경우입니다. 이 노테이션을 이용해 예상 값을 표현합니다. 이 값은 0입니다. 이건 함수 노테이션인데요. 이것은 안에 들어 잇는 내용이 사실인 것의 개수를 셉니다. 그러므로 이 공식은 분류를 잘하지 못한 사례들의 총 개수를 합한 것이죠. 이 평가 매트릭의 문제점은 포르노 이미지와 일반 이미지를 똑같이 평가한다는 것입니다. 하지만 분류하는 프로그램이 포르노사진은 잘못 레이블 하지 않도록 해야겠죠. 포르노 이미지를 인식했음에도, 의심하지 않는 유저에게 보여주게 되면 생각 치도 못하게 굉장히 불쾌할 것입니다. 이런 평가 매트릭을 바꾸는 한가지 방법은, weight 변수를 넣는 것입니다. 이것을 w(i)라고 하고, x(i)가 일반 이미지인 경우는 1이고 x(i) 값이 포르노 이미지인 경우 10 아니면 더 큰 숫자인 100으로 식을 만드는 것입니다. 이와 같이, 포르노 이미지인 경우에는 더 큰 weight를 부여해서 오류 값이 올라가도록 하는 것입니다. 이렇게 하면 포르노 이미지를 고양이 이미지로 잘못 분류하는 경우 오류 값이 훨씬 더 많이 올라가게 지정하는 것입니다. 이번 사례에서는, 10배의 높은 weight를 지정하여 포르노 이미지를 올바르게 판별하는 것에 대해 더 큰 비중을 부여합니다. 이 normalization을 constant로 만들고 싶으면, 엄밀히 이야기해서 이것은 1 나누기 w(i)의 합이 됩니다. 이렇게 하면 이 오류 값은 0에서 1사이의 값을 가지게 될 것이고요. 이 weighting의 상세 내용은 그리 중요하지 않습니다. 이 weighting을 도입하기 위해선, dev set와 test set를 거쳐야 합니다. 포르노 이미지를 dev와 테스트세트에 레이블 하여 이 weighting 함수를 도입시킬 수 있습니다. 가장 중요한 것은, 평가 매트릭이 알고리즘 관련하여 원하는 순서로 선호도를 알려주지 않는다고 하면 새로운 평가 매트릭 도입을 고려할 시점입니다. 앞서 말한 내용은, 평가 매트릭을 정의할 수 있는 한가지 방법입니다. 평가 매트릭의 목적은 2개의 classifier 중, 본인 어플에서 어떤 게 더 정확히 적용될 수 있는지 평가하는 것입니다. 이 비디오에서 알려드리고자 하는 내용만 따져보면, 새로운 오류 매트릭을 어떻게 정의하는 지까지는 상세히 알 필요가 없습니다. 중요한 부분은 바로 이전 오류 매트릭이 만족스럽지 못한 경우, 불만족스러운 매트릭을 계속 유지하지 말고, 어떤 것이 더 뛰어난 알고리즘인지 그 선호도를 잘 캡처하는 새로운 매트릭을 정의하려고 시도해 보십시오. 눈치를 채셨겠지만 이제까지는, classifier를 평가하는 방식에 대해서만 정의하는 방법에 대해서 이야기 했었습니다. 즉, 우리는 음란물이 스트리밍되는 것과 관련해 classifier들을 잘 선호도 별로 랭킹하고 분류하는 것을 잘 평가할 수 있도록 관련 평가 매트릭을 정의 해했었습니다. 이런 사례가 바로 직교화의 실제 사례인데요, 머신러닝의 문제를 쪼개서 특정 단계로 그 절차는 나누어 보는 것입니다. 첫번째 단계는 수행하고 싶은 것을 캡처하는 매트릭을 정의하는 방법을 파악하는 것입니다. 그리고 해당 매트릭에서 잘 구현하는 것에 대해선 따로 고민해볼 것 같습니다. 즉, 머신러닝 수행업무에 대해서 2가지의 단계로 보십시오. 목표를 결정하는 접근을 하면 첫 번째 단계는 목표를 두는 것입니다. 그러니 어디를 겨냥할 것인지 정의하고 나서 완전히 다른 단계로, 이것은 튜닝할 수 있는데요, 어떻게 목표를 둘 것인가는 또 다른 하나의 문제로 보면 됩니다. 이 알고리즘에서 성능을 발휘하기 위한 방법으로써 별개의 튜닝 단계로 생각하십시오. 어떻게 하면 정확히 목표를 겨냥하고, 목표를 실행할 수 있는지도 말입니다. 매트릭을 정의하는 것이 첫 번째 단계이고, 나머지는 두 번째 단계입니다. 목표를 향해 실행하는 단계는, 여러분의 러닝 알고리즘이 이렇게 생긴 비용 함수를 최적화하고 있을 수 있습니다. 트레이닝세트에서 발생한 피해에 대해서 말이죠. 한가지 할 수 있는 것은 이것을 변형시켜서 여기 이런 weight들을 반영시키는 것입니다. 그렇게해서 잘하면 이 normalization constant도 바꿀 수 있겠죠. 이건 1 나누기 w(i)의 합인데요, J를 어떻게 정의하는지에 대한 상세내용은 중요하지 않습니다. 중요한 것은, 직교화의 철학을 바탕으로 첫 번째로 목표를 위치시키는 것을 생각하고, 조준하고 목표를 실행하는 것을 또 다른 단계를 생각하십시오. 다른 말로 말해, 매트릭을 정의하는 것을 첫 번째로, 그리고 반드시 매트릭의 정의가 완료된 시점 이후, 그 매트릭에서 어떻게 하면 잘 성능을 발휘할지 생각해보길 바랍니다. 신경망의 최적화를 담당하는 J 의 비용함수를 바꿔서 할 수도 있겠죠. 다음으로 넘어가기 전에 한가지만 더 살펴보겠습니다. 고양이 Classifier A와 B가 각각 있다고 해봅시다. 각각 3퍼센트 오류, 5퍼센트 오류가 dev set에서 나왔습니다. 아니면 다운받은 이미지들을 바탕으로 한 테스트세트에서 나온 것일 수도 있죠. 고품질의 이미지들 말입니다. 그런데 알고리즘 제품을 투입시키면 B 알고리즘이 더 뛰어난 성능을 발휘하는 것처럼 보이는 것입니다. dev set에서는 더 좋은데도 말이죠. 그리고, 다운로드 받은 고품질의 이미지들을 통해 트레이닝을 진행해왔는데도 모바일 어플로 출시하면 유저들이 수많은 다양한 사진을, 잘 프레임되지 않은 사진을 올리는 것입니다. 고양이 사진에 국한됨에도 불구하고 고양이들이 다양한 표정들이 있고, 이미지들이 흐릿하고, 결국에는 B 알고리즘이 더 잘 작동되는 것입니다. 이런 사례가 바로 매트릭과 dev set가 망가지는 예입니다. 문제는 dev set와 테스트세트에서 평가를 한다는 것입니다. 아주 잘나오고 고화질의 고프레임 사진을 바탕으로 말이죠. 하지만 유저가 신경 쓰는 것은 본인들이 올린 이미지가 잘 작동되는 것입니다. 이런 사진들은 프로페셔널하지 않거나, 흐릿하게 나오거나 프레임이 낮은 사진일 수도 있습니다. 그러므로 가이드라인은, 매트릭에서 잘 하는 것이고, 현재 dev set 또는 dev와 테스트세트 분포 데서 잘하는 것입니다. 이런 것이 어플에서 잘 작동하는 것으로 이어지지 않는다면, 매트릭과 dev test set를 바꾸십시오. 쉽게 얘기해서, dev test set가 고품질의 이미지로 이루어져 있고 이 세트를 평가하는 것이 어플의 성능을 평가하기 부적합하다고 생각하면, 어플에서는 낮은 퀄리티의 사진이 나올 수도 있기 때문에 그렇다면, dev test set를 바꾸기 좋은 시점입니다. 데이터가 실제로 작업에 필요한 데이터 유형을 더 잘 반영하도록 설정할 수 있습니다. 하지만 전반적인 가이드라인은 현재 매트릭과 데이터가 염두하고 있는 부분에서 잘 반영되지 않거나 성능 발휘가 되지 않는다고 하면 매트릭을 바꾸거나 dev또는 dev test set를 바꿔서 알고리즘이 이런 놓친 부분을 잘 반영시킬 수 있도록 합니다. 평가 매트릭과 dev set를 구축함으로써 A 알고리즘과 B알고리즘 중에 어떤 것이 더 나은지 의사결정을 내릴 수 있게 해줍니다. 여러분과 팀이 빠르게 반복학습을 할 수 있도록 해줍니다. 제가 추천 드리는 방법은, 평가 매트릭과 dev set를 완벽히 평가할 수는 없지만, 팀의 반복 수행을 돕기 위해 빨리 한가지를 세팅하는 것입니다. 나중에 프로젝트 진행 중에 안 좋은 것이라고 판명이 되면, 또는 더 좋은 아이디어가 있을 경우, 그때 바꿔도 됩니다. 하지만 모든 팀에게 권장 드리지 않는 것은 어떠한 매트릭이나 dev set던 오래 만들거나 세팅하는 것입니다. 이렇게 하면 속도가 늦춰지고 여러분의 팀 생산성에 문제가 생기고 결과적으로 알고리즘을 개선하는 제한이 있을 수 있습니다. 이번에 다룬 내용은 여러분이 어느 시점에서 평가 매트릭과 dev/ dev test set를 바꿔야 하는지 알아보았습니다. 이런 가이드라인이 여러분의 팀이 잘 확립된 목표를 설정하고 성능 개선 업무를 수행하는데 도움이 됐기 바랍니다.