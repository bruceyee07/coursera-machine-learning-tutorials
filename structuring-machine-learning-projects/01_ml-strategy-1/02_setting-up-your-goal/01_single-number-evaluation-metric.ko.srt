1
00:00:00,252 --> 00:00:03,417
여러분이 하이퍼 파라미터를 튜닝하거나, 알고리즘 교육에 다른 아이디어를 발휘하는 경우이거나

2
00:00:03,417 --> 00:00:06,047
머신러닝 시스템을 만드는데 있어

3
00:00:06,047 --> 00:00:07,764
다른 방법을 찾는 경우

4
00:00:07,764 --> 00:00:12,016
실수 평가 측정 지표가 있을 시, 진행속도가 훨씬 빨라지는 것을 보게 될 것입니다.

5
00:00:12,016 --> 00:00:16,064
이 지표는 새롭게 시도한 것들이 더 잘 작동하는지

6
00:00:16,064 --> 00:00:20,260
더 좋지 않은 결과를 주는지 알려주기 때문입니다.

7
00:00:20,260 --> 00:00:24,710
그래서 보통 팀들이 머신러닝 프로젝트를 시작할 때,

8
00:00:24,710 --> 00:00:29,570
실수 평가 측정 지표를 사용하라고 권장합니다.

9
00:00:29,570 --> 00:00:30,600
예시를 봐볼까요.

10
00:00:32,400 --> 00:00:35,244
저번에도 제가 얘기 했듯이, applied 머신 러닝은

11
00:00:35,244 --> 00:00:36,165
실증적 증거에 기반한 절차입니다.

12
00:00:36,165 --> 00:00:40,360
어떠한 특정 발상이 있으면, 그것을 코드화하고, 실험을 하여 결과를 획득하고,

13
00:00:40,360 --> 00:00:44,100
결과를 이용하여 아이디어를 다듬어 나갑니다.

14
00:00:44,100 --> 00:00:48,590
이러한 절차를 계속 루프처럼 반복하여 알고리즘을 계속 개선해 나갑니다.

15
00:00:48,590 --> 00:00:54,124
여러분의 classifier A라는 것이 있다고 해봅시다.

16
00:00:54,124 --> 00:00:58,036
하이퍼 파라미터와 트레이닝 세트에 변화를 줌으로써,

17
00:00:58,036 --> 00:01:02,032
또는 다른 변수에 변화를 주어 새로운 classifier B를 트레이닝 했다고 해봅시다.

18
00:01:02,032 --> 00:01:06,866
한가지 합리적인 성능 평가 방법은

19
00:01:06,866 --> 00:01:08,680
정밀도와 재현율을 보는 것입니다.

20
00:01:08,680 --> 00:01:12,804
정확히 정밀도와 재현율이 어떻게 되어 있는지 보는 것은 이번 예시에서

21
00:01:12,804 --> 00:01:13,650
사실 그리 중요하지 않습니다

22
00:01:13,650 --> 00:01:16,594
간략히 정밀도의 정의는,

23
00:01:16,594 --> 00:01:20,207
고양이를 인식하는 classifier의 예를 들자면,

24
00:01:23,068 --> 00:01:26,741
몇 퍼센트가 고양이인지? 의 정확도를 나타내는 것을 이야기합니다.

25
00:01:32,341 --> 00:01:37,045
만약 classifier A가 95퍼센트의 정확도를 보이면, classifier A는

26
00:01:37,045 --> 00:01:41,830
고양이가 맞는다고 올바르게 판별하는 확률이 95 퍼센트라는 뜻입니다.

27
00:01:41,830 --> 00:01:45,878
재현율은 고양이 이미지에서

28
00:01:45,878 --> 00:01:50,731
실제로 얼마나 classifier를 통해 올바르게 인식이 되었는가? 를 뜻합니다.

29
00:01:50,731 --> 00:01:57,110
실제 몇 퍼센트의 고양이가 올바르게 분류가 되었는가?

30
00:02:04,331 --> 00:02:08,986
그렇다면 만약 classifier A가 90 퍼센트 재현율 이라고 하면 모든 dev set의 이미지에서

31
00:02:08,986 --> 00:02:11,010
실제로 고양이인 이미지가

32
00:02:11,010 --> 00:02:13,987
90 퍼센트 정확도로 인식했다는 뜻입니다.

33
00:02:13,987 --> 00:02:19,049
그러니 정밀도와 재현율의 정의에 너무 목 메일 필요 없습니다.

34
00:02:19,049 --> 00:02:23,933
정밀도와 재현율의 절충이 있다고 보는데요

35
00:02:23,933 --> 00:02:26,845
둘 다 신경 쓸 수 밖에 없죠.

36
00:02:26,845 --> 00:02:29,455
만약 classifier가 어떤 것이 고양이라고 하면

37
00:02:29,455 --> 00:02:31,765
그럴 확률이 매우 높습니다.

38
00:02:31,765 --> 00:02:33,475
그렇지만 모든 것이 고양이의 이미지라고 하면

39
00:02:33,475 --> 00:02:37,905
classifier가 이 이미지들의 대부분을 올바르게 고양이라고 인식하길 바랄 것입니다.

40
00:02:37,905 --> 00:02:40,865
그렇기 때문에 classifier를 정밀도와 재현율의 기준에서

41
00:02:40,865 --> 00:02:44,685
평가를 하는 것이 합리적인 것이라고 할 수 있습니다.

42
00:02:44,685 --> 00:02:49,728
평가 측정 지표로 정밀도와 재현율을 사용하는 문제점은

43
00:02:49,728 --> 00:02:54,926
여기에서 그렇듯이 classifier A가 재현율에서 더 잘 발휘하고, classifier B는

44
00:02:54,926 --> 00:02:59,840
정밀도에 더 강한데요, 그렇기 때문에 어떤 classifier가 더 좋은지 알기 어려울 수 있습니다.

45
00:03:03,481 --> 00:03:06,976
여러가지 아이디어와,

46
00:03:06,976 --> 00:03:11,076
여러 가지 하이퍼 파라미터를 시도하면서 두 가지의 classifier만 시도할 것이 아니라

47
00:03:11,076 --> 00:03:14,932
약 12가지의 classifier를 테스트해봐서 가장 좋은 것을 고르는 것이 좋습니다.

48
00:03:14,932 --> 00:03:17,010
그 이후로는 계속 반복할 수 있기 때문이죠.

49
00:03:19,850 --> 00:03:23,570
또한, 두 가지의 평가 지표로는

50
00:03:23,570 --> 00:03:27,380
두 가지 중 한가지를 선택하거나, 열 가지 중 한가지를 선택하는 것이 어렵습니다.

51
00:03:29,170 --> 00:03:33,220
그래서 classifier를 고르는 과정에서 제가 추천 드리는 것은

52
00:03:33,220 --> 00:03:35,870
두 가지의 숫자, 정밀도, 재현율을 사용하기보다는

53
00:03:35,870 --> 00:03:40,440
정밀도와 재현율을 결합시킨 새로운 평가 지표를 찾는 것입니다.

54
00:03:41,740 --> 00:03:45,205
머신러닝 세계에서는, 정밀도와 재현율을

55
00:03:45,205 --> 00:03:47,028
결합시키는데 있어 F1 score라는 것을 쓰는 게 정석입니다.

56
00:03:47,028 --> 00:03:52,777
F1 score의 상세내용은 그리 중요하지 않습니다, 그렇지만

57
00:03:52,777 --> 00:03:58,541
대략적으로 P라는 정밀도 값과 R이라는 재현율값의 평균수치라고 생각하면 됩니다.

58
00:03:58,541 --> 00:04:04,574
공식적으로는, F1 score가 식으로 정도 되는데요.

59
00:04:04,574 --> 00:04:07,670
공식은 2/ 1/P + 1/R입니다.

60
00:04:07,670 --> 00:04:12,240
수학에서는 이 공식을 Harmonic mean of

61
00:04:12,240 --> 00:04:16,860
Precision P and recall R이라고 합니다.

62
00:04:16,860 --> 00:04:17,850
비공식적으로는,

63
00:04:17,850 --> 00:04:21,721
정밀도와 재현율의 평균값을 구하는 것이라고 생각하시면 편합니다.

64
00:04:22,840 --> 00:04:25,190
산술적인 평균값을 갖기보다는,

65
00:04:25,190 --> 00:04:28,800
조화 평균값을 공식과 같이 갖게 됩니다.

66
00:04:28,800 --> 00:04:33,410
정밀도와 재현율의 균형에 있어서 장점이 있는데요.

67
00:04:33,410 --> 00:04:34,953
이번 예시를 통해,

68
00:04:34,953 --> 00:04:39,853
classifier A가 더 나은 F1 score를 갖는 사실을 바로 볼 수 있습니다.

69
00:04:39,853 --> 00:04:43,825
F1 score가 정밀도와 재현율을 결합하는데 합리적인 방법이라고 가정하면,

70
00:04:43,825 --> 00:04:47,000
classifier A가 classifier B 보다 낫겠죠.

71
00:04:48,100 --> 00:04:48,880
여러 머신러닝 팀을 보면서 느낀 것은

72
00:04:48,880 --> 00:04:52,401
많은 팀들이 잘 정의된 dev set를 갖추었는데,

73
00:04:52,401 --> 00:04:57,598
즉, 정밀도와 재현율을 잘 측정하도록 구축한 경우를 말하는데요,

74
00:04:57,598 --> 00:05:03,430
single number 평가 지표와 함께 사용하는 것을 보았습니다. 가끔씩 single row number라고 표현하기도 합니다.

75
00:05:04,580 --> 00:05:09,147
평가 지표는 classifier A 또는

76
00:05:09,147 --> 00:05:13,971
classifier B가 더 좋은지 빠르게 판단할 수 있게 해주고,

77
00:05:13,971 --> 00:05:18,301
결과적으로 dev set와 single number 평가 지표를 구축하여 반복하는데 속도를 높일 수 있습니다.

78
00:05:21,551 --> 00:05:26,980
반복적인 절차를 빠르게 처리할 수 있게 해줌으로써 머신러닝 알고리즘을 개선하는데 빠른 처리를 도와줍니다.

79
00:05:26,980 --> 00:05:28,010
다른 예제를 보시죠.

80
00:05:29,130 --> 00:05:35,390
고양이를 좋아하는 사람들을 위하여 4대륙에 고양이 어플을 만든다고 해봅시다.

81
00:05:35,390 --> 00:05:40,490
미국, 중국, 인도, 그리고 나머지 국가로 말이죠.

82
00:05:40,490 --> 00:05:43,940
그리고 2가지 classifier가 다른 종류의 에러를 갖게 된다고 해봅시다.

83
00:05:45,370 --> 00:05:48,400
대륙 별로 각각 다른 데이터에서 오류가 발생했다고 해봅시다.

84
00:05:48,400 --> 00:05:54,280
알고리즘 A는 미국에서 제출한 사진으로부터 3퍼센트 에러를 갖고 나머지도 이런 식으로 된다고 해봅시다.

85
00:05:56,100 --> 00:05:59,140
그럼 기록을 유지하는 것이 합리적일 수 있는데요,

86
00:05:59,140 --> 00:06:03,260
이러한 다른 시장 또는 다른 대륙에서 classifier가 얼마나 잘 발휘하는지 말이죠.

87
00:06:03,260 --> 00:06:06,770
하지만 4가지 숫자 기록을 유지하면서

88
00:06:06,770 --> 00:06:10,890
알고리즘 A가 나은지, 알고리즘 B가 더 나은지 결정하기는 쉽지 않습니다.

89
00:06:10,890 --> 00:06:13,370
그리고 여러 가지 classifier로 테스팅을 하게 되면,

90
00:06:13,370 --> 00:06:17,590
이러한 많은 숫자들을 보면서 한가지를 고르는 것은 너무 어렵습니다.

91
00:06:17,590 --> 00:06:22,390
그래서 제가 이번 예시를 통해 추천 드리는 것은, 대륙 별 성과 기록을 유지하는 것 외에,

92
00:06:22,390 --> 00:06:26,450
평균을 계산하는 것입니다.

93
00:06:26,450 --> 00:06:30,874
평균 성과가 합리적인 single real number 평가 지표라고 하면

94
00:06:30,874 --> 00:06:33,799
평균값을 산출함으로써,

95
00:06:33,799 --> 00:06:38,530
알고리즘 C가 가장 낮은 평균 에러 값을 가지고 있다는 것을 빨리
확인할 수 있습니다.

96
00:06:38,530 --> 00:06:40,555
그럼 바로 이 것을 선택할 수 있겠죠.

97
00:06:40,555 --> 00:06:44,490
지속적으로 반복할 알고리즘을 잘 골라야 합니다.

98
00:06:44,490 --> 00:06:47,573
머신러닝의 절차는 아이디어가 있고,

99
00:06:47,573 --> 00:06:51,970
그 아이디어를 도입하여 시도하고, 그 아이디어가 도움이 되었는지 확인하는 절차를 따릅니다.

100
00:06:51,970 --> 00:06:56,760
이 비디오에서 보여드렸다시피, single number 평가 지표를 이용함으로써,

101
00:06:56,760 --> 00:06:58,980
전체적인 효율성 높일 수 있고,

102
00:06:58,980 --> 00:07:02,340
프로젝트 팀이 효율적인 의사결정을 내릴 수 있도록 도와줍니다.

103
00:07:02,340 --> 00:07:03,240
효과적인 평가 지표를 구축하는 방법에 대한

104
00:07:03,240 --> 00:07:07,510
토론이 완전히 끝난 것은 아닙니다.

105
00:07:07,510 --> 00:07:08,430
다음 비디오에서는

106
00:07:08,430 --> 00:07:13,880
최적화의 만족스러운 매트릭스를 설정하는 방법에 대해서 공유하도록 하겠습니다.

107
00:07:13,880 --> 00:07:15,480
자 그럼 다음 비디오를 보도록 하겠습니다.