1
00:00:00,000 --> 00:00:02,910
여러분이 중요시 여기는 부분을 모두 감안하여 single row 평가 지표로

2
00:00:02,910 --> 00:00:06,265
결합시키는 것은 쉬운 일이 아닙니다.

3
00:00:06,265 --> 00:00:09,150
개인적으로 이런 경우에는 satisficing (최소한의 충족)과 optimizing (최적화) 매트릭스가

4
00:00:09,150 --> 00:00:12,390
간혹 유용한 경우가 있었습니다.

5
00:00:12,390 --> 00:00:13,950
어떤 말인지 자세히 설명해드리도록 하겠습니다.

6
00:00:13,950 --> 00:00:16,410
고양이 인식 프로그램의 classification 정확도를

7
00:00:16,410 --> 00:00:20,694
중요한 요소를 생각하게 되었다고 가정해봅시다.

8
00:00:20,694 --> 00:00:25,470
정확도를 측정하는 요소는 F1 score가 될 수도 있고 다른 수치일수도 있습니다.

9
00:00:25,470 --> 00:00:29,610
이러한 정확도뿐만 아니라 러닝 타임도 고려한다고 가정해보죠.

10
00:00:29,610 --> 00:00:35,050
이미지를 올바르게 분별하는데 얼마나 걸릴까요? classifier A 는 80 밀리세컨드,

11
00:00:35,050 --> 00:00:36,690
B는 95 밀리세컨드 걸립니다.

12
00:00:36,690 --> 00:00:39,325
그리고 C는 1,500 밀리세컨드 소요됩니다.

13
00:00:39,325 --> 00:00:42,150
이것은 이미지를 판별하는데 총 1.5초가 소요된다는 것이죠.

14
00:00:42,150 --> 00:00:45,000
한가지 할 수 있는 방법은, 정확도를 러닝타임과 결합시켜서

15
00:00:45,000 --> 00:00:48,075
종합 평가 수치를 만드는 방법입니다.

16
00:00:48,075 --> 00:00:57,898
그렇게 해서, 종합비용과 같은 것은 정확도 빼기 0.5 곱하기 러닝타임 일 수 있겠죠.

17
00:00:57,898 --> 00:01:01,460
하지만 정확도와 러닝타임을 이런 공식을 이용하여

18
00:01:01,460 --> 00:01:05,265
결합시키는 프로세스 자체가 인공적이라 생각되실 수도 있죠.

19
00:01:05,265 --> 00:01:08,805
두 가지를 가중치 선형 조합을 이용하여 결합시키는 것처럼 말이죠.

20
00:01:08,805 --> 00:01:11,090
그러므로, 다른 방법으로는

21
00:01:11,090 --> 00:01:13,841
애초에 염두하고 있는 러닝타임이면서 동시에 정확도를 최대치로

22
00:01:13,841 --> 00:01:26,470
끌어올릴 수 있는 classifier를 고르는 방법이 있습니다.

23
00:01:26,470 --> 00:01:28,584
러닝타임이라고 하면 이미지를 판별하는 시간이라고 할 수 있습니다.

24
00:01:28,584 --> 00:01:36,325
이 수치는 100 밀리세컨드 이내여야 합니다.

25
00:01:36,325 --> 00:01:40,170
이 경우에는, 정확도가 optimizing metric이라고 할 수 있습니다.

26
00:01:40,170 --> 00:01:44,460
정확도를 최대치로 끌어올리고 싶기 때문이죠.

27
00:01:44,460 --> 00:01:48,195
정확도가 높으면 높을수록 좋으나,

28
00:01:48,195 --> 00:01:53,845
러닝타임이 satisficing metric이라고 하는 부분입니다.

29
00:01:53,845 --> 00:01:55,580
어느 정도 만족할만한 수치로 충족이 되면

30
00:01:55,580 --> 00:02:00,285
즉, 100 밀리세컨드 이내이면 그 이후로는 더 이상 신경을 쓰지 않는 것으로,

31
00:02:00,285 --> 00:02:04,280
적어도 그렇게 많은 노력을 기울이지 않는 것으로 생각하는 요소입니다.

32
00:02:04,280 --> 00:02:07,340
이런 방법이 균형을 찾는 적절한 방법이 됩니다.

33
00:02:07,340 --> 00:02:11,705
정확도와 러닝타임을 적정선에서 모두 고려하는 것이죠.

34
00:02:11,705 --> 00:02:16,015
러닝타임이 100 밀리세컨드 이내인 이상,

35
00:02:16,015 --> 00:02:18,465
유저들이 그다 신경을 많이 쓰지 않을 수도 있고,

36
00:02:18,465 --> 00:02:21,855
50 밀리세컨드이건 100 밀리세컨드이건 말이죠.

37
00:02:21,855 --> 00:02:26,380
optimizing과 satisficing matrix를 정의하면서,

38
00:02:26,380 --> 00:02:30,475
가장 좋은 classifier를 선정하는 선명한 방법을 제시합니다.

39
00:02:30,475 --> 00:02:34,450
이 케이스 같은 경우, classifier B가 될 텐데요, 이유인 즉 슨

40
00:02:34,450 --> 00:02:39,865
모든 100 밀리세컨드 이내인 것 중에서 가장 정확도가 높은 classifier이기 때문입니다.

41
00:02:39,865 --> 00:02:45,220
일반적으로, 신중히 생각하는 N개의 매트릭스가 있으면

42
00:02:45,220 --> 00:02:50,830
한가지를 최적화된 것으로 고르는 것이 합리적입니다.

43
00:02:50,830 --> 00:02:54,005
그렇게 선택한 것에 대해선 가능한 한 잘 해야 합니다.

44
00:02:54,005 --> 00:02:57,515
그 이후, N-1을 satisficing으로 선택합니다.

45
00:02:57,515 --> 00:02:59,380
즉, 러닝타임이 100 밀리세컨드

46
00:02:59,380 --> 00:03:02,730
한계치 이내인 경우를 선별하는 것입니다.

47
00:03:02,730 --> 00:03:04,405
그 범위 안에 속하면,

48
00:03:04,405 --> 00:03:06,520
얼마나 그 이상 빠른지 여부는 그다 신경 쓰지 않고

49
00:03:06,520 --> 00:03:09,455
물론 그 한계치 이내이긴 하지만, 그 이후로는 동일 히 여깁니다.

50
00:03:09,455 --> 00:03:11,350
또 하나의 예제를 보도록 합시다.

51
00:03:11,350 --> 00:03:15,280
wake words를 감지하는 시스템을 만든다고 가정해봅시다.

52
00:03:15,280 --> 00:03:19,030
trigger word라고도 표현하죠.

53
00:03:19,030 --> 00:03:22,900
이것은 아마존 Echo와 같은 음성인식기기에서

54
00:03:22,900 --> 00:03:25,780
보통 시스템기기를 깨울 때, 사용하는 단어를 말하는데요,

55
00:03:25,780 --> 00:03:29,020
Alexa라고 이야기해서 활성화 작동시키거나

56
00:03:29,020 --> 00:03:35,095
google 같은 경우 okay라고 말하거나, 애플 같은 경우 hey siri라고 말하여 기기를 깨우고,

57
00:03:35,095 --> 00:03:42,300
바이두 기기 같은 경우, you ni hao 바이두 라고 이야기하여 깨우는 예가 있습니다.

58
00:03:42,300 --> 00:03:46,390
아, 중국말을 읽고 싶으시겠군요, 이것은 니하오 바이두라고 읽습니다.

59
00:03:46,390 --> 00:03:51,560
이러한 wake words를 사용하여,

60
00:03:51,560 --> 00:03:54,350
음성인식기기를 깨우는데 사용하는데요

61
00:03:54,350 --> 00:03:56,990
이런 말을 한 후, 하고 싶은 말을 이어서 하는 것입니다.

62
00:03:56,990 --> 00:04:02,090
ni hao 바이두와 같은 중국 글자 같은 경우엔,

63
00:04:02,090 --> 00:04:07,935
trigger word detection 시스템의 정확도에 신경을 쓸 수도 있을 것입니다.

64
00:04:07,935 --> 00:04:10,325
어떤 사람이 이런 trigger word를 말하는 경우에,

65
00:04:10,325 --> 00:04:13,525
음성인식기기를 깨울 확률이 얼마나 될지 신경을 쓸 수 있죠.

66
00:04:13,525 --> 00:04:16,970
또한, 잘못된 긍정으로 인식되는 개수를 신경 쓸 수도 있겠죠.

67
00:04:16,970 --> 00:04:19,891
아무도 trigger word를 사용하지 않은 경우에도,

68
00:04:19,891 --> 00:04:23,294
무작위로 갑자기 기기가 스스로 인식하는 경우는 얼마나 자주 발생하는가?

69
00:04:23,294 --> 00:04:27,770
이런 경우에는 두 가지의 평가 지표를 결합하는 

70
00:04:27,770 --> 00:04:33,275
합리적인 방법으로 정확도를 최대치로 하고,

71
00:04:33,275 --> 00:04:35,165
만약 특정 trigger word를 말할 경우

72
00:04:35,165 --> 00:04:37,565
음성인식기기가 깨어날 확률을 최대치로 끌어올린 이후,

73
00:04:37,565 --> 00:04:39,215
이러한 결과를 바탕으로

74
00:04:39,215 --> 00:04:48,815
이중에서 24시간 이내에 1개 이내의 잘못된 긍정만 허용하도록

75
00:04:48,815 --> 00:04:51,070
하는 것입니다. 아시겠죠?

76
00:04:51,070 --> 00:04:53,760
이렇게 하여 기기가 무작위로 스스로 작동하는 경우가

77
00:04:53,760 --> 00:04:57,270
최대 딱 한번만 평균적으로 있을 수 있도록 설정하는 것입니다.

78
00:04:57,270 --> 00:05:00,900
이런 경우, 정확도가

79
00:05:00,900 --> 00:05:05,505
optimizing metric이 되고, 24시간 이내의 긍정오류의 개수가

80
00:05:05,505 --> 00:05:09,870
satisficing metric이 되는 것입니다. satisficing metric의 경우,

81
00:05:09,870 --> 00:05:14,490
24시간 이내 최대 1개의 긍정오류만 발생 시, 만족하는 방법입니다.

82
00:05:14,490 --> 00:05:17,100
요약하자면, 만약 고려요소가 여러 가지 있다고 하면,

83
00:05:17,100 --> 00:05:19,920
한가지의 가장 좋은 결과를 가지고 싶어하는

84
00:05:19,920 --> 00:05:22,530
optimizing metric으로 설정하고,

85
00:05:22,530 --> 00:05:25,475
한가지 이상은 satisficing metric을 통해 만족하는 수치의 범위를 설정합니다.

86
00:05:25,475 --> 00:05:29,430
특정 한계치를 일일이 찾는 것보다 거의 항상 잘 구현되며, 이제는

87
00:05:29,430 --> 00:05:32,310
자동으로 여러분은 빠른 속도로

88
00:05:32,310 --> 00:05:35,864
복수의 코어 사이즈 중 가장 좋은 것을 고를 수 있습니다.

89
00:05:35,864 --> 00:05:39,000
이런 평가 매트릭스는

90
00:05:39,000 --> 00:05:44,095
트레이닝세트 또는 dev set, 테스트세트에서 평가 또는 계산되어야 합니다.

91
00:05:44,095 --> 00:05:46,935
그래서 여러분이 하셔야 하는 것 중에 한가지는 바로 트레이닝을 설정하고,

92
00:05:46,935 --> 00:05:50,100
dev또는 development라는 개발단계와, 테스트를 set up하는 것입니다.

93
00:05:50,100 --> 00:05:52,800
다음 비디오에선 트레이닝, dev, 그리고 테스트세트를 잘 설정하는

94
00:05:52,800 --> 00:05:55,800
가이드라인을 공유하고 싶습니다.

95
00:05:55,800 --> 00:05:57,470
자 그럼 이제 다음 강의로 넘어가겠습니다.