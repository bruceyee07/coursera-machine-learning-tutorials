여러분이 중요시 여기는 부분을 모두 감안하여 single row 평가 지표로 결합시키는 것은 쉬운 일이 아닙니다. 개인적으로 이런 경우에는 satisficing (최소한의 충족)과 optimizing (최적화) 매트릭스가 간혹 유용한 경우가 있었습니다. 어떤 말인지 자세히 설명해드리도록 하겠습니다. 고양이 인식 프로그램의 classification 정확도를 중요한 요소를 생각하게 되었다고 가정해봅시다. 정확도를 측정하는 요소는 F1 score가 될 수도 있고 다른 수치일수도 있습니다. 이러한 정확도뿐만 아니라 러닝 타임도 고려한다고 가정해보죠. 이미지를 올바르게 분별하는데 얼마나 걸릴까요? classifier A 는 80 밀리세컨드, B는 95 밀리세컨드 걸립니다. 그리고 C는 1,500 밀리세컨드 소요됩니다. 이것은 이미지를 판별하는데 총 1.5초가 소요된다는 것이죠. 한가지 할 수 있는 방법은, 정확도를 러닝타임과 결합시켜서 종합 평가 수치를 만드는 방법입니다. 그렇게 해서, 종합비용과 같은 것은 정확도 빼기 0.5 곱하기 러닝타임 일 수 있겠죠. 하지만 정확도와 러닝타임을 이런 공식을 이용하여 결합시키는 프로세스 자체가 인공적이라 생각되실 수도 있죠. 두 가지를 가중치 선형 조합을 이용하여 결합시키는 것처럼 말이죠. 그러므로, 다른 방법으로는 애초에 염두하고 있는 러닝타임이면서 동시에 정확도를 최대치로 끌어올릴 수 있는 classifier를 고르는 방법이 있습니다. 러닝타임이라고 하면 이미지를 판별하는 시간이라고 할 수 있습니다. 이 수치는 100 밀리세컨드 이내여야 합니다. 이 경우에는, 정확도가 optimizing metric이라고 할 수 있습니다. 정확도를 최대치로 끌어올리고 싶기 때문이죠. 정확도가 높으면 높을수록 좋으나, 러닝타임이 satisficing metric이라고 하는 부분입니다. 어느 정도 만족할만한 수치로 충족이 되면 즉, 100 밀리세컨드 이내이면 그 이후로는 더 이상 신경을 쓰지 않는 것으로, 적어도 그렇게 많은 노력을 기울이지 않는 것으로 생각하는 요소입니다. 이런 방법이 균형을 찾는 적절한 방법이 됩니다. 정확도와 러닝타임을 적정선에서 모두 고려하는 것이죠. 러닝타임이 100 밀리세컨드 이내인 이상, 유저들이 그다 신경을 많이 쓰지 않을 수도 있고, 50 밀리세컨드이건 100 밀리세컨드이건 말이죠. optimizing과 satisficing matrix를 정의하면서, 가장 좋은 classifier를 선정하는 선명한 방법을 제시합니다. 이 케이스 같은 경우, classifier B가 될 텐데요, 이유인 즉 슨 모든 100 밀리세컨드 이내인 것 중에서 가장 정확도가 높은 classifier이기 때문입니다. 일반적으로, 신중히 생각하는 N개의 매트릭스가 있으면 한가지를 최적화된 것으로 고르는 것이 합리적입니다. 그렇게 선택한 것에 대해선 가능한 한 잘 해야 합니다. 그 이후, N-1을 satisficing으로 선택합니다. 즉, 러닝타임이 100 밀리세컨드 한계치 이내인 경우를 선별하는 것입니다. 그 범위 안에 속하면, 얼마나 그 이상 빠른지 여부는 그다 신경 쓰지 않고 물론 그 한계치 이내이긴 하지만, 그 이후로는 동일 히 여깁니다. 또 하나의 예제를 보도록 합시다. wake words를 감지하는 시스템을 만든다고 가정해봅시다. trigger word라고도 표현하죠. 이것은 아마존 Echo와 같은 음성인식기기에서 보통 시스템기기를 깨울 때, 사용하는 단어를 말하는데요, Alexa라고 이야기해서 활성화 작동시키거나 google 같은 경우 okay라고 말하거나, 애플 같은 경우 hey siri라고 말하여 기기를 깨우고, 바이두 기기 같은 경우, you ni hao 바이두 라고 이야기하여 깨우는 예가 있습니다. 아, 중국말을 읽고 싶으시겠군요, 이것은 니하오 바이두라고 읽습니다. 이러한 wake words를 사용하여, 음성인식기기를 깨우는데 사용하는데요 이런 말을 한 후, 하고 싶은 말을 이어서 하는 것입니다. ni hao 바이두와 같은 중국 글자 같은 경우엔, trigger word detection 시스템의 정확도에 신경을 쓸 수도 있을 것입니다. 어떤 사람이 이런 trigger word를 말하는 경우에, 음성인식기기를 깨울 확률이 얼마나 될지 신경을 쓸 수 있죠. 또한, 잘못된 긍정으로 인식되는 개수를 신경 쓸 수도 있겠죠. 아무도 trigger word를 사용하지 않은 경우에도, 무작위로 갑자기 기기가 스스로 인식하는 경우는 얼마나 자주 발생하는가? 이런 경우에는 두 가지의 평가 지표를 결합하는 합리적인 방법으로 정확도를 최대치로 하고, 만약 특정 trigger word를 말할 경우 음성인식기기가 깨어날 확률을 최대치로 끌어올린 이후, 이러한 결과를 바탕으로 이중에서 24시간 이내에 1개 이내의 잘못된 긍정만 허용하도록 하는 것입니다. 아시겠죠? 이렇게 하여 기기가 무작위로 스스로 작동하는 경우가 최대 딱 한번만 평균적으로 있을 수 있도록 설정하는 것입니다. 이런 경우, 정확도가 optimizing metric이 되고, 24시간 이내의 긍정오류의 개수가 satisficing metric이 되는 것입니다. satisficing metric의 경우, 24시간 이내 최대 1개의 긍정오류만 발생 시, 만족하는 방법입니다. 요약하자면, 만약 고려요소가 여러 가지 있다고 하면, 한가지의 가장 좋은 결과를 가지고 싶어하는 optimizing metric으로 설정하고, 한가지 이상은 satisficing metric을 통해 만족하는 수치의 범위를 설정합니다. 특정 한계치를 일일이 찾는 것보다 거의 항상 잘 구현되며, 이제는 자동으로 여러분은 빠른 속도로 복수의 코어 사이즈 중 가장 좋은 것을 고를 수 있습니다. 이런 평가 매트릭스는 트레이닝세트 또는 dev set, 테스트세트에서 평가 또는 계산되어야 합니다. 그래서 여러분이 하셔야 하는 것 중에 한가지는 바로 트레이닝을 설정하고, dev또는 development라는 개발단계와, 테스트를 set up하는 것입니다. 다음 비디오에선 트레이닝, dev, 그리고 테스트세트를 잘 설정하는 가이드라인을 공유하고 싶습니다. 자 그럼 이제 다음 강의로 넘어가겠습니다.